var tipuesearch = {"pages":[{"text":"StringiFor StringiFor StringiFor, Strings Fortran Manipulator, yet another strings Fortran module A KISS pure Fortran library providing  astrings (class) manipulator for modern (2003+) Fortran projects. StringiFor is a pure Fortran (KISS) library providing a strings manipulator for modern Fortran projects; StringiFor is Fortran 2003+ standard compliant; StringiFor is OOP designed; StringiFor is TDD designed; StringiFor is a Free, Open Source Project. Issues Compiler Support GNU partial support GNU gfortran does not support user-defined-type-IO, thus some class features are disabled if GNU is used. What is StringiFor? ♺ Main features ♺ Copyrights ♺ Download ♺ Compilation ♺ Documentation What is StringiFor? Modern Fortran standards (2003+) have introduced a better support for characters variables, but Fortraners still do not have the power on dealing with strings of other more-rich-programmers, e.g. Pythoners. Allocatable deferred length character variables are now quantum-leap with respect the old inflexible Fortran characters, but it is still not enough for many Fortraners. Moreover, Fortran does not provide builtin methods for widely used strings manipulations offered by other languages, e.g. UPPER/lowercase transformation, tokenization, etc… StringiFor attempts to fill this lack. Go to Top Main features StringiFor exposes only one class (OO-designed), the string type, that should be used as a more powerful string variable with respect a standard Fortran character variable. The main features of this class are: seamless interchangeability with standard character variables, e.g. concatenation, IO, etc…; handy builtin methods, e.g. split, search, basename, join, etc…; low memory consumption: only one deferred length allocatable character member is stored, allowing for efficient memory allocation in array of strings, the elements of which can have different lengths; safe: almost all methods are elemental or pure; robust: the library is Test Driven Developed TDD , a comprehensive tests suite is provided. Any feature request is welcome. Go to Top Copyrights StringiFor is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to StringiFor is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Download To be written. Go to Top Compilation To be written. Go to Top Documentation The StringiFor documentation is mainly contained into this file (it has its own wiki with some less important documents). Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of StringiFor Basic IO String manipulation Numbers handling Complex scenario Methods API A Taste of StringiFor StringiFor is very handy… Basic IO The class string IO is overloaded by defined write/read TBP. Moreover, dedicated methods and operators can be exploited for IO, e.g. use stringifor type ( string ) :: astring astring = 'Hello World' print \"(A)\" , astring % chars () ! \"chars\" method returns a standard character variable print \"(DT)\" , astring ! defined IO is not enabled with GNU gfortran print \"(A)\" , astring // '' ! on-the-fly conversion to standard character by means of concatenation String manipulation The class string has many methods for a plethora of strings manipulations, e.g. use stringifor type ( string ) :: astring type ( string ) :: strings ( 3 ) astring = '0123456789' print \"(A)\" , astring % reverse () // '' ! print \"9876543210\" astring = 'Hello World' print \"(A)\" , astring % replace ( old = 'World' , new = 'People' ) // '' ! print \"Hello People\" astring = 'Hello World' strings = astring % partition ( sep = 'lo Wo' ) print \"(A)\" , 'Before sep: \"' // strings ( 1 ) // '\"' ! print \"Hel\" print \"(A)\" , 'Sep itself: \"' // strings ( 2 ) // '\"' ! print \"lo Wo\" print \"(A)\" , 'After sep:  \"' // strings ( 3 ) // '\"' ! print \"rld\" strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' print \"(A)\" , astring % join ( strings ) // '' ! print \"onetwothree\" print \"(A)\" , astring % join ( strings , sep = '-' ) // '' ! print \"one-two-three\" astring = ' a StraNgE caSe var' print \"(A)\" , astring % camelcase () // '' ! print \" AStrangeCaseVar\" print \"(A)\" , astring % snakecase () // '' ! print \" a_strange_case_var\" print \"(A)\" , astring % startcase () // '' ! print \" A Strange Case Var\" Numbers handling StringiFor, by means of the portability environment library, PENF can handle numbers (reals and integers) effortless. The string/number casting (to/from and viceversa) is done by overloaded assignments (for all kinds of integers and reals). For convenience, StringiFor exposes the PENF number portable kind parameters. use stringifor type ( string ) :: astring astring = 127 _ I1P ! \"I1P\" is the PENF kind for 1-byte-like integer. print \"(A)\" , astring // '' ! print \"+127\" astring = 3.021e6_R4P ! \"R4P\" is the PENF kind for 4-byte-like real. print \"(A)\" , astring // '' ! print \"+0.302100E+07\" astring = \"3.4e9\" ! assign to a string without the necessity to define a real kind if ( astring % is_number ()) then if ( astring % is_real ()) then print \"(E13.6)\" , astring % to_number ( kind = 1._R4P ) ! print \" 0.340000E+10\" using a 4-byte-like kind endif endif Complex scenario StingiFor is developed to improve the poor Fortran people with daily strings-usage, however, also complex scenario is taken into account, e.g. file parsing, OS operations, etc… use stringifor type ( string ) :: astring ! OS like manipulation astring = '/bar/foo.tar.bz2' print \"(A)\" , astring % basedir () // '' ! print \"/bar\" print \"(A)\" , astring % basename () // '' ! print \"foo.tar.bz2\" print \"(A)\" , astring % basename ( extension = '.tar' ) // '' ! print \"foo\" print \"(A)\" , astring % basename ( last_extension = . true .) // '' ! print \"foo.tar\" ! XML like tag parsing astring = '<test> <first> hello </first> <first> not the first </first> </test>' print \"(A)\" , astring % search ( tag_start = '<first>' , tag_end = '</first>' ) // '' ! print \"<first> hello </first>\" Methods API In the following all the methods of string are listed with a brief description of their aim. The hyperlinks bring you to the full API explained into the GH pages. String manipulations & Co.: basedir return the base directory name of a string containing a file name. basename return the base file name of a string containing a file name. camelcase return a string with all words capitalized without spaces. capitalize return a string with its first character capitalized and the rest lowercased. chars return the raw characters data. escape escape backslashes (or custom escape character). extension return the extension of a string containing a file name. fill pad string on the left (or right) with zeros (or other char) to fill width. free free dynamic memory. join return a string that is a join of an array of strings or characters. lower return a string with all lowercase characters. partition split string at separator and return the 3 parts (before, the separator and after). replace return a string with all occurrences of substring old replaced by new. reverse return a reversed string. search search for tagged record into string. snakecase return a string with all words lowercase separated by \"_\". split return a list of substring in the string, using sep as the delimiter string. startcase return a string with all words capitalized, e.g. title case. strip return a string with the leading and trailing characters removed. swapcase return a string with uppercase chars converted to lowercase and vice versa. to_number cast string to number. unique reduce to one (unique) multiple occurrences of a substring into a string. upper return a string with all uppercase characters. inquires: end_with return true if a string ends with a specified suffix. is_allocated return true if the string is allocated. is_digit return true if all characters in the string are digits. is_integer return true if the string contains an integer. is_lower return true if all characters in the string are lowercase. is_number return true if the string contains a number (real or integer). is_real return true if the string contains an real. is_upper return true if all characters in the string are uppercase. start_with return true if a string starts with a specified prefix. builtins replacements: sadjustl adjustl replacement. sadjustr adjustr replacement. scount count replacement. sindex index replacement. slen len replacement. slen_trim len_trim replacement. srepeat repeat replacement. sscan scan replacement. strim trim replacement. sverify verify replacement. IO: read(formatted) formatted input. write(formatted) formatted output. read(unformatted) unformatted input. write(unformatted) unformatted output. operators: assignment assignment of string from different inputs. // concatenation resulting in characters for seamless integration. Go to Top Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" StringiFor "},{"text":"Portability Environment for Fortran poor people. Source Code !< Portability Environment for Fortran poor people. module penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !< PENF global (exposed) parameters and variables. !< !< @note All module defined entities are public. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none public save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_initialized = . false . !< Check the initialization of some variables that must be initialized. integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. integer :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Portable kind parameters #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33 digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Format parameters #ifdef r16p character ( * ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P real. #else character ( * ), parameter :: FR16P = '(E23.15E3)' !< Output format for kind=R16P real. #endif character ( * ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P real. character ( * ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P real. character ( * ), parameter :: FR_P = FR8P !< Output format for kind=R_P real. character ( * ), parameter :: FI8P = '(I20)' !< Output format for kind=I8P integer. character ( * ), parameter :: FI8PZP = '(I20.19)' !< Output format for kind=I8P integer with zero prefixing. character ( * ), parameter :: FI4P = '(I11)' !< Output format for kind=I4P integer. character ( * ), parameter :: FI4PZP = '(I11.10)' !< Output format for kind=I4P integer with zero prefixing. character ( * ), parameter :: FI2P = '(I6)' !< Output format for kind=I2P integer. character ( * ), parameter :: FI2PZP = '(I6.5)' !< Output format for kind=I2P integer with zero prefixing. character ( * ), parameter :: FI1P = '(I4)' !< Output format for kind=I1P integer. character ( * ), parameter :: FI1PZP = '(I4.3)' !< Output format for kind=I1P integer with zero prefixing. character ( * ), parameter :: FI_P = FI4P !< Output format for kind=I_P integer. character ( * ), parameter :: FI_PZP = FI4PZP !< Output format for kind=I_P integer with zero prefixing. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Length (number of digits) of formatted numbers #ifdef r16p integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. #else integer , parameter :: DR16P = 23 !< Number of digits of output format FR16P. #endif integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! List of kinds integer , parameter :: REAL_KINDS_LIST ( 1 : 4 ) = [ R16P , R8P , R4P , R_P ] !< List of real kinds. character ( * ), parameter :: REAL_FORMATS_LIST ( 1 : 4 ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of real formats. integer , parameter :: INTEGER_KINDS_LIST ( 1 : 5 ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of integer kinds. character ( * ), parameter :: INTEGER_FORMATS_LIST ( 1 : 5 ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of integer formats. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Minimum and maximum (representable) values real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P real. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P real. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P real. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P real. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P real. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P real. real ( R_P ), parameter :: MinR_P = MinR8P !< Minimum value of kind=R_P real. real ( R_P ), parameter :: MaxR_P = MaxR8P !< Maximum value of kind=R_P real. integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P integer. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P integer. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P integer. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P integer. integer ( I_P ), parameter :: MinI_P = MinI4P !< Minimum value of kind=I_P integer. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P integer. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P integer. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P integer. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P integer. integer ( I_P ), parameter :: MaxI_P = MaxI4P !< Maximum value of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Real smallest (representable) values real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest representable value of kind=R16P real. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest representable value of kind=R8P real. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest representable value of kind=R4P real. real ( R_P ), parameter :: smallR_P = smallR8P !< Smallest representable value of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Smallest real representable difference by the running calculator real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P real. real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P real. real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P real. real ( R_P ), parameter :: Zero = ZeroR8 !< Smallest representable difference of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Bits/bytes memory requirements (real variables must be computed at runtime) integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P real. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P real. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P real. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P real. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P real. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P real. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P real. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P real. integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P integer. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P integer. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P integer. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P integer. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P integer. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P integer. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P integer. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P integer. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P integer. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- endmodule penf_global_parameters_variables module penf_b_size !----------------------------------------------------------------------------------------------------------------------------------- !< PENF bit/byte size functions. !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: bit_size , byte_size !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef r16p bit_size_R16P , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface byte_size !< Compute the number of bytes of a variable. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef r16p byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr endmodule penf_b_size module penf_stringify !----------------------------------------------------------------------------------------------------------------------------------- !< PENF string-to-number (and viceversa) facility. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stderr => ERROR_UNIT use penf_b_size use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: str , strz , cton public :: bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface str !< Convert number (real and integer) to string (number to string type casting). module procedure & #ifdef r16p strf_R16P , str_R16P , & #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef r16p str_a_R16P , & #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface strz !< Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). module procedure strz_I8P , strz_I4P , strz_I2P , strz_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface cton !< Convert string to number (real and integer, string to number type casting). module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bstr !< Convert number (real and integer) to bit-string (number to bit-string type casting). module procedure & #ifdef r16p bstr_R16P , & #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bcton !< Convert bit-string to number (real and integer, bit-string to number type casting). module procedure & #ifdef r16p bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P elemental function str_R16P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P elemental function str_R8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P elemental function str_R4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol pure function str_a_R16P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P pure function str_a_R8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P pure function str_a_R4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P pure function str_a_I8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P pure function str_a_I4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P pure function str_a_I2P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P pure function str_a_I1P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P endmodule penf_stringify module penf !----------------------------------------------------------------------------------------------------------------------------------- !< Portability Environment for Fortran poor people. !<{!README-PENF.md!} !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables #ifdef __GFORTRAN__ use penf_b_size , only : bit_size , byte_size #else use penf_b_size #endif use penf_stringify , only : str , strz , cton , bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! Global parameters and variables public :: endianL , endianB , endian , is_initialized public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16 public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: REAL_KINDS_LIST , REAL_FORMATS_LIST public :: INTEGER_KINDS_LIST , INTEGER_FORMATS_LIST ! Bit/byte size functions public :: bit_size , byte_size ! Stringify facility public :: str , strz , cton public :: bstr , bcton ! Miscellanea facility public :: check_endian public :: digit public :: penf_Init public :: penf_print !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef __GFORTRAN__ ! work-around for strange gfortran bug... interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. endinterface #endif !----------------------------------------------------------------------------------------------------------------------------------- interface digit !< Compute the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1 subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print endmodule penf","tags":"","loc":"sourcefile/penf.f90.html","title":"penf.F90 – StringiFor"},{"text":"StringiFor, Strings Fortran, yet another stringify Fortran module Source Code !< StringiFor, Strings Fortran, yet another stringify Fortran module module stringifor !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor, Strings Fortran, yet another stringify Fortran module !----------------------------------------------------------------------------------------------------------------------------------- use penf , only : I1P , I2P , I4P , I8P , R4P , R8P , R16P , str !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: string , CK ! expose PENF kinds public :: I1P , I2P , I4P , I8P , R4P , R8P , R16P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- integer , parameter :: CK = selected_char_kind ( 'DEFAULT' ) !< Default character kind. type :: string !< OOP designed string class. private character ( kind = CK , len = :), allocatable :: raw !< Raw data. contains ! public methods procedure , pass ( self ) :: basedir !< Return the base directory name of a string containing a file name. procedure , pass ( self ) :: basename !< Return the base file name of a string containing a file name. procedure , pass ( self ) :: camelcase !< Return a string with all words capitalized without spaces. procedure , pass ( self ) :: capitalize !< Return a string with its first character capitalized and the rest lowercased. procedure , pass ( self ) :: chars !< Return the raw characters data. procedure , pass ( self ) :: escape !< Escape backslashes (or custom escape character). procedure , pass ( self ) :: extension !< Return the extension of a string containing a file name. procedure , pass ( self ) :: fill !< Pad string on the left (or right) with zeros (or other char) to fill width. procedure , pass ( self ) :: free !< Free dynamic memory. generic :: join => & join_strings , & join_characters !< Return a string that is a join of an array of strings or characters. procedure , pass ( self ) :: lower !< Return a string with all lowercase characters. procedure , pass ( self ) :: partition !< Split string at separator and return the 3 parts (before, the separator and after). procedure , pass ( self ) :: replace !< Return a string with all occurrences of substring old replaced by new. procedure , pass ( self ) :: reverse !< Return a reversed string. procedure , pass ( self ) :: search !< Search for *tagged* record into string. procedure , pass ( self ) :: snakecase !< Return a string with all words lowercase separated by \"_\". procedure , pass ( self ) :: split !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: startcase !< Return a string with all words capitalized, e.g. title case. procedure , pass ( self ) :: strip !< Return a string with the leading and trailing characters removed. procedure , pass ( self ) :: swapcase !< Return a string with uppercase chars converted to lowercase and vice versa. generic :: to_number => & to_integer_I1P ,& to_integer_I2P ,& to_integer_I4P ,& to_integer_I8P ,& to_real_R4P , & #ifdef r16p to_real_R8P , & to_real_R16P !< Cast string to number. #else to_real_R8P !< Cast string to number. #endif procedure , pass ( self ) :: unique !< Reduce to one (unique) multiple occurrences of a substring into a string. procedure , pass ( self ) :: upper !< Return a string with all uppercase characters. ! inquire procedure , pass ( self ) :: end_with !< Return true if a string ends with a specified suffix. procedure , pass ( self ) :: is_allocated !< Return true if the string is allocated. procedure , pass ( self ) :: is_digit !< Return true if all characters in the string are digits. procedure , pass ( self ) :: is_integer !< Return true if the string contains an integer. procedure , pass ( self ) :: is_lower !< Return true if all characters in the string are lowercase. procedure , pass ( self ) :: is_number !< Return true if the string contains a number (real or integer). procedure , pass ( self ) :: is_real !< Return true if the string contains an real. procedure , pass ( self ) :: is_upper !< Return true if all characters in the string are uppercase. procedure , pass ( self ) :: start_with !< Return true if a string starts with a specified prefix. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character , & string_assign_integer_I1P , & string_assign_integer_I2P , & string_assign_integer_I4P , & string_assign_integer_I8P , & string_assign_real_R4P , & #ifdef r16p string_assign_real_R8P , & string_assign_real_R16P !< Assignment operator overloading. #else string_assign_real_R8P !< Assignment operator overloading. #endif generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. ! builtins replacements procedure , pass ( self ) :: sadjustl !< Adjustl replacement. procedure , pass ( self ) :: sadjustr !< Adjustr replacement. procedure , pass ( self ) :: scount !< Count replacement. procedure , pass ( self ) :: sindex !< Index replacement. procedure , pass ( self ) :: slen !< Len replacement. procedure , pass ( self ) :: slen_trim !< Len_trim replacement. procedure , nopass :: srepeat !< Repeat replacement. procedure , pass ( self ) :: sscan !< Scan replacement. procedure , pass ( self ) :: strim !< Trim replacement. procedure , pass ( self ) :: sverify !< Verify replacement. ! IO #ifndef __GFORTRAN__ generic :: read ( formatted ) => read_formatted_ !< Formatted input. generic :: write ( formatted ) => write_formatted_ !< Formatted output. generic :: read ( unformatted ) => read_unformatted_ !< Unformatted input. generic :: write ( unformatted ) => write_unformatted_ !< Unformatted output. #else procedure , pass ( dtv ) :: read_formatted => read_formatted_ !< Formatted input. procedure , pass ( dtv ) :: read_formatted_internal !< Formatted input from internal. procedure , pass ( dtv ) :: write_formatted => write_formatted_ !< Formatted output. procedure , pass ( dtv ) :: write_formatted_internal !< Formatted output to internal. #endif ! private methods procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_assign_integer_I1P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I2P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I4P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I8P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_real_R4P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R8P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R16P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). procedure , private , pass ( dtv ) :: read_formatted_ !< Formatted input. procedure , private , pass ( dtv ) :: write_formatted_ !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted_ !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted_ !< Unformatted output. procedure , private , pass ( self ) :: replace_one_occurrence !< Replace the first occurrence of substring old by new. procedure , private , pass ( self ) :: join_strings !< Return join string of an array of strings. procedure , private , pass ( self ) :: join_characters !< Return join string of an array of characters. procedure , private , pass ( self ) :: to_integer_I1P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I2P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I4P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I8P !< Cast string to integer. procedure , private , pass ( self ) :: to_real_R4P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R8P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R16P !< Cast string to real. endtype string character ( kind = CK , len = 26 ), parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( kind = CK , len = 26 ), parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. character ( kind = CK , len = 1 ), parameter :: SPACE = ' ' !< Space character. character ( kind = CK , len = 1 ), parameter :: TAB = achar ( 9 ) !< Tab character. character ( kind = CK , len = 1 ), parameter :: UIX_DIR_SEP = char ( 47 ) !< Unix/Linux directories separator (/). character ( kind = CK , len = 1 ), parameter :: BACKSLASH = char ( 92 ) !< Backslash character. !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental function basedir ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base directory name of a string containing a file name. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = '/bar/foo.tar.bz2' !< print '(A)', astring%basedir()//'' ! print \"/bar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. type ( string ) :: basedir !< Base directory name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basedir = self pos = index ( self % raw , sep_ , back = . true .) if ( pos > 0 ) basedir % raw = self % raw ( 1 : pos - 1 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basedir elemental function basename ( self , sep , extension , strip_last_extension ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'bar/foo.tar.bz2' !< print '(A)', astring%basename(extension='.tar.bz2')//''        ! print \"foo\" !< print '(A)', astring%basename(strip_last_extension=.true.)//'' ! print \"foo.tar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , sep_ , back = . true .) if ( pos > 0 ) basename % raw = temporary ( pos + 1 :) #else pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) #endif if ( present ( extension )) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , extension , back = . true .) if ( pos > 0 ) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) #endif elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , '.' , back = . true .) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , '.' , back = . true .) basename % raw = basename % raw ( 1 : pos - 1 ) #endif endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basename elemental function camelcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction camelcase elemental function capitalize ( self ) result ( capitalized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with its first character capitalized and the rest lowercased. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction capitalize pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars elemental function escape ( self , to_escape , esc ) result ( escaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Escape backslashes (or custom escape character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to be escaped, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction escape elemental function extension ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the extension of a string containing a file name. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: extension !< Extension file name. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then extension = '' pos = index ( self % raw , '.' , back = . true .) #ifdef __GFORTRAN__ temporary = self % raw if ( pos > 0 ) extension % raw = temporary ( pos :) #else if ( pos > 0 ) extension % raw = self % raw ( pos :) #endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction extension elemental function fill ( self , width , right , filling_char ) result ( filled ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pad string on the left (or right) with zeros (or other char) to fill width. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: width !< Final width of filled string. logical , intent ( in ), optional :: right !< Fill on the right instead of left. character ( kind = CK , len = 1 ), intent ( in ), optional :: filling_char !< Filling character (default \"0\"). type ( string ) :: filled !< Filled string. logical :: right_ !< Fill on the right instead of left, local variable. character ( kind = CK , len = 1 ) :: filling_char_ !< Filling character (default \"0\"), local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( width > len ( self % raw )) then right_ = . false . ; if ( present ( right )) right_ = right filling_char_ = '0' ; if ( present ( filling_char )) filling_char_ = filling_char if (. not . right_ ) then filled % raw = repeat ( filling_char_ , width - len ( self % raw )) // self % raw else filled % raw = self % raw // repeat ( filling_char_ , width - len ( self % raw )) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction fill elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) deallocate ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental function lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all lowercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: lower !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then lower = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) lower % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lower pure function partition ( self , sep ) result ( partitions ) !--------------------------------------------------------------------------------------------------------------------------------- !< Split string at separator and return the 3 parts (before, the separator and after). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: partitions ( 1 : 3 ) !< Partions: before the separator, the separator itsels and !< after the separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: c !< Character counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep partitions ( 1 ) = self partitions ( 2 ) = sep_ partitions ( 3 ) = '' if ( len ( sep_ ) >= len ( self % raw )) return c = index ( self % raw , sep_ ) if ( c > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw partitions ( 1 )% raw = temporary ( 1 : c - 1 ) partitions ( 2 )% raw = temporary ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = temporary ( c + len ( sep_ ):) #else partitions ( 1 )% raw = self % raw ( 1 : c - 1 ) partitions ( 2 )% raw = self % raw ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = self % raw ( c + len ( sep_ ):) #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction partition elemental function replace ( self , old , new , count ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all occurrences of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. integer , intent ( in ), optional :: count !< Number of old occurences to be replaced. type ( string ) :: replaced !< The string with old replaced by new. integer :: r !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self r = 0 do if ( index ( replaced % raw , old ) > 0 ) then replaced = replaced % replace_one_occurrence ( old = old , new = new ) r = r + 1 if ( present ( count )) then if ( r >= count ) exit endif else exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace elemental function reverse ( self ) result ( reversed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a reversed string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: reversed !< The reversed string. integer :: length !< Length of the string. integer :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then reversed = self length = len ( self % raw ) do c = 1 , length reversed % raw ( c : c ) = self % raw ( length - c + 1 : length - c + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction reverse elemental function snakecase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words lowercase separated by \"_\". !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: snakecase !< Snake case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % lower () snakecase = snakecase % join ( array = tokens , sep = '_' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction snakecase function search ( self , tag_start , tag_end , in_string , in_character , istart , iend ) result ( tag ) !--------------------------------------------------------------------------------------------------------------------------------- !< Search for *tagged* record into string, return the first record found (if any) matching the tags. !< !< Optionally, returns the indexes of tag start/end, thus this is not an `elemental` function. !< !< @note The tagged record is searched into self if allocated otherwise into `in_string` if passed or, eventually, into !< `in_character` is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are !< zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: tag_start !< Start tag. character ( kind = CK , len =* ), intent ( in ) :: tag_end !< End tag. type ( string ), intent ( in ), optional :: in_string !< Search into this string. character ( kind = CK , len =* ), intent ( in ), optional :: in_character !< Search into this character string. integer , intent ( out ), optional :: istart !< Starting index of tag inside the string. integer , intent ( out ), optional :: iend !< Ending index of tag inside the string. type ( string ) :: tag !< First tag found. character ( kind = CK , len = :), allocatable :: raw !< Raw string into which search the tag. integer :: istart_ !< Starting index of tag inside the string, local variable. integer :: iend_ !< Ending index of tag inside the string, local variable. logical :: found !< Flag for inquiring search result. integer :: nested_tags !< Number of nested tags inside tag. integer :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- raw = '' if ( present ( in_string )) then raw = in_string % raw elseif ( present ( in_character )) then raw = in_character else if ( allocated ( self % raw )) then raw = self % raw endif endif istart_ = 0 iend_ = 0 if ( raw /= '' ) then found = . false . istart_ = index ( raw , tag_start ) iend_ = index ( raw , tag_end ) if ( istart_ > 0. and . iend_ > 0 ) then iend_ = iend_ + len ( tag_end ) - 1 tag % raw = raw ( istart_ : iend_ ) nested_tags = tag % scount ( tag_start ) if ( nested_tags > 1 ) then do t = 2 , nested_tags iend_ = iend_ + len ( tag_end ) - 1 + index ( raw ( iend_ + 1 :), tag_end ) enddo tag % raw = raw ( istart_ : iend_ ) endif endif endif if ( present ( istart )) istart = istart_ if ( present ( iend )) iend = iend_ return !--------------------------------------------------------------------------------------------------------------------------------- endfunction search pure subroutine split ( self , tokens , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a list of substring in the string, using sep as the delimiter string. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: No !< Number of occurrences of sep. integer :: t !< Character counter. type ( string ) :: temporary !< Temporary storage. type ( string ), allocatable :: temp_toks (:,:) !< Temporary tokens substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep temporary = self % unique ( sep_ ) No = temporary % scount ( sep_ ) allocate ( temp_toks ( 3 , No )) temp_toks (:, 1 ) = temporary % partition ( sep_ ) if ( No > 1 ) then do t = 2 , No temp_toks (:, t ) = temp_toks ( 3 , t - 1 )% partition ( sep_ ) enddo endif if ( temp_toks ( 1 , 1 )% raw /= '' . and . temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No + 1 )) do t = 1 , No if ( t == No ) then tokens ( t ) = temp_toks ( 1 , t ) tokens ( t + 1 ) = temp_toks ( 3 , t ) else tokens ( t ) = temp_toks ( 1 , t ) endif enddo elseif ( temp_toks ( 1 , 1 )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No tokens ( t ) = temp_toks ( 1 , t ) enddo elseif ( temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No )) do t = 2 , No if ( t == No ) then tokens ( t - 1 ) = temp_toks ( 1 , t ) tokens ( t ) = temp_toks ( 3 , t ) else tokens ( t - 1 ) = temp_toks ( 1 , t ) endif enddo else allocate ( tokens ( No - 1 )) do t = 2 , No tokens ( t - 1 ) = temp_toks ( 1 , t ) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine split elemental function startcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized, e.g. title case. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: startcase !< Start case string. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep call self % split ( tokens = tokens , sep = sep_ ) tokens = tokens % capitalize () startcase = startcase % join ( array = tokens , sep = sep_ ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction startcase elemental function strip ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with the leading and trailing characters removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: strip !< The stripped string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then strip = self % sadjustl () strip = strip % strim () endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strip elemental function swapcase ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with uppercase characters converted to lowercase and vice versa. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: swapcase !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then swapcase = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) then swapcase % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) else n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) swapcase % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction swapcase elemental function unique ( self , substring ) result ( uniq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: substring !< Substring which multiple occurences must be reduced to one. character ( kind = CK , len = :), allocatable :: substring_ !< Substring, default value. type ( string ) :: uniq !< String parsed. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then substring_ = SPACE ; if ( present ( substring )) substring_ = substring uniq = self do if (. not . uniq % sindex ( repeat ( substring_ , 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( substring_ , 2 ), new = substring_ ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unique elemental function upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all uppercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then upper = self do n1 = 1 , len ( self % raw ) n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) upper % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper ! inquire elemental function end_with ( self , suffix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string ends with a specified suffix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: suffix !< Searched suffix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: end_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- end_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( suffix ) <= len ( self % raw ( start_ : end_ ))) then end_with = index ( self % raw ( start_ : end_ ), suffix ) == ( len ( self % raw ( start_ : end_ )) - len ( suffix ) + 1 ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction end_with elemental function is_allocated ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string is allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_allocated !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_allocated = allocated ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_allocated elemental function is_digit ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are digits. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_digit !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_digit = . false . if ( allocated ( self % raw )) then do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( '0' : '9' ) is_digit = . true . case default is_digit = . false . exit end select enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_digit elemental function is_integer ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains an integer. !< !< The regular expression is `\\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3   | S4  | S5  | S6  | !< |-----|---------|-----|------|-----|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d+`|`[eE]`|`\\+?`|`\\d+`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | !< |----|----|----|----|----|----|----| !< |  F |  F |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L294) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_integer !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_integer = . true . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 6 ) is_integer = allow_spaces_ case ( 2 , 5 ) is_integer = allow_spaces_ stage = 6 case default is_integer = . false . endselect case ( '-' ) select case ( stage ) case ( 0 ) stage = 1 case default is_integer = . false . end select case ( '+' ) select case ( stage ) case ( 0 ) stage = 1 case ( 3 ) stage = 4 case default is_integer = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 case ( 3 : 4 ) stage = 5 case default continue endselect case ( 'e' , 'E' ) select case ( stage ) case ( 2 ) stage = 3 case default is_integer = . false . endselect case default is_integer = . false . endselect if (. not . is_integer ) exit enddo endif if ( is_integer ) then select case ( stage ) case ( 2 , 5 , 6 ) is_integer = . true . case default is_integer = . false . end select endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_integer elemental function is_lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are lowercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_lower !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_lower = . false . if ( allocated ( self % raw )) then is_lower = . true . do c = 1 , len ( self % raw ) if ( index ( UPPER_ALPHABET , self % raw ( c : c )) > 0 ) then is_lower = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_lower elemental function is_number ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a number (real or integer). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_number !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_number = ( self % is_integer ( allow_spaces = allow_spaces ). or . self % is_real ( allow_spaces = allow_spaces )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_number elemental function is_real ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a real. !< !< The regular expression is `\\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3  | S4  | S5     | S6      | S7  | S8  | !< |-----|---------|-----|-----|-----|--------|---------|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d*`|`\\.?`|`\\d*`|`[deDE]`|`[\\+\\-]?`|`\\d*`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | !< |----|----|----|----|----|----|----|----|----| !  |  F |  F |  T |  T |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L614) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_real !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. logical :: has_leading_digit !< Check the presence of leading digits. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_real = . true . has_leading_digit = . false . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 8 ) is_real = allow_spaces_ continue case ( 2 : 4 , 7 ) is_real = allow_spaces_ stage = 8 case default is_real = . false . endselect case ( '+' , '-' ) select case ( stage ) case ( 0 ) stage = 1 case ( 5 ) stage = 6 case default is_real = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 has_leading_digit = . true . case ( 3 ) stage = 4 case ( 5 : 6 ) stage = 7 case default continue endselect case ( '.' ) select case ( stage ) case ( 0 : 2 ) stage = 3 case default is_real = . false . endselect case ( 'e' , 'E' , 'd' , 'D' ) select case ( stage ) case ( 2 : 4 ) stage = 5 case default is_real = . false . endselect case default is_real = . false . endselect if (. not . is_real ) exit enddo endif if ( is_real ) then select case ( stage ) case ( 2 , 4 , 7 , 8 ) is_real = . true . case ( 3 ) is_real = has_leading_digit case default is_real = . false . endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_real elemental function is_upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are uppercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_upper !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_upper = . false . if ( allocated ( self % raw )) then is_upper = . true . do c = 1 , len ( self % raw ) if ( index ( LOWER_ALPHABET , self % raw ( c : c )) > 0 ) then is_upper = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_upper elemental function start_with ( self , prefix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string starts with a specified prefix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: prefix !< Searched prefix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: start_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- start_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( prefix ) <= len ( self % raw ( start_ : end_ ))) then start_with = index ( self % raw ( start_ : end_ ), prefix ) == 1 endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction start_with ! builtins replacements elemental function sadjustl ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl elemental function sadjustr ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr elemental function scount ( self , substring , ignore_isolated ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !< !< @note If `ignore_isolated` is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those !< occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a !< right companion). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: substring !< Substring. logical , intent ( in ), optional :: ignore_isolated !< Ignore \"isolated\" occurrences. integer :: No !< Number of occurrences. logical :: ignore_isolated_ !< Ignore \"isolated\" occurrences, local variable. integer :: c1 !< Counter. integer :: c2 !< Counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( allocated ( self % raw )) then if ( len ( substring ) > len ( self % raw )) return ignore_isolated_ = . false . ; if ( present ( ignore_isolated )) ignore_isolated_ = ignore_isolated #ifdef __GFORTRAN__ temporary = self % raw #endif c1 = 1 do #ifdef __GFORTRAN__ c2 = index ( string = temporary ( c1 :), substring = substring ) #else c2 = index ( string = self % raw ( c1 :), substring = substring ) #endif if ( c2 == 0 ) return if (. not .( ignore_isolated_ . and .( c1 == 1. or . c1 + c2 - 1 == len ( self % raw ) - len ( substring ) + 1 ))) then No = No + 1 endif c1 = c1 + c2 - 1 + len ( substring ) enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction scount elemental function sindex ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex elemental function slen ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen elemental function slen_trim ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string, ignoring any trailing blanks. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen_trim elemental function srepeat ( rstring , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = rstring , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat elemental function sscan ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan elemental function strim ( self ) result ( trimmed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Remove leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strim elemental function sverify ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sverify ! private methods elemental subroutine string_assign_string ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from string input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) lhs % raw = rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_string elemental subroutine string_assign_character ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from character input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_character elemental subroutine string_assign_integer_I1P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I1P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I1P elemental subroutine string_assign_integer_I2P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I2P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I2P elemental subroutine string_assign_integer_I4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I4P elemental subroutine string_assign_integer_I8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I8P elemental subroutine string_assign_real_R4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R4P elemental subroutine string_assign_real_R8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R8P elemental subroutine string_assign_real_R16P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R16P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R16P pure function string_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string pure function string_concat_character ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character pure function character_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string elemental function string_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( kind = CK , len = :), allocatable :: temporary !< Temporary concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string_string elemental function string_concat_character_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character_string elemental function character_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string_string subroutine read_formatted_ ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted_ subroutine read_formatted_internal ( dtv , iunit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input from internal. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. character ( kind = CK , len =* ), intent ( in ) :: iunit !< Internal unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted_internal subroutine write_formatted_ ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted_ subroutine write_formatted_internal ( dtv , iunit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output to internal. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. character ( kind = CK , len =* ), intent ( inout ) :: iunit !< Interanl unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted_internal subroutine read_unformatted_ ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_unformatted_ subroutine write_unformatted_ ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_unformatted_ elemental function replace_one_occurrence ( self , old , new ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with the first occurrence of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. type ( string ) :: replaced !< The string with old replaced by new. integer :: pos !< Position from which replace old. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self pos = index ( string = self % raw , substring = old ) if ( pos > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw if ( pos == 1 ) then replaced % raw = new // temporary ( len ( old ) + 1 :) else replaced % raw = temporary ( 1 : pos - 1 ) // new // temporary ( pos + len ( old ):) endif #else if ( pos == 1 ) then replaced % raw = new // self % raw ( len ( old ) + 1 :) else replaced % raw = self % raw ( 1 : pos - 1 ) // new // self % raw ( pos + len ( old ):) endif #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace_one_occurrence pure function join_strings ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_strings pure function join_characters ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_characters elemental function to_integer_I1P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I1P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I1P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I1P elemental function to_integer_I2P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I2P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I2P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I2P elemental function to_integer_I4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I4P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I4P elemental function to_integer_I8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I8P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I8P elemental function to_real_R4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R4P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R4P elemental function to_real_R8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R8P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R8P elemental function to_real_R16P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R16P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R16P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R16P endmodule stringifor","tags":"","loc":"sourcefile/stringifor.f90.html","title":"stringifor.F90 – StringiFor"},{"text":"StringiFor assignments test. Source Code !< StringiFor `assignments` test. program assignments !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `assignments` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string , I1P , I2P , I4P , I8P , R4P , R8P , R16P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. integer ( I1P ) :: ainteger_I1P !< A integer (I1P). integer ( I2P ) :: ainteger_I2P !< A integer (I2P). integer ( I4P ) :: ainteger_I4P !< A integer (I4P). integer ( I8P ) :: ainteger_I8P !< A integer (I8P). real ( R4P ) :: areal_R4P !< A real (R4P). real ( R8P ) :: areal_R8P !< A real (R8P). real ( R16P ) :: areal_R16P !< A real (R16P). logical :: test_passed ( 7 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . ainteger_I1P = 127_I1P astring = ainteger_I1P test_passed ( 1 ) = astring // '' == '+127' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 1 ) ainteger_I2P = 32767_I2P astring = ainteger_I2P test_passed ( 2 ) = astring // '' == '+32767' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 2 ) ainteger_I4P = 2147483647_I4P astring = ainteger_I4P test_passed ( 3 ) = astring // '' == '+2147483647' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 3 ) ainteger_I8P = - 9223372036854775807_I8P astring = ainteger_I8P test_passed ( 4 ) = astring // '' == '-9223372036854775807' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 4 ) areal_R4P = 3.021e6_R4P astring = areal_R4P test_passed ( 5 ) = astring // '' == '+0.302100E+07' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 5 ) areal_R8P = 7.00907641e23_R8P astring = areal_R8P test_passed ( 6 ) = astring // '' == '+0.700907641000000E+024' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 6 ) areal_R16P = 1.1e200_R16P astring = areal_R16P test_passed ( 7 ) = astring // '' == '+0.110000000000000000000000000000000E+0201' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 7 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram assignments","tags":"","loc":"sourcefile/assignments.f90.html","title":"assignments.f90 – StringiFor"},{"text":"StringiFor basename_dir test. Source Code !< StringiFor `basename_dir` test. program basename_dir !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `basename_dir` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '/bar/foo.tar.bz2' write ( stdout , \"(A)\" ) 'Original:                  \"' // astring // '\"' test_passed ( 1 ) = ( astring % basedir () // '' == '/bar' ) write ( stdout , \"(A)\" ) 'Basedir:                   \"' // astring % basedir () // '\"' test_passed ( 2 ) = ( astring % basename () // '' == 'foo.tar.bz2' ) write ( stdout , \"(A)\" ) 'Basename:                  \"' // astring % basename () // '\"' test_passed ( 3 ) = ( astring % basename ( extension = '.tar' ) // '' == 'foo' ) write ( stdout , \"(A)\" ) 'Basename (extension):      \"' // astring % basename ( extension = '.tar' ) // '\"' test_passed ( 4 ) = ( astring % basename ( strip_last_extension = . true .) // '' == 'foo.tar' ) write ( stdout , \"(A)\" ) 'Basename (last extension): \"' // astring % basename ( strip_last_extension = . true .) // '\"' astring = '\\bar\\foo.tar.bz2' write ( stdout , \"(A)\" ) 'Original (\\ sep):          \"' // astring // '\"' test_passed ( 5 ) = ( astring % basedir ( sep = '\\')//''==' \\ bar ') write(stdout, \"(A)\") ' Basedir : \"'//astring%basedir(sep='\\')//'\" ' test_passed(6) = (astring%basename(sep=' \\ ')//''==' foo . tar . bz2 ') write(stdout, \"(A)\") ' Basename : \"'//astring%basename(sep='\\')//'\" ' test_passed(7) = (astring%basename(sep=' \\ ', extension=' . tar ')//''==' foo ') write(stdout, \"(A)\") ' Basename ( extension ): \"'//astring%basename(sep='\\', extension='.tar')//'\" ' test_passed(8) = (astring%basename(sep=' \\ ', strip_last_extension=.true.)//''==' foo . tar ') write(stdout, \"(A)\") ' Basename ( last extension ): \"'//astring%basename(sep='\\', strip_last_extension=.true.)//'\" ' write(stdout, \"(A,L1)\") new_line(' a ')//' Are all tests passed ? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram basename_dir","tags":"","loc":"sourcefile/basename_dir.f90.html","title":"basename_dir.f90 – StringiFor"},{"text":"StringiFor camelcase test. Source Code !< StringiFor `camelcase` test. program camelcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `camelcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % camelcase () // '' == 'TheQuickBrownFoxJumpsOverTheLazyDog.' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % camelcase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram camelcase","tags":"","loc":"sourcefile/camelcase.f90.html","title":"camelcase.f90 – StringiFor"},{"text":"StringiFor capitalize test. Source Code !< StringiFor `capitalize` test. program capitalize !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `capitalize` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'say all Hello WorLD!' test_passed ( 1 ) = astring % capitalize () // '' == 'Say all hello world!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Capitalize: \"' // astring % capitalize () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram capitalize","tags":"","loc":"sourcefile/capitalize.f90.html","title":"capitalize.f90 – StringiFor"},{"text":"StringiFor concatenation test. Source Code !< StringiFor `concatenation` test. program concatenation !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `concatenation` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. type ( string ) :: yetanotherstring !< Yet another string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello ' anotherstring = 'Bye bye' acharacter = 'World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // acharacter // '\"' test_passed ( 1 ) = astring // acharacter == 'Hello World!' write ( stdout , \"(A)\" ) astring // acharacter test_passed ( 2 ) = acharacter // astring == 'World!Hello ' write ( stdout , \"(A)\" ) 'Original: \"' // acharacter // '\"+\"' // astring // '\"' write ( stdout , \"(A)\" ) acharacter // astring test_passed ( 3 ) = astring // anotherstring == 'Hello Bye bye' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // anotherstring // '\"' write ( stdout , \"(A)\" ) astring // anotherstring yetanotherstring = astring . cat . acharacter test_passed ( 4 ) = yetanotherstring % chars () == 'Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // acharacter // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = acharacter . cat . astring test_passed ( 5 ) = yetanotherstring % chars () == 'World!Hello ' write ( stdout , \"(A)\" ) 'Original: \"' // acharacter // '\"+\"' // astring // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = astring . cat . anotherstring test_passed ( 6 ) = yetanotherstring % chars () == 'Hello Bye bye' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // anotherstring // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram concatenation","tags":"","loc":"sourcefile/concatenation.f90.html","title":"concatenation.f90 – StringiFor"},{"text":"StringiFor escape test. Source Code !< StringiFor `escape` test. program escape !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `escape` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '&#94;\\s \\d+\\s*' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = ( astring % escape ( to_escape = '\\')//''==' &#94;\\\\ s \\\\ d + \\\\ s * ') write(stdout, \"(A)\") ' Escaped : \"'//astring%escape(to_escape='\\')//'\" ' write(stdout, \"(A,L1)\") new_line(' a ')//' Are all tests passed ? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram escape","tags":"","loc":"sourcefile/escape.f90.html","title":"escape.f90 – StringiFor"},{"text":"StringiFor extension test. Source Code !< StringiFor `extension` test. program extension !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `extension` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '/bar/foo.tar.bz2' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = ( astring % extension () // '' == '.bz2' ) write ( stdout , \"(A)\" ) 'Extension: \"' // astring % extension () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram extension","tags":"","loc":"sourcefile/extension.f90.html","title":"extension.f90 – StringiFor"},{"text":"StringiFor fill test. Source Code !< StringiFor `fill` test. program fill !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `fill` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = astring % fill ( width = 40 ) // '' == '00000000this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Fill (w=40): \"' // astring % fill ( width = 40 ) // '\"' test_passed ( 2 ) = astring % fill ( width = 50 ) // '' == '000000000000000000this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Fill (w=50): \"' // astring % fill ( width = 50 ) // '\"' test_passed ( 3 ) = astring % fill ( width = 50 , right = . true .) // '' == 'this is string example....wow!!!000000000000000000' write ( stdout , \"(A)\" ) 'Fill (w=50, right): \"' // astring % fill ( width = 50 , right = . true .) // '\"' test_passed ( 4 ) = astring % fill ( width = 40 , filling_char = '*' ) // '' == '********this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Fill (w=40, fc=*): \"' // astring % fill ( width = 40 , filling_char = '*' ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram fill","tags":"","loc":"sourcefile/fill.f90.html","title":"fill.f90 – StringiFor"},{"text":"StringiFor free test. Source Code !< StringiFor `free` test. program free !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `free` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'say all Hello WorLD!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % is_allocated (). eqv .. true . write ( stdout , \"(A,L1)\" ) 'Is allocated? ' , astring % is_allocated () call astring % free test_passed ( 2 ) = astring % is_allocated (). eqv .. false . write ( stdout , \"(A,L1)\" ) 'Is allocated? ' , astring % is_allocated () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram free","tags":"","loc":"sourcefile/free.f90.html","title":"free.f90 – StringiFor"},{"text":"StringiFor io_basic test. Source Code !< StringiFor `io_basic` test. program io_basic !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `io_basic` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!' acharacter = 'New Hello World!' #ifndef __GFORTRAN__ write ( stdout , \"(DT)\" , iostat = iostat , iomsg = iomsg ) astring test_passed ( 1 ) = iostat == 0 read ( acharacter , \"(DT)\" , iostat = iostat , iomsg = iomsg ) astring test_passed ( 2 ) = iostat == 0 print \"(DT)\" , astring #else call astring % write_formatted ( stdout , \"(DT)\" , [ 1 ], iostat , iomsg ) test_passed ( 1 ) = iostat == 0 call astring % read_formatted_internal ( acharacter , \"(DT)\" , [ 1 ], iostat , iomsg ) test_passed ( 2 ) = iostat == 0 write ( stdout , \"(A)\" ) astring % chars () #endif write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram io_basic","tags":"","loc":"sourcefile/io_basic.f90.html","title":"io_basic.F90 – StringiFor"},{"text":"StringiFor is_digit test. Source Code !< StringiFor `is_digit` test. program is_digit !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_digit` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112.3 ' test_passed ( 1 ) = astring % is_digit (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is digit? ' , astring % is_digit () astring = '12121123' test_passed ( 2 ) = astring % is_digit (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is digit? ' , astring % is_digit () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_digit","tags":"","loc":"sourcefile/is_digit.f90.html","title":"is_digit.f90 – StringiFor"},{"text":"StringiFor is_integer test. Source Code !< StringiFor `is_integer` test. program is_integer !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_integer` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112 ' test_passed ( 1 ) = astring % is_integer (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () astring = '   -1212112' test_passed ( 2 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer (no spaces allowed)? ' , astring % is_integer ( allow_spaces = . false .) astring = '-1212112   ' test_passed ( 3 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer (no spaces allowed)? ' , astring % is_integer ( allow_spaces = . false .) astring = '+2e20' test_passed ( 4 ) = astring % is_integer (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () astring = ' -2E13 ' test_passed ( 5 ) = astring % is_integer (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () astring = ' -2 E13 ' test_passed ( 6 ) = astring % is_integer (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_integer","tags":"","loc":"sourcefile/is_integer.f90.html","title":"is_integer.f90 – StringiFor"},{"text":"StringiFor is_number test. Source Code !< StringiFor `is_number` test. program is_number !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_number` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 7 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112 ' test_passed ( 1 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = '   -121.2112 ' test_passed ( 2 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = '   -1212112' test_passed ( 3 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number (no spaces allowed)? ' , astring % is_number ( allow_spaces = . false .) astring = '-12121.12   ' test_passed ( 4 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number (no spaces allowed)? ' , astring % is_number ( allow_spaces = . false .) astring = '+2e20' test_passed ( 5 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = ' -2.4E13 ' test_passed ( 6 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = ' -2 E13 ' test_passed ( 7 ) = astring % is_number (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_number","tags":"","loc":"sourcefile/is_number.f90.html","title":"is_number.f90 – StringiFor"},{"text":"StringiFor is_real test. Source Code !< StringiFor `is_real` test. program is_real !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_real` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112.d0 ' test_passed ( 1 ) = astring % is_real (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () astring = '   -1212112.d0' test_passed ( 2 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real (no spaces allowed)? ' , astring % is_real ( allow_spaces = . false .) astring = '-1212112.d0   ' test_passed ( 3 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real (no spaces allowed)? ' , astring % is_real ( allow_spaces = . false .) astring = '+2.e20' test_passed ( 4 ) = astring % is_real (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () astring = ' -2.01E13 ' test_passed ( 5 ) = astring % is_real (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () astring = ' -2.01 E13 ' test_passed ( 6 ) = astring % is_real (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_real","tags":"","loc":"sourcefile/is_real.f90.html","title":"is_real.f90 – StringiFor"},{"text":"StringiFor join test. Source Code !< StringiFor `join` test. program join !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `join` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: strings ( 3 ) !< A set of strings. character ( 5 ) :: characters ( 3 ) !< A set of characters. logical :: test_passed ( 11 ) !< List of passed tests. integer :: s !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (default sep) \"' // astring % join ( array = strings ) // '\"' test_passed ( 1 ) = ( astring % join ( array = strings ) // '' == strings ( 1 ) // strings ( 2 ) // strings ( 3 )) write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 2 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 ) // '-' // strings ( 3 )) call strings ( 1 )% free strings ( 2 ) = 'two' strings ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 3 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 2 ) // '-' // strings ( 3 )) strings ( 1 ) = 'one' strings ( 2 ) = 'two' call strings ( 3 )% free write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 4 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 )) strings ( 1 ) = 'one' call strings ( 2 )% free strings ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 5 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (default sep) \"' // astring % join ( array = characters ) // '\"' test_passed ( 6 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // characters ( 2 ) // characters ( 3 )) write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 7 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 8 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 9 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 )) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 10 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo astring = '_' write ( stdout , \"(A)\" ) 'join (sep by astring) \"' // astring % join ( array = characters ) // '\"' test_passed ( 11 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // '_' // characters ( 2 ) // '_' // characters ( 3 )) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram join","tags":"","loc":"sourcefile/join.f90.html","title":"join.f90 – StringiFor"},{"text":"StringiFor partition test. Source Code !< StringiFor `partition` test. program partition !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `partition` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: strings ( 3 ) !< A set of strings. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' strings = astring % partition ( sep = 'lo Wo' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'Hel' . and . strings ( 2 ) // '' == 'lo Wo' . and . strings ( 3 ) // '' == 'rLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // 'lo Wo' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' strings = astring % partition ( sep = 'Hello' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == '' . and . strings ( 2 ) // '' == 'Hello' . and . strings ( 3 ) // '' == ' WorLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // 'Hello' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' astring = 'Hello WorLD!' strings = astring % partition () test_passed ( 3 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == ' ' . and . strings ( 3 ) // '' == 'WorLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // ' ' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram partition","tags":"","loc":"sourcefile/partition.f90.html","title":"partition.f90 – StringiFor"},{"text":"StringiFor replace test. Source Code !< StringiFor `replace` test. program replace !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `replace` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'When YOU are sad YOU should think to me :-)' write ( stdout , \"(A)\" ) 'Original:                                 \"' // astring // '\"' test_passed ( 1 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' ) // '' == 'When THEY are sad THEY should think to me :-)' ) write ( stdout , \"(A)\" ) 'Replace \"YOU\" with \"THEY\":                \"' // astring % replace ( old = 'YOU' , new = 'THEY' ) // '\"' test_passed ( 2 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '' == 'When THEY are sad YOU should think to me :-)' ) write ( stdout , \"(A)\" ) 'Replace only the first \"YOU\" with \"THEY\": \"' // astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram replace","tags":"","loc":"sourcefile/replace.f90.html","title":"replace.f90 – StringiFor"},{"text":"StringiFor reverse test. Source Code !< StringiFor `reverse` test. program reverse !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `reverse` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'abcdefghilmnopqrstuvz' test_passed ( 1 ) = ( astring % reverse () // '' == 'zvutsrqponmlihgfedcba' ) write ( stdout , \"(A,L1)\" ) 'Original:  \"' // astring // '\", reversed: \"' // astring % reverse () // '\", is correct? ' , & astring % reverse () // '' == 'zvutsrqponmlihgfedcba' astring = '0123456789' test_passed ( 2 ) = ( astring % reverse () // '' == '9876543210' ) write ( stdout , \"(A,L1)\" ) 'Original:  \"' // astring // '\", reversed: \"' // astring % reverse () // '\", is correct? ' , & astring % reverse () // '' == '9876543210' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram reverse","tags":"","loc":"sourcefile/reverse.f90.html","title":"reverse.f90 – StringiFor"},{"text":"StringiFor sadjustlr test. Source Code !< StringiFor `sadjustlr` test. program sadjustlr !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sadjustlr` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % sadjustl () // '' == 'Hello World!   ' write ( stdout , \"(A)\" ) 'AdjustL:  \"' // astring % sadjustl () // '\"' astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 2 ) = astring % sadjustr () // '' == '   Hello World!' write ( stdout , \"(A)\" ) 'AdjustR:  \"' // astring % sadjustr () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sadjustlr","tags":"","loc":"sourcefile/sadjustlr.f90.html","title":"sadjustlr.f90 – StringiFor"},{"text":"StringiFor search test. Source Code !< StringiFor `search` test. program search !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `search` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. character ( len = :), allocatable :: acharacter !< A character. integer :: istart !< Start index of searched tag. integer :: iend !< End index of searched tag. logical :: test_passed ( 5 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '<test> <first> hello </first> <first> not the first </first> </test>' anotherstring = astring % search ( tag_start = '<first>' , tag_end = '</first>' ) test_passed ( 1 ) = anotherstring // '' == '<first> hello </first>' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // anotherstring // '\", is correct? ' , test_passed ( 1 ) astring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' anotherstring = astring % search ( tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 2 ) = anotherstring // '' == '<a> <a> <a> the nested a </a> </a> </a>' write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // anotherstring // '\", is correct? ' , test_passed ( 2 ) call astring % free anotherstring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_string = anotherstring , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 3 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // anotherstring // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // astring // '\", is correct? ' , test_passed ( 3 ) call astring % free acharacter = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 4 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // acharacter // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // astring // '\", is correct? ' , test_passed ( 4 ) acharacter = '<test> <first> hello </first> <sec> <sec>not the first</sec> </sec> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<sec>' , tag_end = '</sec>' , istart = istart , iend = iend ) test_passed ( 5 ) = astring // '' == acharacter ( 31 : 67 ) write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // acharacter // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // astring // '\", is correct? ' , test_passed ( 5 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram search","tags":"","loc":"sourcefile/search.f90.html","title":"search.f90 – StringiFor"},{"text":"StringiFor sindex test. Source Code !< StringiFor `sindex` test. program sindex !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sindex` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sindex ( substring = anothercharacter ) ic = index ( string = acharacter , substring = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sindex ( substring = anothercharacter , back = . true .) ic = index ( string = acharacter , substring = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sindex","tags":"","loc":"sourcefile/sindex.f90.html","title":"sindex.f90 – StringiFor"},{"text":"StringiFor slen test. Source Code !< StringiFor `slen` test. program slen !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `slen` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % slen () == len ( 'Hello World!   ' ) write ( stdout , \"(A,I2)\" ) 'Len: ' , astring % slen () test_passed ( 2 ) = astring % slen_trim () == len_trim ( 'Hello World!   ' ) write ( stdout , \"(A,I2)\" ) 'Len_trim: ' , astring % slen_trim () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram slen","tags":"","loc":"sourcefile/slen.f90.html","title":"slen.f90 – StringiFor"},{"text":"StringiFor snakecase test. Source Code !< StringiFor `snakecase` test. program snakecase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `snakecase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % snakecase () // '' == 'the_quick_brown_fox_jumps_over_the_lazy_dog.' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % snakecase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram snakecase","tags":"","loc":"sourcefile/snakecase.f90.html","title":"snakecase.f90 – StringiFor"},{"text":"StringiFor split test. Source Code !< StringiFor `split` test. program split !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `split` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. logical :: test_passed ( 5 ) !< List of passed tests. integer :: s !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '+ab-++cre-++cre-ab+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'ab-++cre-++cre-ab+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'ab-++cre-++cre-ab' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 3 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'Hello ' // new_line ( 'a' ) // 'World!' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"new_line\"' call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 4 ) = ( strings ( 1 ) // '' == 'Hello ' . and . strings ( 2 ) // '' == 'World!' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'Hello World!' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"default\" (namely space)' call astring % split ( tokens = strings ) test_passed ( 5 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == 'World!' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram split","tags":"","loc":"sourcefile/split.f90.html","title":"split.f90 – StringiFor"},{"text":"StringiFor srepeat test. Source Code !< StringiFor `srepeat` test. program srepeat !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `srepeat` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . test_passed ( 1 ) = astring % srepeat ( rstring = 'x' , ncopies = 5 ) // '' == 'xxxxx' write ( stdout , \"(A,I2)\" ) 'Repeat x 5 times: \"' // astring % srepeat ( rstring = 'x' , ncopies = 5 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram srepeat","tags":"","loc":"sourcefile/srepeat.f90.html","title":"srepeat.f90 – StringiFor"},{"text":"StringiFor sscan test. Source Code !< StringiFor `sscan` test. program sscan !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sscan` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sscan ( set = anothercharacter ) ic = scan ( string = acharacter , set = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sscan ( set = anothercharacter , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sscan","tags":"","loc":"sourcefile/sscan.f90.html","title":"sscan.f90 – StringiFor"},{"text":"StringiFor start_end test. Source Code !< StringiFor `start_end` test. program start_end !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `start_end` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % start_with ( prefix = 'Hello' ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'start with \"Hello\"? ' , astring % start_with ( prefix = 'Hello' ) test_passed ( 2 ) = astring % start_with ( prefix = 'hell' ). eqv .. false . write ( stdout , \"(A,L1)\" ) 'start with \"hell\"? ' , astring % start_with ( prefix = 'hell' ) test_passed ( 3 ) = astring % start_with ( prefix = 'llo Wor' , start = 3 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (3:) start with \"llo Wor\"? ' , astring % start_with ( prefix = 'llo Wor' , start = 3 ) test_passed ( 4 ) = astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (4:7) start with \"lo W\"? ' , astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ) test_passed ( 5 ) = astring % end_with ( suffix = 'LD!' ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'end with \"LD!\"? ' , astring % end_with ( suffix = 'LD!' ) test_passed ( 6 ) = astring % end_with ( suffix = 'lD!' ). eqv .. false . write ( stdout , \"(A,L1)\" ) 'end with \"lD!\"? ' , astring % end_with ( suffix = 'lD!' ) test_passed ( 7 ) = astring % end_with ( suffix = 'orLD!' , start = 5 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (5:) end with \"orLD!\"? ' , astring % end_with ( suffix = 'orLD!' , start = 5 ) test_passed ( 8 ) = astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (8:12) end with \"orLD!\"? ' , astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram start_end","tags":"","loc":"sourcefile/start_end.f90.html","title":"start_end.f90 – StringiFor"},{"text":"StringiFor startcase test. Source Code !< StringiFor `startcase` test. program startcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `startcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % startcase () // '' == 'The Quick Brown Fox Jumps Over The Lazy Dog.' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % startcase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram startcase","tags":"","loc":"sourcefile/startcase.f90.html","title":"startcase.f90 – StringiFor"},{"text":"StringiFor strim test. Source Code !< StringiFor `strim` test. program strim !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strim` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % strim () // '' == 'Hello World!' write ( stdout , \"(A)\" ) 'Trimmed:  \"' // astring % strim () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strim","tags":"","loc":"sourcefile/strim.f90.html","title":"strim.f90 – StringiFor"},{"text":"StringiFor strip test. Source Code !< StringiFor `strip` test. program strip !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strip` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % strip () // '' == 'Hello World!' write ( stdout , \"(A,L1)\" ) 'Strip:    \"' // astring % strip () // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strip","tags":"","loc":"sourcefile/strip.f90.html","title":"strip.f90 – StringiFor"},{"text":"StringiFor sverify test. Source Code !< StringiFor `sverify` test. program sverify !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sverify` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sverify ( set = anothercharacter ) ic = verify ( string = acharacter , set = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , test_passed ( 1 ) i = astring % sverify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , test_passed ( 2 ) anothercharacter = acharacter i = astring % sverify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 3 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Identical strings call result: ' , i , ' is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sverify","tags":"","loc":"sourcefile/sverify.f90.html","title":"sverify.f90 – StringiFor"},{"text":"StringiFor swapcase test. Source Code !< StringiFor `swapcase` test. program swapcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `swapcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % swapcase () // '' == '  hELLO wORLD!   ' write ( stdout , \"(A,L1)\" ) 'Swapcase: \"' // astring % swapcase () // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram swapcase","tags":"","loc":"sourcefile/swapcase.f90.html","title":"swapcase.f90 – StringiFor"},{"text":"StringiFor to_number test. Source Code !< StringiFor `to_number` test. program to_number !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `to_number` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string , I1P , I2P , I4P , I8P , R4P , R8P , R16P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. integer ( I1P ) :: integer_I1P !< A integer. integer ( I1P ) :: integer_I1P_ !< A integer. integer ( I2P ) :: integer_I2P !< A integer. integer ( I2P ) :: integer_I2P_ !< A integer. integer ( I4P ) :: integer_I4P !< A integer. integer ( I4P ) :: integer_I4P_ !< A integer. integer ( I8P ) :: integer_I8P !< A integer. integer ( I8P ) :: integer_I8P_ !< A integer. real ( R4P ) :: real_R4P !< A real. real ( R4P ) :: real_R4P_ !< A real. real ( R8P ) :: real_R8P !< A real. real ( R8P ) :: real_R8P_ !< A real. real ( R16P ) :: real_R16P !< A real. real ( R16P ) :: real_R16P_ !< A real. logical :: test_passed ( 7 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '127' integer_I1P = astring % to_number ( kind = 1_I1P ) integer_I1P_ = 127_I1P test_passed ( 1 ) = integer_I1P == integer_I1P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I4,A)\" ) 'To number: \"' , integer_I1P , '\"' astring = '32767' integer_I2P = astring % to_number ( kind = 1_I2P ) integer_I2P_ = 32767_I2P test_passed ( 2 ) = integer_I2P == integer_I2P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I6,A)\" ) 'To number: \"' , integer_I2P , '\"' astring = '2147483647' integer_I4P = astring % to_number ( kind = 1_I4P ) integer_I4P_ = 2147483647_I4P test_passed ( 3 ) = integer_I4P == integer_I4P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I11,A)\" ) 'To number: \"' , integer_I4P , '\"' astring = '-9223372036854775807' integer_I8P = astring % to_number ( kind = 1_I8P ) integer_I8P_ = - 9223372036854775807_I8P test_passed ( 4 ) = integer_I8P == integer_I8P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I20,A)\" ) 'To number: \"' , integer_I8P , '\"' astring = '3.4e9' real_R4P = astring % to_number ( kind = 1._R4P ) real_R4P_ = 3.4e9_R4P test_passed ( 5 ) = real_R4P == real_R4P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,E13.6,A)\" ) 'To number: \"' , real_R4P , '\"' astring = '-13.4345345e21' real_R8P = astring % to_number ( kind = 1._R8P ) real_R8P_ = - 1 3.4345345e21_R8P test_passed ( 6 ) = real_R8P == real_R8P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,E23.15,A)\" ) 'To number: \"' , real_R8P , '\"' astring = '1.1e200' real_R16P = astring % to_number ( kind = 1._R16P ) real_R16P_ = 1.1e200_R16P test_passed ( 7 ) = real_R16P == real_R16P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,E42.33,A)\" ) 'To number: \"' , real_R16P , '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram to_number","tags":"","loc":"sourcefile/to_number.f90.html","title":"to_number.f90 – StringiFor"},{"text":"StringiFor unique test. Source Code !< StringiFor `unique` test. program unique !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `unique` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '+++ab-++cre-++cre-ab+++++' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % unique ( substring = '+' ) // '' == '+ab-+cre-+cre-ab+' write ( stdout , \"(A,L1)\" ) 'Unique:   \"' // astring % unique ( substring = '+' ) // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram unique","tags":"","loc":"sourcefile/unique.f90.html","title":"unique.f90 – StringiFor"},{"text":"StringiFor upper_lower test. Source Code !< StringiFor `upper_lower` test. program upper_lower !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `upper_lower` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 : 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' test_passed ( 1 ) = astring % upper () // '' == 'HELLO WORLD!' test_passed ( 2 ) = astring % lower () // '' == 'hello world!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'UPPER:    \"' // astring % upper () // '\". Is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) 'lower:    \"' // astring % lower () // '\". Is correct? ' , test_passed ( 2 ) astring = ' Hello World' test_passed ( 3 ) = astring % is_upper (). eqv .. false . test_passed ( 4 ) = astring % is_lower (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 4 ) astring = ' HELLO WORLD' test_passed ( 5 ) = astring % is_upper (). eqv .. true . test_passed ( 6 ) = astring % is_lower (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 5 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 6 ) astring = ' hello world' test_passed ( 7 ) = astring % is_upper (). eqv .. false . test_passed ( 8 ) = astring % is_lower (). eqv .. true . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 7 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 8 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram upper_lower","tags":"","loc":"sourcefile/upper_lower.f90.html","title":"upper_lower.f90 – StringiFor"},{"text":"Portability Environment for Fortran poor people. Source Code !< Portability Environment for Fortran poor people. module penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !< PENF global (exposed) parameters and variables. !< !< @note All module defined entities are public. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none public save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_initialized = . false . !< Check the initialization of some variables that must be initialized. integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. integer :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Portable kind parameters #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33 digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Format parameters #ifdef r16p character ( * ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P real. #else character ( * ), parameter :: FR16P = '(E23.15E3)' !< Output format for kind=R16P real. #endif character ( * ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P real. character ( * ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P real. character ( * ), parameter :: FR_P = FR8P !< Output format for kind=R_P real. character ( * ), parameter :: FI8P = '(I20)' !< Output format for kind=I8P integer. character ( * ), parameter :: FI8PZP = '(I20.19)' !< Output format for kind=I8P integer with zero prefixing. character ( * ), parameter :: FI4P = '(I11)' !< Output format for kind=I4P integer. character ( * ), parameter :: FI4PZP = '(I11.10)' !< Output format for kind=I4P integer with zero prefixing. character ( * ), parameter :: FI2P = '(I6)' !< Output format for kind=I2P integer. character ( * ), parameter :: FI2PZP = '(I6.5)' !< Output format for kind=I2P integer with zero prefixing. character ( * ), parameter :: FI1P = '(I4)' !< Output format for kind=I1P integer. character ( * ), parameter :: FI1PZP = '(I4.3)' !< Output format for kind=I1P integer with zero prefixing. character ( * ), parameter :: FI_P = FI4P !< Output format for kind=I_P integer. character ( * ), parameter :: FI_PZP = FI4PZP !< Output format for kind=I_P integer with zero prefixing. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Length (number of digits) of formatted numbers #ifdef r16p integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. #else integer , parameter :: DR16P = 23 !< Number of digits of output format FR16P. #endif integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! List of kinds integer , parameter :: REAL_KINDS_LIST ( 1 : 4 ) = [ R16P , R8P , R4P , R_P ] !< List of real kinds. character ( * ), parameter :: REAL_FORMATS_LIST ( 1 : 4 ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of real formats. integer , parameter :: INTEGER_KINDS_LIST ( 1 : 5 ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of integer kinds. character ( * ), parameter :: INTEGER_FORMATS_LIST ( 1 : 5 ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of integer formats. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Minimum and maximum (representable) values real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P real. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P real. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P real. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P real. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P real. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P real. real ( R_P ), parameter :: MinR_P = MinR8P !< Minimum value of kind=R_P real. real ( R_P ), parameter :: MaxR_P = MaxR8P !< Maximum value of kind=R_P real. integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P integer. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P integer. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P integer. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P integer. integer ( I_P ), parameter :: MinI_P = MinI4P !< Minimum value of kind=I_P integer. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P integer. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P integer. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P integer. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P integer. integer ( I_P ), parameter :: MaxI_P = MaxI4P !< Maximum value of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Real smallest (representable) values real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest representable value of kind=R16P real. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest representable value of kind=R8P real. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest representable value of kind=R4P real. real ( R_P ), parameter :: smallR_P = smallR8P !< Smallest representable value of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Smallest real representable difference by the running calculator real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P real. real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P real. real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P real. real ( R_P ), parameter :: Zero = ZeroR8 !< Smallest representable difference of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Bits/bytes memory requirements (real variables must be computed at runtime) integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P real. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P real. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P real. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P real. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P real. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P real. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P real. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P real. integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P integer. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P integer. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P integer. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P integer. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P integer. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P integer. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P integer. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P integer. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P integer. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- endmodule penf_global_parameters_variables module penf_b_size !----------------------------------------------------------------------------------------------------------------------------------- !< PENF bit/byte size functions. !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: bit_size , byte_size !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef r16p bit_size_R16P , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface byte_size !< Compute the number of bytes of a variable. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef r16p byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr endmodule penf_b_size module penf_stringify !----------------------------------------------------------------------------------------------------------------------------------- !< PENF string-to-number (and viceversa) facility. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stderr => ERROR_UNIT use penf_b_size use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: str , strz , cton public :: bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface str !< Convert number (real and integer) to string (number to string type casting). module procedure & #ifdef r16p strf_R16P , str_R16P , & #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef r16p str_a_R16P , & #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface strz !< Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). module procedure strz_I8P , strz_I4P , strz_I2P , strz_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface cton !< Convert string to number (real and integer, string to number type casting). module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bstr !< Convert number (real and integer) to bit-string (number to bit-string type casting). module procedure & #ifdef r16p bstr_R16P , & #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bcton !< Convert bit-string to number (real and integer, bit-string to number type casting). module procedure & #ifdef r16p bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P elemental function str_R16P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P elemental function str_R8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P elemental function str_R4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol pure function str_a_R16P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P pure function str_a_R8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P pure function str_a_R4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P pure function str_a_I8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P pure function str_a_I4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P pure function str_a_I2P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P pure function str_a_I1P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P endmodule penf_stringify module penf !----------------------------------------------------------------------------------------------------------------------------------- !< Portability Environment for Fortran poor people. !<{!README-PENF.md!} !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables #ifdef __GFORTRAN__ use penf_b_size , only : bit_size , byte_size #else use penf_b_size #endif use penf_stringify , only : str , strz , cton , bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! Global parameters and variables public :: endianL , endianB , endian , is_initialized public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16 public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: REAL_KINDS_LIST , REAL_FORMATS_LIST public :: INTEGER_KINDS_LIST , INTEGER_FORMATS_LIST ! Bit/byte size functions public :: bit_size , byte_size ! Stringify facility public :: str , strz , cton public :: bstr , bcton ! Miscellanea facility public :: check_endian public :: digit public :: penf_Init public :: penf_print !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef __GFORTRAN__ ! work-around for strange gfortran bug... interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. endinterface #endif !----------------------------------------------------------------------------------------------------------------------------------- interface digit !< Compute the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1 subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print endmodule penf","tags":"","loc":"sourcefile/penf.f90~2.html","title":"penf.F90 – StringiFor"},{"text":"PENF's testing program. Source Code !< PENF's testing program. program test_all !----------------------------------------------------------------------------------------------------------------------------------- !< PENF's testing program. !< !<### Usage !<```bash !< ./test_all !<``` !----------------------------------------------------------------------------------------------------------------------------------- use penf use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call penf_Init call penf_Print ( unit = stdout ) print \"(A)\" , '' print \"(A)\" , 'Testing IR_Precision tools' print \"(A)\" , 'Casting real-to-string: ' // str ( n = 1._R8P ) print \"(A)\" , 'Casting integer-to-string: ' // str ( n = 11_I8P ) print \"(A,\" // FR8P // \")\" , 'Casting string-to-real: ' , cton ( str = '2.2d0' , knd = 1._R8P ) print \"(A,\" // FI4P // \")\" , 'Casting integer-to-string: ' , cton ( str = '43' , knd = 1_I4P ) print \"(A)\" , 'Casting integer-to-string with zero padding: ' // trim ( strz ( nz_pad = 3 , n = 34_I8P )) #ifndef __GFORTRAN__ print \"(A)\" , 'Casting real-to-bit_string: ' // bstr ( n = 1._R4P ) #endif print \"(A)\" , 'Casting integer-to-bit_string: ' // bstr ( n = 1_I4P ) #ifndef __GFORTRAN__ print \"(A,\" // FR4P // \")\" , 'Casting bit_string-to-real: ' , bcton ( bstr = '00111111100000000000000000000000' , knd = 1._R4P ) #endif print \"(A,\" // FI4P // \")\" , 'Casting bit_string-to-integer: ' , bcton ( bstr = '00000000000000000000000000000001' , knd = 1_I4P ) print \"(A)\" , 'Number of digit of 1023: ' // str ( n = digit ( 1023_I4P )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_all","tags":"","loc":"sourcefile/test_all.f90.html","title":"test_all.f90 – StringiFor"},{"text":"type, public :: string OOP designed string class. Components Type Visibility Attributes Name Initial character(kind=CK,len=:), private, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: basedir Return the base directory name of a string containing a file name. private elemental function basedir (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. Description Return the base directory name of a string containing a file name. procedure, public, pass(self) :: basename Return the base file name of a string containing a file name. private elemental function basename (self, sep, extension, strip_last_extension) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. character(kind=CK,len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. Description Return the base file name of a string containing a file name. procedure, public, pass(self) :: camelcase Return a string with all words capitalized without spaces. private elemental function camelcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. Description Return a string with all words capitalized without spaces. procedure, public, pass(self) :: capitalize Return a string with its first character capitalized and the rest lowercased. private elemental function capitalize (self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with its first character capitalized and the rest lowercased. procedure, public, pass(self) :: chars Return the raw characters data. private pure function chars (self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data. procedure, public, pass(self) :: escape Escape backslashes (or custom escape character). private elemental function escape (self, to_escape, esc) result(escaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK,len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. Description Escape backslashes (or custom escape character). procedure, public, pass(self) :: extension Return the extension of a string containing a file name. private elemental function extension (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. Description Return the extension of a string containing a file name. procedure, public, pass(self) :: fill Pad string on the left (or right) with zeros (or other char) to fill width. private elemental function fill (self, width, right, filling_char) result(filled) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK,len=1), intent(in), optional :: filling_char Filling character (default \"0\"). Return Value type( string ) Filled string. Description Pad string on the left (or right) with zeros (or other char) to fill width. procedure, public, pass(self) :: free Free dynamic memory. private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Description Free dynamic memory. generic, public :: join => join_strings , join_characters Return a string that is a join of an array of strings or characters. private pure function join_strings (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. private pure function join_characters (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. procedure, public, pass(self) :: lower Return a string with all lowercase characters. private elemental function lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all lowercase characters. procedure, public, pass(self) :: partition Split string at separator and return the 3 parts (before, the separator and after). private pure function partition (self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )\n  (1:3) after the separator. Description Split string at separator and return the 3 parts (before, the separator and after). procedure, public, pass(self) :: replace Return a string with all occurrences of substring old replaced by new. private elemental function replace (self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Description Return a string with all occurrences of substring old replaced by new. procedure, public, pass(self) :: reverse Return a reversed string. private elemental function reverse (self) result(reversed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. Description Return a reversed string. procedure, public, pass(self) :: search Search for tagged record into string. private function search (self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: tag_start Start tag. character(kind=CK,len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK,len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. Description Search for tagged record into string, return the first record found (if any) matching the tags. procedure, public, pass(self) :: snakecase Return a string with all words lowercase separated by \"_\". private elemental function snakecase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. Description Return a string with all words lowercase separated by \"_\". procedure, public, pass(self) :: split Return a list of substring in the string, using sep as the delimiter string. private pure subroutine split (self, tokens, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. Description Return a list of substring in the string, using sep as the delimiter string. procedure, public, pass(self) :: startcase Return a string with all words capitalized, e.g. title case. private elemental function startcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. Description Return a string with all words capitalized, e.g. title case. procedure, public, pass(self) :: strip Return a string with the leading and trailing characters removed. private elemental function strip (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The stripped string. Description Return a copy of the string with the leading and trailing characters removed. procedure, public, pass(self) :: swapcase Return a string with uppercase chars converted to lowercase and vice versa. private elemental function swapcase (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a copy of the string with uppercase characters converted to lowercase and vice versa. generic, public :: to_number => to_integer_I1P , to_integer_I2P , to_integer_I4P , to_integer_I8P , to_real_R4P , to_real_R8P Cast string to number. private elemental function to_integer_I1P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). private elemental function to_integer_I2P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). private elemental function to_integer_I4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). private elemental function to_integer_I8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). private elemental function to_real_R4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). private elemental function to_real_R8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). procedure, public, pass(self) :: unique Reduce to one (unique) multiple occurrences of a substring into a string. private elemental function unique (self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Description Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. procedure, public, pass(self) :: upper Return a string with all uppercase characters. private elemental function upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all uppercase characters. procedure, public, pass(self) :: end_with Return true if a string ends with a specified suffix. private elemental function end_with (self, suffix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string ends with a specified suffix. procedure, public, pass(self) :: is_allocated Return true if the string is allocated. private elemental function is_allocated (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if the string is allocated. procedure, public, pass(self) :: is_digit Return true if all characters in the string are digits. private elemental function is_digit (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are digits. procedure, public, pass(self) :: is_integer Return true if the string contains an integer. private elemental function is_integer (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains an integer. procedure, public, pass(self) :: is_lower Return true if all characters in the string are lowercase. private elemental function is_lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are lowercase. procedure, public, pass(self) :: is_number Return true if the string contains a number (real or integer). private elemental function is_number (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a number (real or integer). procedure, public, pass(self) :: is_real Return true if the string contains an real. private elemental function is_real (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a real. procedure, public, pass(self) :: is_upper Return true if all characters in the string are uppercase. private elemental function is_upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are uppercase. procedure, public, pass(self) :: start_with Return true if a string starts with a specified prefix. private elemental function start_with (self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string starts with a specified prefix. generic, public :: assignment(=) => string_assign_string , string_assign_character , string_assign_integer_I1P , string_assign_integer_I2P , string_assign_integer_I4P , string_assign_integer_I8P , string_assign_real_R4P , string_assign_real_R8P Assignment operator overloading. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. private elemental subroutine string_assign_integer_I1P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I2P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. generic, public :: operator(//) => string_concat_string , string_concat_character , character_concat_string Concatenation operator overloading. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). generic, public :: operator(.cat.) => string_concat_string_string , string_concat_character_string , character_concat_string_string Concatenation operator (string output) overloading. private elemental function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. private elemental function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. private elemental function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). procedure, public, pass(self) :: sadjustl Adjustl replacement. private elemental function sadjustl (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. procedure, public, pass(self) :: sadjustr Adjustr replacement. private elemental function sadjustr (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. procedure, public, pass(self) :: scount Count replacement. private elemental function scount (self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore \"isolated\" occurrences. Return Value integer Number of occurrences. Description Count the number of occurences of a substring into a string. procedure, public, pass(self) :: sindex Index replacement. private elemental function sindex (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. procedure, public, pass(self) :: slen Len replacement. private elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. procedure, public, pass(self) :: slen_trim Len_trim replacement. private elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer <\np S\nt\nr\ni\nn\ng l\ne\nn\ng\nt\nh\n.\n<\n/\np Description Return the length of a string, ignoring any trailing blanks. procedure, public, nopass :: srepeat Repeat replacement. private elemental function srepeat (rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. procedure, public, pass(self) :: sscan Scan replacement. private elemental function sscan (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . procedure, public, pass(self) :: strim Trim replacement. private elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. procedure, public, pass(self) :: sverify Verify replacement. private elemental function sverify (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. procedure, public, pass(dtv) :: read_formatted => read_formatted_ Formatted input. private subroutine read_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted input. procedure, public, pass(dtv) :: read_formatted_internal Formatted input from internal. private subroutine read_formatted_internal (dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. character(kind=CK,len=*), intent(in) :: iunit Internal unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted input from internal. procedure, public, pass(dtv) :: write_formatted => write_formatted_ Formatted output. private subroutine write_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. procedure, public, pass(dtv) :: write_formatted_internal Formatted output to internal. private subroutine write_formatted_internal (dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. character(kind=CK,len=*), intent(inout) :: iunit Interanl unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output to internal. procedure, private, pass(lhs) :: string_assign_string Assignment operator from string input. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. procedure, private, pass(lhs) :: string_assign_character Assignment operator from character input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. procedure, private, pass(lhs) :: string_assign_integer_I1P Assignment operator from integer input. private elemental subroutine string_assign_integer_I1P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_integer_I2P Assignment operator from integer input. private elemental subroutine string_assign_integer_I2P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_integer_I4P Assignment operator from integer input. private elemental subroutine string_assign_integer_I4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_integer_I8P Assignment operator from integer input. private elemental subroutine string_assign_integer_I8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R4P Assignment operator from real input. private elemental subroutine string_assign_real_R4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R8P Assignment operator from real input. private elemental subroutine string_assign_real_R8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R16P Assignment operator from real input. private elemental subroutine string_assign_real_R16P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_concat_string Concatenation with string. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. procedure, private, pass(lhs) :: string_concat_character Concatenation with character. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. procedure, private, pass(rhs) :: character_concat_string Concatenation with character (inverted). private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). procedure, private, pass(lhs) :: string_concat_string_string Concatenation with string (string output). private elemental function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. procedure, private, pass(lhs) :: string_concat_character_string Concatenation with character (string output). private elemental function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. procedure, private, pass(rhs) :: character_concat_string_string Concatenation with character (inverted, string output). private elemental function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). procedure, private, pass(dtv) :: read_formatted_ Formatted input. private subroutine read_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted input. procedure, private, pass(dtv) :: write_formatted_ Formatted output. private subroutine write_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. procedure, private, pass(dtv) :: read_unformatted_ Unformatted input. private subroutine read_unformatted_ (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. procedure, private, pass(dtv) :: write_unformatted_ Unformatted output. private subroutine write_unformatted_ (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. procedure, private, pass(self) :: replace_one_occurrence Replace the first occurrence of substring old by new. private elemental function replace_one_occurrence (self, old, new) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Description Return a string with the first occurrence of substring old replaced by new. procedure, private, pass(self) :: join_strings Return join string of an array of strings. private pure function join_strings (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. procedure, private, pass(self) :: join_characters Return join string of an array of characters. private pure function join_characters (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. procedure, private, pass(self) :: to_integer_I1P Cast string to integer. private elemental function to_integer_I1P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). procedure, private, pass(self) :: to_integer_I2P Cast string to integer. private elemental function to_integer_I2P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). procedure, private, pass(self) :: to_integer_I4P Cast string to integer. private elemental function to_integer_I4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). procedure, private, pass(self) :: to_integer_I8P Cast string to integer. private elemental function to_integer_I8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). procedure, private, pass(self) :: to_real_R4P Cast string to real. private elemental function to_real_R4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). procedure, private, pass(self) :: to_real_R8P Cast string to real. private elemental function to_real_R8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). procedure, private, pass(self) :: to_real_R16P Cast string to real. private elemental function to_real_R16P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. Description Cast string to real (R16P). Source Code type :: string !< OOP designed string class. private character ( kind = CK , len = :), allocatable :: raw !< Raw data. contains ! public methods procedure , pass ( self ) :: basedir !< Return the base directory name of a string containing a file name. procedure , pass ( self ) :: basename !< Return the base file name of a string containing a file name. procedure , pass ( self ) :: camelcase !< Return a string with all words capitalized without spaces. procedure , pass ( self ) :: capitalize !< Return a string with its first character capitalized and the rest lowercased. procedure , pass ( self ) :: chars !< Return the raw characters data. procedure , pass ( self ) :: escape !< Escape backslashes (or custom escape character). procedure , pass ( self ) :: extension !< Return the extension of a string containing a file name. procedure , pass ( self ) :: fill !< Pad string on the left (or right) with zeros (or other char) to fill width. procedure , pass ( self ) :: free !< Free dynamic memory. generic :: join => & join_strings , & join_characters !< Return a string that is a join of an array of strings or characters. procedure , pass ( self ) :: lower !< Return a string with all lowercase characters. procedure , pass ( self ) :: partition !< Split string at separator and return the 3 parts (before, the separator and after). procedure , pass ( self ) :: replace !< Return a string with all occurrences of substring old replaced by new. procedure , pass ( self ) :: reverse !< Return a reversed string. procedure , pass ( self ) :: search !< Search for *tagged* record into string. procedure , pass ( self ) :: snakecase !< Return a string with all words lowercase separated by \"_\". procedure , pass ( self ) :: split !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: startcase !< Return a string with all words capitalized, e.g. title case. procedure , pass ( self ) :: strip !< Return a string with the leading and trailing characters removed. procedure , pass ( self ) :: swapcase !< Return a string with uppercase chars converted to lowercase and vice versa. generic :: to_number => & to_integer_I1P ,& to_integer_I2P ,& to_integer_I4P ,& to_integer_I8P ,& to_real_R4P , & #ifdef r16p to_real_R8P , & to_real_R16P !< Cast string to number. #else to_real_R8P !< Cast string to number. #endif procedure , pass ( self ) :: unique !< Reduce to one (unique) multiple occurrences of a substring into a string. procedure , pass ( self ) :: upper !< Return a string with all uppercase characters. ! inquire procedure , pass ( self ) :: end_with !< Return true if a string ends with a specified suffix. procedure , pass ( self ) :: is_allocated !< Return true if the string is allocated. procedure , pass ( self ) :: is_digit !< Return true if all characters in the string are digits. procedure , pass ( self ) :: is_integer !< Return true if the string contains an integer. procedure , pass ( self ) :: is_lower !< Return true if all characters in the string are lowercase. procedure , pass ( self ) :: is_number !< Return true if the string contains a number (real or integer). procedure , pass ( self ) :: is_real !< Return true if the string contains an real. procedure , pass ( self ) :: is_upper !< Return true if all characters in the string are uppercase. procedure , pass ( self ) :: start_with !< Return true if a string starts with a specified prefix. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character , & string_assign_integer_I1P , & string_assign_integer_I2P , & string_assign_integer_I4P , & string_assign_integer_I8P , & string_assign_real_R4P , & #ifdef r16p string_assign_real_R8P , & string_assign_real_R16P !< Assignment operator overloading. #else string_assign_real_R8P !< Assignment operator overloading. #endif generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. ! builtins replacements procedure , pass ( self ) :: sadjustl !< Adjustl replacement. procedure , pass ( self ) :: sadjustr !< Adjustr replacement. procedure , pass ( self ) :: scount !< Count replacement. procedure , pass ( self ) :: sindex !< Index replacement. procedure , pass ( self ) :: slen !< Len replacement. procedure , pass ( self ) :: slen_trim !< Len_trim replacement. procedure , nopass :: srepeat !< Repeat replacement. procedure , pass ( self ) :: sscan !< Scan replacement. procedure , pass ( self ) :: strim !< Trim replacement. procedure , pass ( self ) :: sverify !< Verify replacement. ! IO #ifndef __GFORTRAN__ generic :: read ( formatted ) => read_formatted_ !< Formatted input. generic :: write ( formatted ) => write_formatted_ !< Formatted output. generic :: read ( unformatted ) => read_unformatted_ !< Unformatted input. generic :: write ( unformatted ) => write_unformatted_ !< Unformatted output. #else procedure , pass ( dtv ) :: read_formatted => read_formatted_ !< Formatted input. procedure , pass ( dtv ) :: read_formatted_internal !< Formatted input from internal. procedure , pass ( dtv ) :: write_formatted => write_formatted_ !< Formatted output. procedure , pass ( dtv ) :: write_formatted_internal !< Formatted output to internal. #endif ! private methods procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_assign_integer_I1P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I2P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I4P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I8P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_real_R4P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R8P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R16P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). procedure , private , pass ( dtv ) :: read_formatted_ !< Formatted input. procedure , private , pass ( dtv ) :: write_formatted_ !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted_ !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted_ !< Unformatted output. procedure , private , pass ( self ) :: replace_one_occurrence !< Replace the first occurrence of substring old by new. procedure , private , pass ( self ) :: join_strings !< Return join string of an array of strings. procedure , private , pass ( self ) :: join_characters !< Return join string of an array of characters. procedure , private , pass ( self ) :: to_integer_I1P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I2P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I4P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I8P !< Cast string to integer. procedure , private , pass ( self ) :: to_real_R4P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R8P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R16P !< Cast string to real. endtype string","tags":"","loc":"type/string.html","title":"string – StringiFor "},{"text":"private elemental function bit_size_R16P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Compute the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P","tags":"","loc":"proc/bit_size_r16p.html","title":"bit_size_R16P – StringiFor"},{"text":"private elemental function bit_size_R8P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. Called By proc~~bit_size_r8p~~CalledByGraph proc~bit_size_r8p bit_size_R8P interface~bit_size bit_size interface~bit_size->proc~bit_size_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P","tags":"","loc":"proc/bit_size_r8p.html","title":"bit_size_R8P – StringiFor"},{"text":"private elemental function bit_size_R4P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. Called By proc~~bit_size_r4p~~CalledByGraph proc~bit_size_r4p bit_size_R4P interface~bit_size bit_size interface~bit_size->proc~bit_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P","tags":"","loc":"proc/bit_size_r4p.html","title":"bit_size_R4P – StringiFor"},{"text":"private elemental function bit_size_chr(i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. Called By proc~~bit_size_chr~~CalledByGraph proc~bit_size_chr bit_size_chr interface~bit_size bit_size interface~bit_size->proc~bit_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr","tags":"","loc":"proc/bit_size_chr.html","title":"bit_size_chr – StringiFor"},{"text":"private elemental function byte_size_I8P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i8p~~CalledByGraph proc~byte_size_i8p byte_size_I8P interface~byte_size byte_size interface~byte_size->proc~byte_size_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P","tags":"","loc":"proc/byte_size_i8p.html","title":"byte_size_I8P – StringiFor"},{"text":"private elemental function byte_size_I4P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i4p~~CalledByGraph proc~byte_size_i4p byte_size_I4P interface~byte_size byte_size interface~byte_size->proc~byte_size_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P","tags":"","loc":"proc/byte_size_i4p.html","title":"byte_size_I4P – StringiFor"},{"text":"private elemental function byte_size_I2P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i2p~~CalledByGraph proc~byte_size_i2p byte_size_I2P interface~byte_size byte_size interface~byte_size->proc~byte_size_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P","tags":"","loc":"proc/byte_size_i2p.html","title":"byte_size_I2P – StringiFor"},{"text":"private elemental function byte_size_I1P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i1p~~CalledByGraph proc~byte_size_i1p byte_size_I1P interface~byte_size byte_size interface~byte_size->proc~byte_size_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P","tags":"","loc":"proc/byte_size_i1p.html","title":"byte_size_I1P – StringiFor"},{"text":"private elemental function byte_size_R16P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Source Code elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P","tags":"","loc":"proc/byte_size_r16p.html","title":"byte_size_R16P – StringiFor"},{"text":"private elemental function byte_size_R8P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Called By proc~~byte_size_r8p~~CalledByGraph proc~byte_size_r8p byte_size_R8P interface~byte_size byte_size interface~byte_size->proc~byte_size_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P","tags":"","loc":"proc/byte_size_r8p.html","title":"byte_size_R8P – StringiFor"},{"text":"private elemental function byte_size_R4P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Called By proc~~byte_size_r4p~~CalledByGraph proc~byte_size_r4p byte_size_R4P interface~byte_size byte_size interface~byte_size->proc~byte_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P","tags":"","loc":"proc/byte_size_r4p.html","title":"byte_size_R4P – StringiFor"},{"text":"private elemental function byte_size_chr(i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable. Called By proc~~byte_size_chr~~CalledByGraph proc~byte_size_chr byte_size_chr interface~byte_size byte_size interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr","tags":"","loc":"proc/byte_size_chr.html","title":"byte_size_chr – StringiFor"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. Calls interface~~bit_size~~CallsGraph interface~bit_size bit_size proc~bit_size_chr bit_size_chr interface~bit_size->proc~bit_size_chr proc~bit_size_r8p bit_size_R8P interface~bit_size->proc~bit_size_r8p proc~bit_size_r4p bit_size_R4P interface~bit_size->proc~bit_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable.","tags":"","loc":"interface/bit_size.html","title":"bit_size – StringiFor"},{"text":"public interface byte_size Compute the number of bytes of a variable. Calls interface~~byte_size~~CallsGraph interface~byte_size byte_size proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable.","tags":"","loc":"interface/byte_size.html","title":"byte_size – StringiFor"},{"text":"private elemental function strf_R16P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. Source Code elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P","tags":"","loc":"proc/strf_r16p.html","title":"strf_R16P – StringiFor"},{"text":"private elemental function strf_R8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. Called By proc~~strf_r8p~~CalledByGraph proc~strf_r8p strf_R8P interface~str str interface~str->proc~strf_r8p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P","tags":"","loc":"proc/strf_r8p.html","title":"strf_R8P – StringiFor"},{"text":"private elemental function strf_R4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. Called By proc~~strf_r4p~~CalledByGraph proc~strf_r4p strf_R4P interface~str str interface~str->proc~strf_r4p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P","tags":"","loc":"proc/strf_r4p.html","title":"strf_R4P – StringiFor"},{"text":"private elemental function strf_I8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i8p~~CalledByGraph proc~strf_i8p strf_I8P interface~str str interface~str->proc~strf_i8p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P","tags":"","loc":"proc/strf_i8p.html","title":"strf_I8P – StringiFor"},{"text":"private elemental function strf_I4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i4p~~CalledByGraph proc~strf_i4p strf_I4P interface~str str interface~str->proc~strf_i4p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P","tags":"","loc":"proc/strf_i4p.html","title":"strf_I4P – StringiFor"},{"text":"private elemental function strf_I2P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i2p~~CalledByGraph proc~strf_i2p strf_I2P interface~str str interface~str->proc~strf_i2p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P","tags":"","loc":"proc/strf_i2p.html","title":"strf_I2P – StringiFor"},{"text":"private elemental function strf_I1P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i1p~~CalledByGraph proc~strf_i1p strf_I1P interface~str str interface~str->proc~strf_i1p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P","tags":"","loc":"proc/strf_i1p.html","title":"strf_I1P – StringiFor"},{"text":"private elemental function str_R16P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r16p~~CalledByGraph proc~str_r16p str_R16P proc~str_a_r16p str_a_R16P proc~str_a_r16p->proc~str_r16p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R16P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P","tags":"","loc":"proc/str_r16p.html","title":"str_R16P – StringiFor"},{"text":"private elemental function str_R8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r8p~~CalledByGraph proc~str_r8p str_R8P proc~str_a_r8p str_a_R8P proc~str_a_r8p->proc~str_r8p interface~str str interface~str->proc~str_r8p interface~str->proc~str_a_r8p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P","tags":"","loc":"proc/str_r8p.html","title":"str_R8P – StringiFor"},{"text":"private elemental function str_R4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r4p~~CalledByGraph proc~str_r4p str_R4P proc~str_a_r4p str_a_R4P proc~str_a_r4p->proc~str_r4p interface~str str interface~str->proc~str_r4p interface~str->proc~str_a_r4p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P","tags":"","loc":"proc/str_r4p.html","title":"str_R4P – StringiFor"},{"text":"private elemental function str_I8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i8p~~CalledByGraph proc~str_i8p str_I8P proc~str_a_i8p str_a_I8P proc~str_a_i8p->proc~str_i8p interface~str str interface~str->proc~str_i8p interface~str->proc~str_a_i8p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P","tags":"","loc":"proc/str_i8p.html","title":"str_I8P – StringiFor"},{"text":"private elemental function str_I4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. Called By proc~~str_i4p~~CalledByGraph proc~str_i4p str_I4P proc~str_a_i4p str_a_I4P proc~str_a_i4p->proc~str_i4p interface~str str interface~str->proc~str_i4p interface~str->proc~str_a_i4p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P","tags":"","loc":"proc/str_i4p.html","title":"str_I4P – StringiFor"},{"text":"private elemental function str_I2P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i2p~~CalledByGraph proc~str_i2p str_I2P proc~str_a_i2p str_a_I2P proc~str_a_i2p->proc~str_i2p interface~str str interface~str->proc~str_i2p interface~str->proc~str_a_i2p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P","tags":"","loc":"proc/str_i2p.html","title":"str_I2P – StringiFor"},{"text":"private elemental function str_I1P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i1p~~CalledByGraph proc~str_i1p str_I1P proc~str_a_i1p str_a_I1P proc~str_a_i1p->proc~str_i1p interface~str str interface~str->proc~str_i1p interface~str->proc~str_a_i1p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P","tags":"","loc":"proc/str_i1p.html","title":"str_I1P – StringiFor"},{"text":"private elemental function str_bol(n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. Called By proc~~str_bol~~CalledByGraph proc~str_bol str_bol interface~str str interface~str->proc~str_bol proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol","tags":"","loc":"proc/str_bol.html","title":"str_bol – StringiFor"},{"text":"private pure function str_a_R16P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Converting real array to string. Calls proc~~str_a_r16p~~CallsGraph proc~str_a_r16p str_a_R16P proc~str_r16p str_R16P proc~str_a_r16p->proc~str_r16p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR16P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R16P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P","tags":"","loc":"proc/str_a_r16p.html","title":"str_a_R16P – StringiFor"},{"text":"private pure function str_a_R8P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. Calls proc~~str_a_r8p~~CallsGraph proc~str_a_r8p str_a_R8P proc~str_r8p str_R8P proc~str_a_r8p->proc~str_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_r8p~~CalledByGraph proc~str_a_r8p str_a_R8P interface~str str interface~str->proc~str_a_r8p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P","tags":"","loc":"proc/str_a_r8p.html","title":"str_a_R8P – StringiFor"},{"text":"private pure function str_a_R4P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. Calls proc~~str_a_r4p~~CallsGraph proc~str_a_r4p str_a_R4P proc~str_r4p str_R4P proc~str_a_r4p->proc~str_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_r4p~~CalledByGraph proc~str_a_r4p str_a_R4P interface~str str interface~str->proc~str_a_r4p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P","tags":"","loc":"proc/str_a_r4p.html","title":"str_a_R4P – StringiFor"},{"text":"private pure function str_a_I8P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i8p~~CallsGraph proc~str_a_i8p str_a_I8P proc~str_i8p str_I8P proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i8p~~CalledByGraph proc~str_a_i8p str_a_I8P interface~str str interface~str->proc~str_a_i8p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P","tags":"","loc":"proc/str_a_i8p.html","title":"str_a_I8P – StringiFor"},{"text":"private pure function str_a_I4P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i4p~~CallsGraph proc~str_a_i4p str_a_I4P proc~str_i4p str_I4P proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i4p~~CalledByGraph proc~str_a_i4p str_a_I4P interface~str str interface~str->proc~str_a_i4p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P","tags":"","loc":"proc/str_a_i4p.html","title":"str_a_I4P – StringiFor"},{"text":"private pure function str_a_I2P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i2p~~CallsGraph proc~str_a_i2p str_a_I2P proc~str_i2p str_I2P proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i2p~~CalledByGraph proc~str_a_i2p str_a_I2P interface~str str interface~str->proc~str_a_i2p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I2P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P","tags":"","loc":"proc/str_a_i2p.html","title":"str_a_I2P – StringiFor"},{"text":"private pure function str_a_I1P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i1p~~CallsGraph proc~str_a_i1p str_a_I1P proc~str_i1p str_I1P proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i1p~~CalledByGraph proc~str_a_i1p str_a_I1P interface~str str interface~str->proc~str_a_i1p proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I1P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P","tags":"","loc":"proc/str_a_i1p.html","title":"str_a_I1P – StringiFor"},{"text":"private elemental function strz_I8P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. Called By proc~~strz_i8p~~CalledByGraph proc~strz_i8p strz_I8P interface~strz strz interface~strz->proc~strz_i8p program~test_all test_all program~test_all->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P","tags":"","loc":"proc/strz_i8p.html","title":"strz_I8P – StringiFor"},{"text":"private elemental function strz_I4P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i4p~~CalledByGraph proc~strz_i4p strz_I4P interface~strz strz interface~strz->proc~strz_i4p program~test_all test_all program~test_all->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P","tags":"","loc":"proc/strz_i4p.html","title":"strz_I4P – StringiFor"},{"text":"private elemental function strz_I2P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i2p~~CalledByGraph proc~strz_i2p strz_I2P interface~strz strz interface~strz->proc~strz_i2p program~test_all test_all program~test_all->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P","tags":"","loc":"proc/strz_i2p.html","title":"strz_I2P – StringiFor"},{"text":"private elemental function strz_I1P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i1p~~CalledByGraph proc~strz_i1p strz_I1P interface~strz strz interface~strz->proc~strz_i1p program~test_all test_all program~test_all->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P","tags":"","loc":"proc/strz_i1p.html","title":"strz_I1P – StringiFor"},{"text":"private function ctor_R16P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Description Convert string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P","tags":"","loc":"proc/ctor_r16p.html","title":"ctor_R16P – StringiFor"},{"text":"private function ctor_R8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. Called By proc~~ctor_r8p~~CalledByGraph proc~ctor_r8p ctor_R8P interface~cton cton interface~cton->proc~ctor_r8p program~test_all test_all program~test_all->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P","tags":"","loc":"proc/ctor_r8p.html","title":"ctor_R8P – StringiFor"},{"text":"private function ctor_R4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. Called By proc~~ctor_r4p~~CalledByGraph proc~ctor_r4p ctor_R4P interface~cton cton interface~cton->proc~ctor_r4p program~test_all test_all program~test_all->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P","tags":"","loc":"proc/ctor_r4p.html","title":"ctor_R4P – StringiFor"},{"text":"private function ctoi_I8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i8p~~CalledByGraph proc~ctoi_i8p ctoi_I8P interface~cton cton interface~cton->proc~ctoi_i8p program~test_all test_all program~test_all->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P","tags":"","loc":"proc/ctoi_i8p.html","title":"ctoi_I8P – StringiFor"},{"text":"private function ctoi_I4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i4p~~CalledByGraph proc~ctoi_i4p ctoi_I4P interface~cton cton interface~cton->proc~ctoi_i4p program~test_all test_all program~test_all->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P","tags":"","loc":"proc/ctoi_i4p.html","title":"ctoi_I4P – StringiFor"},{"text":"private function ctoi_I2P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i2p~~CalledByGraph proc~ctoi_i2p ctoi_I2P interface~cton cton interface~cton->proc~ctoi_i2p program~test_all test_all program~test_all->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P","tags":"","loc":"proc/ctoi_i2p.html","title":"ctoi_I2P – StringiFor"},{"text":"private function ctoi_I1P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i1p~~CalledByGraph proc~ctoi_i1p ctoi_I1P interface~cton cton interface~cton->proc~ctoi_i1p program~test_all test_all program~test_all->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P","tags":"","loc":"proc/ctoi_i1p.html","title":"ctoi_I1P – StringiFor"},{"text":"private elemental function bstr_R16P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. Source Code elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P","tags":"","loc":"proc/bstr_r16p.html","title":"bstr_R16P – StringiFor"},{"text":"private elemental function bstr_R8P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. Called By proc~~bstr_r8p~~CalledByGraph proc~bstr_r8p bstr_R8P interface~bstr bstr interface~bstr->proc~bstr_r8p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P","tags":"","loc":"proc/bstr_r8p.html","title":"bstr_R8P – StringiFor"},{"text":"private elemental function bstr_R4P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. Called By proc~~bstr_r4p~~CalledByGraph proc~bstr_r4p bstr_R4P interface~bstr bstr interface~bstr->proc~bstr_r4p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P","tags":"","loc":"proc/bstr_r4p.html","title":"bstr_R4P – StringiFor"},{"text":"private elemental function bstr_I8P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. Called By proc~~bstr_i8p~~CalledByGraph proc~bstr_i8p bstr_I8P interface~bstr bstr interface~bstr->proc~bstr_i8p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P","tags":"","loc":"proc/bstr_i8p.html","title":"bstr_I8P – StringiFor"},{"text":"private elemental function bstr_I4P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. Called By proc~~bstr_i4p~~CalledByGraph proc~bstr_i4p bstr_I4P interface~bstr bstr interface~bstr->proc~bstr_i4p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P","tags":"","loc":"proc/bstr_i4p.html","title":"bstr_I4P – StringiFor"},{"text":"private elemental function bstr_I2P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. Called By proc~~bstr_i2p~~CalledByGraph proc~bstr_i2p bstr_I2P interface~bstr bstr interface~bstr->proc~bstr_i2p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P","tags":"","loc":"proc/bstr_i2p.html","title":"bstr_I2P – StringiFor"},{"text":"private elemental function bstr_I1P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. Called By proc~~bstr_i1p~~CalledByGraph proc~bstr_i1p bstr_I1P interface~bstr bstr interface~bstr->proc~bstr_i1p program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P","tags":"","loc":"proc/bstr_i1p.html","title":"bstr_I1P – StringiFor"},{"text":"private elemental function bctor_R16P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r16p~~CallsGraph proc~bctor_r16p bctor_R16P interface~str str proc~bctor_r16p->interface~str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P","tags":"","loc":"proc/bctor_r16p.html","title":"bctor_R16P – StringiFor"},{"text":"private elemental function bctor_R8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r8p~~CallsGraph proc~bctor_r8p bctor_R8P interface~str str proc~bctor_r8p->interface~str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctor_r8p~~CalledByGraph proc~bctor_r8p bctor_R8P interface~bcton bcton interface~bcton->proc~bctor_r8p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P","tags":"","loc":"proc/bctor_r8p.html","title":"bctor_R8P – StringiFor"},{"text":"private elemental function bctor_R4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r4p~~CallsGraph proc~bctor_r4p bctor_R4P interface~str str proc~bctor_r4p->interface~str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctor_r4p~~CalledByGraph proc~bctor_r4p bctor_R4P interface~bcton bcton interface~bcton->proc~bctor_r4p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P","tags":"","loc":"proc/bctor_r4p.html","title":"bctor_R4P – StringiFor"},{"text":"private elemental function bctoi_I8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i8p~~CallsGraph proc~bctoi_i8p bctoi_I8P interface~str str proc~bctoi_i8p->interface~str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i8p~~CalledByGraph proc~bctoi_i8p bctoi_I8P interface~bcton bcton interface~bcton->proc~bctoi_i8p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P","tags":"","loc":"proc/bctoi_i8p.html","title":"bctoi_I8P – StringiFor"},{"text":"private elemental function bctoi_I4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i4p~~CallsGraph proc~bctoi_i4p bctoi_I4P interface~str str proc~bctoi_i4p->interface~str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i4p~~CalledByGraph proc~bctoi_i4p bctoi_I4P interface~bcton bcton interface~bcton->proc~bctoi_i4p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P","tags":"","loc":"proc/bctoi_i4p.html","title":"bctoi_I4P – StringiFor"},{"text":"private elemental function bctoi_I2P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i2p~~CallsGraph proc~bctoi_i2p bctoi_I2P interface~str str proc~bctoi_i2p->interface~str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i2p~~CalledByGraph proc~bctoi_i2p bctoi_I2P interface~bcton bcton interface~bcton->proc~bctoi_i2p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P","tags":"","loc":"proc/bctoi_i2p.html","title":"bctoi_I2P – StringiFor"},{"text":"private elemental function bctoi_I1P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i1p~~CallsGraph proc~bctoi_i1p bctoi_I1P interface~str str proc~bctoi_i1p->interface~str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i1p~~CalledByGraph proc~bctoi_i1p bctoi_I1P interface~bcton bcton interface~bcton->proc~bctoi_i1p program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P","tags":"","loc":"proc/bctoi_i1p.html","title":"bctoi_I1P – StringiFor"},{"text":"public interface str Convert number (real and integer) to string (number to string type casting). Calls interface~~str~~CallsGraph interface~str str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~str~~CalledByGraph interface~str str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str interface~bcton bcton program~test_all->interface~bcton proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string.","tags":"","loc":"interface/str.html","title":"str – StringiFor"},{"text":"public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). Calls interface~~strz~~CallsGraph interface~strz strz proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~strz~~CalledByGraph interface~strz strz program~test_all test_all program~test_all->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros.","tags":"","loc":"interface/strz.html","title":"strz – StringiFor"},{"text":"public interface cton Convert string to number (real and integer, string to number type casting). Calls interface~~cton~~CallsGraph interface~cton cton proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~cton~~CalledByGraph interface~cton cton program~test_all test_all program~test_all->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer.","tags":"","loc":"interface/cton.html","title":"cton – StringiFor"},{"text":"public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). Calls interface~~bstr~~CallsGraph interface~bstr bstr proc~bstr_r8p bstr_R8P interface~bstr->proc~bstr_r8p proc~bstr_i4p bstr_I4P interface~bstr->proc~bstr_i4p proc~bstr_i2p bstr_I2P interface~bstr->proc~bstr_i2p proc~bstr_i1p bstr_I1P interface~bstr->proc~bstr_i1p proc~bstr_r4p bstr_R4P interface~bstr->proc~bstr_r4p proc~bstr_i8p bstr_I8P interface~bstr->proc~bstr_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~bstr~~CalledByGraph interface~bstr bstr program~test_all test_all program~test_all->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits.","tags":"","loc":"interface/bstr.html","title":"bstr – StringiFor"},{"text":"public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). Calls interface~~bcton~~CallsGraph interface~bcton bcton proc~bctor_r4p bctor_R4P interface~bcton->proc~bctor_r4p proc~bctor_r8p bctor_R8P interface~bcton->proc~bctor_r8p proc~bctoi_i1p bctoi_I1P interface~bcton->proc~bctoi_i1p proc~bctoi_i4p bctoi_I4P interface~bcton->proc~bctoi_i4p proc~bctoi_i2p bctoi_I2P interface~bcton->proc~bctoi_i2p proc~bctoi_i8p bctoi_I8P interface~bcton->proc~bctoi_i8p interface~str str proc~bctor_r4p->interface~str proc~bctor_r8p->interface~str proc~bctoi_i1p->interface~str proc~bctoi_i4p->interface~str proc~bctoi_i2p->interface~str proc~bctoi_i8p->interface~str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~bcton~~CalledByGraph interface~bcton bcton program~test_all test_all program~test_all->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer.","tags":"","loc":"interface/bcton.html","title":"bcton – StringiFor"},{"text":"private elemental function digit_I8(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i8~~CalledByGraph proc~digit_i8 digit_I8 interface~digit digit interface~digit->proc~digit_i8 program~test_all test_all program~test_all->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8","tags":"","loc":"proc/digit_i8.html","title":"digit_I8 – StringiFor"},{"text":"private elemental function digit_I4(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i4~~CalledByGraph proc~digit_i4 digit_I4 interface~digit digit interface~digit->proc~digit_i4 program~test_all test_all program~test_all->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4","tags":"","loc":"proc/digit_i4.html","title":"digit_I4 – StringiFor"},{"text":"private elemental function digit_I2(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i2~~CalledByGraph proc~digit_i2 digit_I2 interface~digit digit interface~digit->proc~digit_i2 program~test_all test_all program~test_all->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2","tags":"","loc":"proc/digit_i2.html","title":"digit_I2 – StringiFor"},{"text":"private elemental function digit_I1(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i1~~CalledByGraph proc~digit_i1 digit_I1 interface~digit digit interface~digit->proc~digit_i1 program~test_all test_all program~test_all->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1","tags":"","loc":"proc/digit_i1.html","title":"digit_I1 – StringiFor"},{"text":"public subroutine check_endian() Arguments None Description Check the type of bit ordering (big or little endian) of the running architecture. Note The result is stored into the endian global variable. Calls proc~~check_endian~~CallsGraph proc~check_endian check_endian none~is_little_endian is_little_endian proc~check_endian->none~is_little_endian Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~check_endian~~CalledByGraph proc~check_endian check_endian proc~penf_init penf_init proc~penf_init->proc~check_endian program~test_all test_all program~test_all->proc~penf_init Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions pure function is_little_endian() result(is_little) Arguments None Return Value logical Logical output: true is the running architecture uses little endian ordering, false otherwise. Description Check if the type of the bit ordering of the running architecture is little endian. Source Code subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian","tags":"","loc":"proc/check_endian.html","title":"check_endian – StringiFor"},{"text":"public subroutine penf_init() Arguments None Description Initialize PENF's variables that are not initialized into the definition specification. Calls proc~~penf_init~~CallsGraph proc~penf_init penf_init proc~check_endian check_endian proc~penf_init->proc~check_endian none~is_little_endian is_little_endian proc~check_endian->none~is_little_endian Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~penf_init~~CalledByGraph proc~penf_init penf_init program~test_all test_all program~test_all->proc~penf_init Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init","tags":"","loc":"proc/penf_init.html","title":"penf_init – StringiFor"},{"text":"public subroutine penf_print(unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print to the specified unit the PENF's environment data. Called By proc~~penf_print~~CalledByGraph proc~penf_print penf_print program~test_all test_all program~test_all->proc~penf_print Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. Source Code subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print","tags":"","loc":"proc/penf_print.html","title":"penf_print – StringiFor"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables.","tags":"","loc":"interface/bit_size~2.html","title":"bit_size – StringiFor"},{"text":"public interface digit Compute the number of digits in decimal base of the input integer. Calls interface~~digit~~CallsGraph interface~digit digit proc~digit_i4 digit_I4 interface~digit->proc~digit_i4 proc~digit_i8 digit_I8 interface~digit->proc~digit_i8 proc~digit_i1 digit_I1 interface~digit->proc~digit_i1 proc~digit_i2 digit_I2 interface~digit->proc~digit_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~digit~~CalledByGraph interface~digit digit program~test_all test_all program~test_all->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer.","tags":"","loc":"interface/digit.html","title":"digit – StringiFor"},{"text":"private elemental function basedir(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. Description Return the base directory name of a string containing a file name. Example type ( string ) :: astring astring = '/bar/foo.tar.bz2' print '(A)' , astring % basedir () // '' ! print \"/bar\" Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: pos Character position. Source Code elemental function basedir ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base directory name of a string containing a file name. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = '/bar/foo.tar.bz2' !< print '(A)', astring%basedir()//'' ! print \"/bar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. type ( string ) :: basedir !< Base directory name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basedir = self pos = index ( self % raw , sep_ , back = . true .) if ( pos > 0 ) basedir % raw = self % raw ( 1 : pos - 1 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basedir","tags":"","loc":"proc/basedir.html","title":"basedir – StringiFor"},{"text":"private elemental function basename(self, sep, extension, strip_last_extension) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. character(kind=CK,len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. Description Return the base file name of a string containing a file name. Optionally, the extension is also stripped if provided or the last one if required, e.g. Example type ( string ) :: astring astring = 'bar/foo.tar.bz2' print '(A)' , astring % basename ( extension = '.tar.bz2' ) // '' ! print \"foo\" print '(A)' , astring % basename ( strip_last_extension = . true .) // '' ! print \"foo.tar\" Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: pos Character position. character(kind=CK,len=:), public, allocatable :: temporary Temporary storage, workaround for GNU bug. Source Code elemental function basename ( self , sep , extension , strip_last_extension ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'bar/foo.tar.bz2' !< print '(A)', astring%basename(extension='.tar.bz2')//''        ! print \"foo\" !< print '(A)', astring%basename(strip_last_extension=.true.)//'' ! print \"foo.tar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , sep_ , back = . true .) if ( pos > 0 ) basename % raw = temporary ( pos + 1 :) #else pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) #endif if ( present ( extension )) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , extension , back = . true .) if ( pos > 0 ) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) #endif elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , '.' , back = . true .) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , '.' , back = . true .) basename % raw = basename % raw ( 1 : pos - 1 ) #endif endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basename","tags":"","loc":"proc/basename.html","title":"basename – StringiFor"},{"text":"private elemental function camelcase(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. Description Return a string with all words capitalized without spaces. Note Multiple subsequent separators are collapsed to one occurence. Example ```fortran\n type(string) :: astring\n astring = 'caMeL caSe var'\n print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" Variables Type Visibility Attributes Name Initial type( string ), public, allocatable :: tokens (:) String tokens. Source Code elemental function camelcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction camelcase","tags":"","loc":"proc/camelcase.html","title":"camelcase – StringiFor"},{"text":"private elemental function capitalize(self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with its first character capitalized and the rest lowercased. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function capitalize ( self ) result ( capitalized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with its first character capitalized and the rest lowercased. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction capitalize","tags":"","loc":"proc/capitalize.html","title":"capitalize – StringiFor"},{"text":"private pure function chars(self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data. Source Code pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars","tags":"","loc":"proc/chars.html","title":"chars – StringiFor"},{"text":"private elemental function escape(self, to_escape, esc) result(escaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK,len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. Description Escape backslashes (or custom escape character). Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: esc_ Character to be escaped, local variable. integer, public :: c Character counter. Source Code elemental function escape ( self , to_escape , esc ) result ( escaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Escape backslashes (or custom escape character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to be escaped, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction escape","tags":"","loc":"proc/escape.html","title":"escape – StringiFor"},{"text":"private elemental function extension(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. Description Return the extension of a string containing a file name. Variables Type Visibility Attributes Name Initial integer, public :: pos Character position. character(kind=CK,len=:), public, allocatable :: temporary Temporary storage, workaround for GNU bug. Source Code elemental function basename ( self , sep , extension , strip_last_extension ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'bar/foo.tar.bz2' !< print '(A)', astring%basename(extension='.tar.bz2')//''        ! print \"foo\" !< print '(A)', astring%basename(strip_last_extension=.true.)//'' ! print \"foo.tar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , sep_ , back = . true .) if ( pos > 0 ) basename % raw = temporary ( pos + 1 :) #else pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) #endif if ( present ( extension )) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , extension , back = . true .) if ( pos > 0 ) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) #endif elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , '.' , back = . true .) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , '.' , back = . true .) basename % raw = basename % raw ( 1 : pos - 1 ) #endif endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basename elemental function camelcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction camelcase elemental function capitalize ( self ) result ( capitalized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with its first character capitalized and the rest lowercased. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction capitalize pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars elemental function escape ( self , to_escape , esc ) result ( escaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Escape backslashes (or custom escape character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to be escaped, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction escape elemental function extension ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the extension of a string containing a file name. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: extension !< Extension file name. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then extension = '' pos = index ( self % raw , '.' , back = . true .) #ifdef __GFORTRAN__ temporary = self % raw if ( pos > 0 ) extension % raw = temporary ( pos :) #else if ( pos > 0 ) extension % raw = self % raw ( pos :) #endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction extension","tags":"","loc":"proc/extension.html","title":"extension – StringiFor"},{"text":"private elemental function fill(self, width, right, filling_char) result(filled) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK,len=1), intent(in), optional :: filling_char Filling character (default \"0\"). Return Value type( string ) Filled string. Description Pad string on the left (or right) with zeros (or other char) to fill width. Variables Type Visibility Attributes Name Initial logical, public :: right_ Fill on the right instead of left, local variable. character(kind=CK,len=1), public :: filling_char_ Filling character (default \"0\"), local variable. Source Code elemental function fill ( self , width , right , filling_char ) result ( filled ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pad string on the left (or right) with zeros (or other char) to fill width. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: width !< Final width of filled string. logical , intent ( in ), optional :: right !< Fill on the right instead of left. character ( kind = CK , len = 1 ), intent ( in ), optional :: filling_char !< Filling character (default \"0\"). type ( string ) :: filled !< Filled string. logical :: right_ !< Fill on the right instead of left, local variable. character ( kind = CK , len = 1 ) :: filling_char_ !< Filling character (default \"0\"), local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( width > len ( self % raw )) then right_ = . false . ; if ( present ( right )) right_ = right filling_char_ = '0' ; if ( present ( filling_char )) filling_char_ = filling_char if (. not . right_ ) then filled % raw = repeat ( filling_char_ , width - len ( self % raw )) // self % raw else filled % raw = self % raw // repeat ( filling_char_ , width - len ( self % raw )) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction fill","tags":"","loc":"proc/fill.html","title":"fill – StringiFor"},{"text":"private elemental function lower(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all lowercase characters. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. Source Code elemental function lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all lowercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: lower !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then lower = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) lower % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lower","tags":"","loc":"proc/lower.html","title":"lower – StringiFor"},{"text":"private pure function partition(self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )\n  (1:3) after the separator. Description Split string at separator and return the 3 parts (before, the separator and after). Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: c Character counter. character(kind=CK,len=:), public, allocatable :: temporary Temporary storage, workaround for GNU bug. Source Code pure function partition ( self , sep ) result ( partitions ) !--------------------------------------------------------------------------------------------------------------------------------- !< Split string at separator and return the 3 parts (before, the separator and after). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: partitions ( 1 : 3 ) !< Partions: before the separator, the separator itsels and !< after the separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: c !< Character counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep partitions ( 1 ) = self partitions ( 2 ) = sep_ partitions ( 3 ) = '' if ( len ( sep_ ) >= len ( self % raw )) return c = index ( self % raw , sep_ ) if ( c > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw partitions ( 1 )% raw = temporary ( 1 : c - 1 ) partitions ( 2 )% raw = temporary ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = temporary ( c + len ( sep_ ):) #else partitions ( 1 )% raw = self % raw ( 1 : c - 1 ) partitions ( 2 )% raw = self % raw ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = self % raw ( c + len ( sep_ ):) #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction partition","tags":"","loc":"proc/partition.html","title":"partition – StringiFor"},{"text":"private elemental function replace(self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Description Return a string with all occurrences of substring old replaced by new. Variables Type Visibility Attributes Name Initial integer, public :: r Counter. Source Code elemental function replace ( self , old , new , count ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all occurrences of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. integer , intent ( in ), optional :: count !< Number of old occurences to be replaced. type ( string ) :: replaced !< The string with old replaced by new. integer :: r !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self r = 0 do if ( index ( replaced % raw , old ) > 0 ) then replaced = replaced % replace_one_occurrence ( old = old , new = new ) r = r + 1 if ( present ( count )) then if ( r >= count ) exit endif else exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace","tags":"","loc":"proc/replace.html","title":"replace – StringiFor"},{"text":"private elemental function reverse(self) result(reversed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. Description Return a reversed string. Variables Type Visibility Attributes Name Initial integer, public :: length Length of the string. integer, public :: c Counter. Source Code elemental function reverse ( self ) result ( reversed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a reversed string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: reversed !< The reversed string. integer :: length !< Length of the string. integer :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then reversed = self length = len ( self % raw ) do c = 1 , length reversed % raw ( c : c ) = self % raw ( length - c + 1 : length - c + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction reverse","tags":"","loc":"proc/reverse.html","title":"reverse – StringiFor"},{"text":"private elemental function snakecase(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. Description Return a string with all words lowercase separated by \"_\". Note Multiple subsequent separators are collapsed to one occurence. Variables Type Visibility Attributes Name Initial type( string ), public, allocatable :: tokens (:) String tokens. Source Code elemental function snakecase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words lowercase separated by \"_\". !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: snakecase !< Snake case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % lower () snakecase = snakecase % join ( array = tokens , sep = '_' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction snakecase","tags":"","loc":"proc/snakecase.html","title":"snakecase – StringiFor"},{"text":"private function search(self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: tag_start Start tag. character(kind=CK,len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK,len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. Description Search for tagged record into string, return the first record found (if any) matching the tags. Optionally, returns the indexes of tag start/end, thus this is not an elemental function. Note The tagged record is searched into self if allocated otherwise into in_string if passed or, eventually, into in_character is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are\n zero. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: raw Raw string into which search the tag. integer, public :: istart_ Starting index of tag inside the string, local variable. integer, public :: iend_ Ending index of tag inside the string, local variable. logical, public :: found Flag for inquiring search result. integer, public :: nested_tags Number of nested tags inside tag. integer, public :: t Counter. Source Code function search ( self , tag_start , tag_end , in_string , in_character , istart , iend ) result ( tag ) !--------------------------------------------------------------------------------------------------------------------------------- !< Search for *tagged* record into string, return the first record found (if any) matching the tags. !< !< Optionally, returns the indexes of tag start/end, thus this is not an `elemental` function. !< !< @note The tagged record is searched into self if allocated otherwise into `in_string` if passed or, eventually, into !< `in_character` is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are !< zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: tag_start !< Start tag. character ( kind = CK , len =* ), intent ( in ) :: tag_end !< End tag. type ( string ), intent ( in ), optional :: in_string !< Search into this string. character ( kind = CK , len =* ), intent ( in ), optional :: in_character !< Search into this character string. integer , intent ( out ), optional :: istart !< Starting index of tag inside the string. integer , intent ( out ), optional :: iend !< Ending index of tag inside the string. type ( string ) :: tag !< First tag found. character ( kind = CK , len = :), allocatable :: raw !< Raw string into which search the tag. integer :: istart_ !< Starting index of tag inside the string, local variable. integer :: iend_ !< Ending index of tag inside the string, local variable. logical :: found !< Flag for inquiring search result. integer :: nested_tags !< Number of nested tags inside tag. integer :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- raw = '' if ( present ( in_string )) then raw = in_string % raw elseif ( present ( in_character )) then raw = in_character else if ( allocated ( self % raw )) then raw = self % raw endif endif istart_ = 0 iend_ = 0 if ( raw /= '' ) then found = . false . istart_ = index ( raw , tag_start ) iend_ = index ( raw , tag_end ) if ( istart_ > 0. and . iend_ > 0 ) then iend_ = iend_ + len ( tag_end ) - 1 tag % raw = raw ( istart_ : iend_ ) nested_tags = tag % scount ( tag_start ) if ( nested_tags > 1 ) then do t = 2 , nested_tags iend_ = iend_ + len ( tag_end ) - 1 + index ( raw ( iend_ + 1 :), tag_end ) enddo tag % raw = raw ( istart_ : iend_ ) endif endif endif if ( present ( istart )) istart = istart_ if ( present ( iend )) iend = iend_ return !--------------------------------------------------------------------------------------------------------------------------------- endfunction search","tags":"","loc":"proc/search.html","title":"search – StringiFor"},{"text":"private elemental function startcase(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. Description Return a string with all words capitalized, e.g. title case. Note Multiple subsequent separators are collapsed to one occurence. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. type( string ), public, allocatable :: tokens (:) String tokens. Source Code elemental function startcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized, e.g. title case. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: startcase !< Start case string. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep call self % split ( tokens = tokens , sep = sep_ ) tokens = tokens % capitalize () startcase = startcase % join ( array = tokens , sep = sep_ ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction startcase","tags":"","loc":"proc/startcase.html","title":"startcase – StringiFor"},{"text":"private elemental function strip(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The stripped string. Description Return a copy of the string with the leading and trailing characters removed. Source Code elemental function strip ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with the leading and trailing characters removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: strip !< The stripped string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then strip = self % sadjustl () strip = strip % strim () endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strip","tags":"","loc":"proc/strip.html","title":"strip – StringiFor"},{"text":"private elemental function swapcase(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a copy of the string with uppercase characters converted to lowercase and vice versa. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. Source Code elemental function swapcase ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with uppercase characters converted to lowercase and vice versa. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: swapcase !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then swapcase = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) then swapcase % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) else n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) swapcase % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction swapcase","tags":"","loc":"proc/swapcase.html","title":"swapcase – StringiFor"},{"text":"private elemental function unique(self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Description Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. Note Eventual multiple trailing white space are not reduced to one occurrence. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: substring_ Substring, default value. Source Code elemental function unique ( self , substring ) result ( uniq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: substring !< Substring which multiple occurences must be reduced to one. character ( kind = CK , len = :), allocatable :: substring_ !< Substring, default value. type ( string ) :: uniq !< String parsed. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then substring_ = SPACE ; if ( present ( substring )) substring_ = substring uniq = self do if (. not . uniq % sindex ( repeat ( substring_ , 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( substring_ , 2 ), new = substring_ ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unique","tags":"","loc":"proc/unique.html","title":"unique – StringiFor"},{"text":"private elemental function upper(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all uppercase characters. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. Source Code elemental function upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all uppercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then upper = self do n1 = 1 , len ( self % raw ) n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) upper % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper","tags":"","loc":"proc/upper.html","title":"upper – StringiFor"},{"text":"private elemental function end_with(self, suffix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string ends with a specified suffix. Variables Type Visibility Attributes Name Initial integer, public :: start_ Start position into the string, local variable. integer, public :: end_ End position into the string, local variable. Source Code elemental function end_with ( self , suffix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string ends with a specified suffix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: suffix !< Searched suffix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: end_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- end_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( suffix ) <= len ( self % raw ( start_ : end_ ))) then end_with = index ( self % raw ( start_ : end_ ), suffix ) == ( len ( self % raw ( start_ : end_ )) - len ( suffix ) + 1 ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction end_with","tags":"","loc":"proc/end_with.html","title":"end_with – StringiFor"},{"text":"private elemental function is_allocated(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if the string is allocated. Source Code elemental function is_allocated ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string is allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_allocated !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_allocated = allocated ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_allocated","tags":"","loc":"proc/is_allocated.html","title":"is_allocated – StringiFor"},{"text":"private elemental function is_digit(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are digits. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function is_digit ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are digits. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_digit !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_digit = . false . if ( allocated ( self % raw )) then do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( '0' : '9' ) is_digit = . true . case default is_digit = . false . exit end select enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_digit","tags":"","loc":"proc/is_digit.html","title":"is_digit – StringiFor"},{"text":"private elemental function is_integer(self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains an integer. The regular expression is \\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s* . The parse algorithm is done in stages: S0 S1 S2 S3 S4 S5 S6 \\s* [\\+\\-]? \\d+ [eE] \\+? \\d+ \\s* Exit on stages-parsing results in: S0 S1 S2 S3 S4 S5 S6 F F T F F T T Note This implementation is courtesy of tomedunn Variables Type Visibility Attributes Name Initial logical, public :: allow_spaces_ Allow leading-trailing spaces, local variable. integer, public :: stage Stages counter. integer, public :: c Character counter. Source Code elemental function is_integer ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains an integer. !< !< The regular expression is `\\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3   | S4  | S5  | S6  | !< |-----|---------|-----|------|-----|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d+`|`[eE]`|`\\+?`|`\\d+`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | !< |----|----|----|----|----|----|----| !< |  F |  F |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L294) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_integer !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_integer = . true . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 6 ) is_integer = allow_spaces_ case ( 2 , 5 ) is_integer = allow_spaces_ stage = 6 case default is_integer = . false . endselect case ( '-' ) select case ( stage ) case ( 0 ) stage = 1 case default is_integer = . false . end select case ( '+' ) select case ( stage ) case ( 0 ) stage = 1 case ( 3 ) stage = 4 case default is_integer = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 case ( 3 : 4 ) stage = 5 case default continue endselect case ( 'e' , 'E' ) select case ( stage ) case ( 2 ) stage = 3 case default is_integer = . false . endselect case default is_integer = . false . endselect if (. not . is_integer ) exit enddo endif if ( is_integer ) then select case ( stage ) case ( 2 , 5 , 6 ) is_integer = . true . case default is_integer = . false . end select endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_integer","tags":"","loc":"proc/is_integer.html","title":"is_integer – StringiFor"},{"text":"private elemental function is_lower(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are lowercase. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function is_lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are lowercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_lower !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_lower = . false . if ( allocated ( self % raw )) then is_lower = . true . do c = 1 , len ( self % raw ) if ( index ( UPPER_ALPHABET , self % raw ( c : c )) > 0 ) then is_lower = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_lower","tags":"","loc":"proc/is_lower.html","title":"is_lower – StringiFor"},{"text":"private elemental function is_number(self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a number (real or integer). Source Code elemental function is_number ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a number (real or integer). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_number !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_number = ( self % is_integer ( allow_spaces = allow_spaces ). or . self % is_real ( allow_spaces = allow_spaces )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_number","tags":"","loc":"proc/is_number.html","title":"is_number – StringiFor"},{"text":"private elemental function is_real(self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a real. The regular expression is \\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s* . The parse algorithm is done in stages: S0 S1 S2 S3 S4 S5 S6 S7 S8 \\s* [\\+\\-]? \\d* \\.? \\d* [deDE] [\\+\\-]? \\d* \\s* Exit on stages-parsing results in: S0 S1 S2 S3 S4 S5 S6 S7 S8 Note This implementation is courtesy of tomedunn Variables Type Visibility Attributes Name Initial logical, public :: allow_spaces_ Allow leading-trailing spaces, local variable. logical, public :: has_leading_digit Check the presence of leading digits. integer, public :: stage Stages counter. integer, public :: c Character counter. Source Code elemental function is_real ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a real. !< !< The regular expression is `\\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3  | S4  | S5     | S6      | S7  | S8  | !< |-----|---------|-----|-----|-----|--------|---------|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d*`|`\\.?`|`\\d*`|`[deDE]`|`[\\+\\-]?`|`\\d*`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | !< |----|----|----|----|----|----|----|----|----| !  |  F |  F |  T |  T |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L614) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_real !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. logical :: has_leading_digit !< Check the presence of leading digits. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_real = . true . has_leading_digit = . false . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 8 ) is_real = allow_spaces_ continue case ( 2 : 4 , 7 ) is_real = allow_spaces_ stage = 8 case default is_real = . false . endselect case ( '+' , '-' ) select case ( stage ) case ( 0 ) stage = 1 case ( 5 ) stage = 6 case default is_real = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 has_leading_digit = . true . case ( 3 ) stage = 4 case ( 5 : 6 ) stage = 7 case default continue endselect case ( '.' ) select case ( stage ) case ( 0 : 2 ) stage = 3 case default is_real = . false . endselect case ( 'e' , 'E' , 'd' , 'D' ) select case ( stage ) case ( 2 : 4 ) stage = 5 case default is_real = . false . endselect case default is_real = . false . endselect if (. not . is_real ) exit enddo endif if ( is_real ) then select case ( stage ) case ( 2 , 4 , 7 , 8 ) is_real = . true . case ( 3 ) is_real = has_leading_digit case default is_real = . false . endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_real","tags":"","loc":"proc/is_real.html","title":"is_real – StringiFor"},{"text":"private elemental function is_upper(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are uppercase. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function is_upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are uppercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_upper !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_upper = . false . if ( allocated ( self % raw )) then is_upper = . true . do c = 1 , len ( self % raw ) if ( index ( LOWER_ALPHABET , self % raw ( c : c )) > 0 ) then is_upper = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_upper","tags":"","loc":"proc/is_upper.html","title":"is_upper – StringiFor"},{"text":"private elemental function start_with(self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string starts with a specified prefix. Variables Type Visibility Attributes Name Initial integer, public :: start_ Start position into the string, local variable. integer, public :: end_ End position into the string, local variable. Source Code elemental function start_with ( self , prefix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string starts with a specified prefix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: prefix !< Searched prefix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: start_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- start_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( prefix ) <= len ( self % raw ( start_ : end_ ))) then start_with = index ( self % raw ( start_ : end_ ), prefix ) == 1 endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction start_with","tags":"","loc":"proc/start_with.html","title":"start_with – StringiFor"},{"text":"private elemental function sadjustl(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. Source Code elemental function sadjustl ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl","tags":"","loc":"proc/sadjustl.html","title":"sadjustl – StringiFor"},{"text":"private elemental function sadjustr(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. Source Code elemental function sadjustr ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr","tags":"","loc":"proc/sadjustr.html","title":"sadjustr – StringiFor"},{"text":"private elemental function scount(self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore \"isolated\" occurrences. Return Value integer Number of occurrences. Description Count the number of occurences of a substring into a string. Note If ignore_isolated is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those\n occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a\n right companion). Variables Type Visibility Attributes Name Initial logical, public :: ignore_isolated_ Ignore \"isolated\" occurrences, local variable. integer, public :: c1 Counter. integer, public :: c2 Counter. character(kind=CK,len=:), public, allocatable :: temporary Temporary storage, workaround for GNU bug. Source Code elemental function scount ( self , substring , ignore_isolated ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !< !< @note If `ignore_isolated` is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those !< occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a !< right companion). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: substring !< Substring. logical , intent ( in ), optional :: ignore_isolated !< Ignore \"isolated\" occurrences. integer :: No !< Number of occurrences. logical :: ignore_isolated_ !< Ignore \"isolated\" occurrences, local variable. integer :: c1 !< Counter. integer :: c2 !< Counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( allocated ( self % raw )) then if ( len ( substring ) > len ( self % raw )) return ignore_isolated_ = . false . ; if ( present ( ignore_isolated )) ignore_isolated_ = ignore_isolated #ifdef __GFORTRAN__ temporary = self % raw #endif c1 = 1 do #ifdef __GFORTRAN__ c2 = index ( string = temporary ( c1 :), substring = substring ) #else c2 = index ( string = self % raw ( c1 :), substring = substring ) #endif if ( c2 == 0 ) return if (. not .( ignore_isolated_ . and .( c1 == 1. or . c1 + c2 - 1 == len ( self % raw ) - len ( substring ) + 1 ))) then No = No + 1 endif c1 = c1 + c2 - 1 + len ( substring ) enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction scount","tags":"","loc":"proc/scount.html","title":"scount – StringiFor"},{"text":"private elemental function sindex(self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Source Code elemental function sindex ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex","tags":"","loc":"proc/sindex.html","title":"sindex – StringiFor"},{"text":"private elemental function slen(self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. Source Code elemental function slen ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen","tags":"","loc":"proc/slen.html","title":"slen – StringiFor"},{"text":"private elemental function slen_trim(self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks. Source Code elemental function slen_trim ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string, ignoring any trailing blanks. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen_trim","tags":"","loc":"proc/slen_trim.html","title":"slen_trim – StringiFor"},{"text":"private elemental function srepeat(rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Source Code elemental function srepeat ( rstring , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = rstring , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat","tags":"","loc":"proc/srepeat.html","title":"srepeat – StringiFor"},{"text":"private elemental function sscan(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Source Code elemental function sscan ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan","tags":"","loc":"proc/sscan.html","title":"sscan – StringiFor"},{"text":"private elemental function strim(self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. Source Code elemental function strim ( self ) result ( trimmed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Remove leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strim","tags":"","loc":"proc/strim.html","title":"strim – StringiFor"},{"text":"private elemental function sverify(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Source Code elemental function sverify ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sverify","tags":"","loc":"proc/sverify.html","title":"sverify – StringiFor"},{"text":"private pure function string_concat_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. Source Code pure function string_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string","tags":"","loc":"proc/string_concat_string.html","title":"string_concat_string – StringiFor"},{"text":"private pure function string_concat_character(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. Source Code pure function string_concat_character ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character","tags":"","loc":"proc/string_concat_character.html","title":"string_concat_character – StringiFor"},{"text":"private pure function character_concat_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). Source Code pure function character_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string","tags":"","loc":"proc/character_concat_string.html","title":"character_concat_string – StringiFor"},{"text":"private elemental function string_concat_string_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: temporary Temporary concatenated string. Source Code elemental function string_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( kind = CK , len = :), allocatable :: temporary !< Temporary concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string_string","tags":"","loc":"proc/string_concat_string_string.html","title":"string_concat_string_string – StringiFor"},{"text":"private elemental function string_concat_character_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. Source Code elemental function string_concat_character_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character_string","tags":"","loc":"proc/string_concat_character_string.html","title":"string_concat_character_string – StringiFor"},{"text":"private elemental function character_concat_string_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). Source Code elemental function character_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string_string","tags":"","loc":"proc/character_concat_string_string.html","title":"character_concat_string_string – StringiFor"},{"text":"private elemental function replace_one_occurrence(self, old, new) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Description Return a string with the first occurrence of substring old replaced by new. Variables Type Visibility Attributes Name Initial integer, public :: pos Position from which replace old. character(kind=CK,len=:), public, allocatable :: temporary Temporary storage, workaround for GNU bug. Source Code elemental function replace_one_occurrence ( self , old , new ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with the first occurrence of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. type ( string ) :: replaced !< The string with old replaced by new. integer :: pos !< Position from which replace old. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self pos = index ( string = self % raw , substring = old ) if ( pos > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw if ( pos == 1 ) then replaced % raw = new // temporary ( len ( old ) + 1 :) else replaced % raw = temporary ( 1 : pos - 1 ) // new // temporary ( pos + len ( old ):) endif #else if ( pos == 1 ) then replaced % raw = new // self % raw ( len ( old ) + 1 :) else replaced % raw = self % raw ( 1 : pos - 1 ) // new // self % raw ( pos + len ( old ):) endif #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace_one_occurrence","tags":"","loc":"proc/replace_one_occurrence.html","title":"replace_one_occurrence – StringiFor"},{"text":"private pure function join_strings(self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden\n passing a custom separator. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: a Counter. Source Code pure function join_strings ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_strings","tags":"","loc":"proc/join_strings.html","title":"join_strings – StringiFor"},{"text":"private pure function join_characters(self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden\n passing a custom separator. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: a Counter. Source Code pure function join_characters ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_characters","tags":"","loc":"proc/join_characters.html","title":"join_characters – StringiFor"},{"text":"private elemental function to_integer_I1P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). Source Code elemental function to_integer_I1P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I1P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I1P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I1P","tags":"","loc":"proc/to_integer_i1p.html","title":"to_integer_I1P – StringiFor"},{"text":"private elemental function to_integer_I2P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). Source Code elemental function to_integer_I2P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I2P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I2P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I2P","tags":"","loc":"proc/to_integer_i2p.html","title":"to_integer_I2P – StringiFor"},{"text":"private elemental function to_integer_I4P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). Source Code elemental function to_integer_I4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I4P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I4P","tags":"","loc":"proc/to_integer_i4p.html","title":"to_integer_I4P – StringiFor"},{"text":"private elemental function to_integer_I8P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). Source Code elemental function to_integer_I8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I8P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I8P","tags":"","loc":"proc/to_integer_i8p.html","title":"to_integer_I8P – StringiFor"},{"text":"private elemental function to_real_R4P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). Source Code elemental function to_real_R4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R4P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R4P","tags":"","loc":"proc/to_real_r4p.html","title":"to_real_R4P – StringiFor"},{"text":"private elemental function to_real_R8P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). Source Code elemental function to_real_R8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R8P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R8P","tags":"","loc":"proc/to_real_r8p.html","title":"to_real_R8P – StringiFor"},{"text":"private elemental function to_real_R16P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. Description Cast string to real (R16P). Source Code elemental function to_real_R16P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R16P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R16P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R16P","tags":"","loc":"proc/to_real_r16p.html","title":"to_real_R16P – StringiFor"},{"text":"private elemental subroutine free(self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Description Free dynamic memory. Source Code elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) deallocate ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free.html","title":"free – StringiFor"},{"text":"private pure subroutine split(self, tokens, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. Description Return a list of substring in the string, using sep as the delimiter string. Note Multiple subsequent separators are collapsed to one occurence. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: No Number of occurrences of sep. integer, public :: t Character counter. type( string ), public :: temporary Temporary storage. type( string ), public, allocatable :: temp_toks (:,:) Temporary tokens substring. Source Code pure subroutine split ( self , tokens , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a list of substring in the string, using sep as the delimiter string. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: No !< Number of occurrences of sep. integer :: t !< Character counter. type ( string ) :: temporary !< Temporary storage. type ( string ), allocatable :: temp_toks (:,:) !< Temporary tokens substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep temporary = self % unique ( sep_ ) No = temporary % scount ( sep_ ) allocate ( temp_toks ( 3 , No )) temp_toks (:, 1 ) = temporary % partition ( sep_ ) if ( No > 1 ) then do t = 2 , No temp_toks (:, t ) = temp_toks ( 3 , t - 1 )% partition ( sep_ ) enddo endif if ( temp_toks ( 1 , 1 )% raw /= '' . and . temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No + 1 )) do t = 1 , No if ( t == No ) then tokens ( t ) = temp_toks ( 1 , t ) tokens ( t + 1 ) = temp_toks ( 3 , t ) else tokens ( t ) = temp_toks ( 1 , t ) endif enddo elseif ( temp_toks ( 1 , 1 )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No tokens ( t ) = temp_toks ( 1 , t ) enddo elseif ( temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No )) do t = 2 , No if ( t == No ) then tokens ( t - 1 ) = temp_toks ( 1 , t ) tokens ( t ) = temp_toks ( 3 , t ) else tokens ( t - 1 ) = temp_toks ( 1 , t ) endif enddo else allocate ( tokens ( No - 1 )) do t = 2 , No tokens ( t - 1 ) = temp_toks ( 1 , t ) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine split","tags":"","loc":"proc/split.html","title":"split – StringiFor"},{"text":"private elemental subroutine string_assign_string(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. Source Code elemental subroutine string_assign_string ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from string input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) lhs % raw = rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_string","tags":"","loc":"proc/string_assign_string.html","title":"string_assign_string – StringiFor"},{"text":"private elemental subroutine string_assign_character(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. Source Code elemental subroutine string_assign_character ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from character input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_character","tags":"","loc":"proc/string_assign_character.html","title":"string_assign_character – StringiFor"},{"text":"private elemental subroutine string_assign_integer_I1P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i1p~~CallsGraph proc~string_assign_integer_i1p string_assign_integer_I1P interface~str str proc~string_assign_integer_i1p->interface~str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I1P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I1P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I1P","tags":"","loc":"proc/string_assign_integer_i1p.html","title":"string_assign_integer_I1P – StringiFor"},{"text":"private elemental subroutine string_assign_integer_I2P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i2p~~CallsGraph proc~string_assign_integer_i2p string_assign_integer_I2P interface~str str proc~string_assign_integer_i2p->interface~str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I2P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I2P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I2P","tags":"","loc":"proc/string_assign_integer_i2p.html","title":"string_assign_integer_I2P – StringiFor"},{"text":"private elemental subroutine string_assign_integer_I4P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i4p~~CallsGraph proc~string_assign_integer_i4p string_assign_integer_I4P interface~str str proc~string_assign_integer_i4p->interface~str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I4P","tags":"","loc":"proc/string_assign_integer_i4p.html","title":"string_assign_integer_I4P – StringiFor"},{"text":"private elemental subroutine string_assign_integer_I8P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i8p~~CallsGraph proc~string_assign_integer_i8p string_assign_integer_I8P interface~str str proc~string_assign_integer_i8p->interface~str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I8P","tags":"","loc":"proc/string_assign_integer_i8p.html","title":"string_assign_integer_I8P – StringiFor"},{"text":"private elemental subroutine string_assign_real_R4P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_real_r4p~~CallsGraph proc~string_assign_real_r4p string_assign_real_R4P interface~str str proc~string_assign_real_r4p->interface~str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_real_R4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R4P","tags":"","loc":"proc/string_assign_real_r4p.html","title":"string_assign_real_R4P – StringiFor"},{"text":"private elemental subroutine string_assign_real_R8P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_real_r8p~~CallsGraph proc~string_assign_real_r8p string_assign_real_R8P interface~str str proc~string_assign_real_r8p->interface~str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_real_R8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R8P","tags":"","loc":"proc/string_assign_real_r8p.html","title":"string_assign_real_R8P – StringiFor"},{"text":"private elemental subroutine string_assign_real_R16P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_real_r16p~~CallsGraph proc~string_assign_real_r16p string_assign_real_R16P interface~str str proc~string_assign_real_r16p->interface~str proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_real_R16P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R16P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R16P","tags":"","loc":"proc/string_assign_real_r16p.html","title":"string_assign_real_R16P – StringiFor"},{"text":"private subroutine read_formatted_(dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Variables Type Visibility Attributes Name Initial character(kind=CK,len=100), public :: temporary Temporary storage string. Source Code subroutine read_formatted_ ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted_","tags":"","loc":"proc/read_formatted_.html","title":"read_formatted_ – StringiFor"},{"text":"private subroutine read_formatted_internal(dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. character(kind=CK,len=*), intent(in) :: iunit Internal unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted input from internal. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Variables Type Visibility Attributes Name Initial character(kind=CK,len=100), public :: temporary Temporary storage string. Source Code subroutine read_formatted_internal ( dtv , iunit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input from internal. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. character ( kind = CK , len =* ), intent ( in ) :: iunit !< Internal unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted_internal","tags":"","loc":"proc/read_formatted_internal.html","title":"read_formatted_internal – StringiFor"},{"text":"private subroutine write_formatted_(dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. Source Code subroutine write_formatted_ ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted_","tags":"","loc":"proc/write_formatted_.html","title":"write_formatted_ – StringiFor"},{"text":"private subroutine write_formatted_internal(dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. character(kind=CK,len=*), intent(inout) :: iunit Interanl unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output to internal. Source Code subroutine write_formatted_internal ( dtv , iunit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output to internal. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. character ( kind = CK , len =* ), intent ( inout ) :: iunit !< Interanl unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted_internal","tags":"","loc":"proc/write_formatted_internal.html","title":"write_formatted_internal – StringiFor"},{"text":"private subroutine read_unformatted_(dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Variables Type Visibility Attributes Name Initial character(kind=CK,len=100), public :: temporary Temporary storage string. Source Code subroutine read_unformatted_ ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_unformatted_","tags":"","loc":"proc/read_unformatted_.html","title":"read_unformatted_ – StringiFor"},{"text":"private subroutine write_unformatted_(dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. Source Code subroutine write_unformatted_ ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_unformatted_","tags":"","loc":"proc/write_unformatted_.html","title":"write_unformatted_ – StringiFor"},{"text":"private elemental function bit_size_R16P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Compute the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P","tags":"","loc":"proc/bit_size_r16p~2.html","title":"bit_size_R16P – StringiFor"},{"text":"private elemental function bit_size_R8P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. Called By proc~~bit_size_r8p~2~~CalledByGraph proc~bit_size_r8p~2 bit_size_R8P interface~bit_size~3 bit_size interface~bit_size~3->proc~bit_size_r8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P","tags":"","loc":"proc/bit_size_r8p~2.html","title":"bit_size_R8P – StringiFor"},{"text":"private elemental function bit_size_R4P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. Called By proc~~bit_size_r4p~2~~CalledByGraph proc~bit_size_r4p~2 bit_size_R4P interface~bit_size~3 bit_size interface~bit_size~3->proc~bit_size_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P","tags":"","loc":"proc/bit_size_r4p~2.html","title":"bit_size_R4P – StringiFor"},{"text":"private elemental function bit_size_chr(i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. Called By proc~~bit_size_chr~2~~CalledByGraph proc~bit_size_chr~2 bit_size_chr interface~bit_size~3 bit_size interface~bit_size~3->proc~bit_size_chr~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr","tags":"","loc":"proc/bit_size_chr~2.html","title":"bit_size_chr – StringiFor"},{"text":"private elemental function byte_size_I8P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i8p~2~~CalledByGraph proc~byte_size_i8p~2 byte_size_I8P interface~byte_size~2 byte_size interface~byte_size~2->proc~byte_size_i8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P","tags":"","loc":"proc/byte_size_i8p~2.html","title":"byte_size_I8P – StringiFor"},{"text":"private elemental function byte_size_I4P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i4p~2~~CalledByGraph proc~byte_size_i4p~2 byte_size_I4P interface~byte_size~2 byte_size interface~byte_size~2->proc~byte_size_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P","tags":"","loc":"proc/byte_size_i4p~2.html","title":"byte_size_I4P – StringiFor"},{"text":"private elemental function byte_size_I2P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i2p~2~~CalledByGraph proc~byte_size_i2p~2 byte_size_I2P interface~byte_size~2 byte_size interface~byte_size~2->proc~byte_size_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P","tags":"","loc":"proc/byte_size_i2p~2.html","title":"byte_size_I2P – StringiFor"},{"text":"private elemental function byte_size_I1P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i1p~2~~CalledByGraph proc~byte_size_i1p~2 byte_size_I1P interface~byte_size~2 byte_size interface~byte_size~2->proc~byte_size_i1p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P","tags":"","loc":"proc/byte_size_i1p~2.html","title":"byte_size_I1P – StringiFor"},{"text":"private elemental function byte_size_R16P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Source Code elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P","tags":"","loc":"proc/byte_size_r16p~2.html","title":"byte_size_R16P – StringiFor"},{"text":"private elemental function byte_size_R8P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Called By proc~~byte_size_r8p~2~~CalledByGraph proc~byte_size_r8p~2 byte_size_R8P interface~byte_size~2 byte_size interface~byte_size~2->proc~byte_size_r8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P","tags":"","loc":"proc/byte_size_r8p~2.html","title":"byte_size_R8P – StringiFor"},{"text":"private elemental function byte_size_R4P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Called By proc~~byte_size_r4p~2~~CalledByGraph proc~byte_size_r4p~2 byte_size_R4P interface~byte_size~2 byte_size interface~byte_size~2->proc~byte_size_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P","tags":"","loc":"proc/byte_size_r4p~2.html","title":"byte_size_R4P – StringiFor"},{"text":"private elemental function byte_size_chr(i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable. Called By proc~~byte_size_chr~2~~CalledByGraph proc~byte_size_chr~2 byte_size_chr interface~byte_size~2 byte_size interface~byte_size~2->proc~byte_size_chr~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr","tags":"","loc":"proc/byte_size_chr~2.html","title":"byte_size_chr – StringiFor"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. Calls interface~~bit_size~3~~CallsGraph interface~bit_size~3 bit_size proc~bit_size_r8p~2 bit_size_R8P interface~bit_size~3->proc~bit_size_r8p~2 proc~bit_size_r4p~2 bit_size_R4P interface~bit_size~3->proc~bit_size_r4p~2 proc~bit_size_chr~2 bit_size_chr interface~bit_size~3->proc~bit_size_chr~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable.","tags":"","loc":"interface/bit_size~3.html","title":"bit_size – StringiFor"},{"text":"public interface byte_size Compute the number of bytes of a variable. Calls interface~~byte_size~2~~CallsGraph interface~byte_size~2 byte_size proc~byte_size_i1p~2 byte_size_I1P interface~byte_size~2->proc~byte_size_i1p~2 proc~byte_size_chr~2 byte_size_chr interface~byte_size~2->proc~byte_size_chr~2 proc~byte_size_i8p~2 byte_size_I8P interface~byte_size~2->proc~byte_size_i8p~2 proc~byte_size_i2p~2 byte_size_I2P interface~byte_size~2->proc~byte_size_i2p~2 proc~byte_size_r8p~2 byte_size_R8P interface~byte_size~2->proc~byte_size_r8p~2 proc~byte_size_r4p~2 byte_size_R4P interface~byte_size~2->proc~byte_size_r4p~2 proc~byte_size_i4p~2 byte_size_I4P interface~byte_size~2->proc~byte_size_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable.","tags":"","loc":"interface/byte_size~2.html","title":"byte_size – StringiFor"},{"text":"private elemental function strf_R16P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. Source Code elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P","tags":"","loc":"proc/strf_r16p~2.html","title":"strf_R16P – StringiFor"},{"text":"private elemental function strf_R8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. Called By proc~~strf_r8p~2~~CalledByGraph proc~strf_r8p~2 strf_R8P interface~str~2 str interface~str~2->proc~strf_r8p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P","tags":"","loc":"proc/strf_r8p~2.html","title":"strf_R8P – StringiFor"},{"text":"private elemental function strf_R4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. Called By proc~~strf_r4p~2~~CalledByGraph proc~strf_r4p~2 strf_R4P interface~str~2 str interface~str~2->proc~strf_r4p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P","tags":"","loc":"proc/strf_r4p~2.html","title":"strf_R4P – StringiFor"},{"text":"private elemental function strf_I8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i8p~2~~CalledByGraph proc~strf_i8p~2 strf_I8P interface~str~2 str interface~str~2->proc~strf_i8p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P","tags":"","loc":"proc/strf_i8p~2.html","title":"strf_I8P – StringiFor"},{"text":"private elemental function strf_I4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i4p~2~~CalledByGraph proc~strf_i4p~2 strf_I4P interface~str~2 str interface~str~2->proc~strf_i4p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P","tags":"","loc":"proc/strf_i4p~2.html","title":"strf_I4P – StringiFor"},{"text":"private elemental function strf_I2P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i2p~2~~CalledByGraph proc~strf_i2p~2 strf_I2P interface~str~2 str interface~str~2->proc~strf_i2p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P","tags":"","loc":"proc/strf_i2p~2.html","title":"strf_I2P – StringiFor"},{"text":"private elemental function strf_I1P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i1p~2~~CalledByGraph proc~strf_i1p~2 strf_I1P interface~str~2 str interface~str~2->proc~strf_i1p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P","tags":"","loc":"proc/strf_i1p~2.html","title":"strf_I1P – StringiFor"},{"text":"private elemental function str_R16P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r16p~2~~CalledByGraph proc~str_r16p~2 str_R16P proc~str_a_r16p~2 str_a_R16P proc~str_a_r16p~2->proc~str_r16p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R16P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P","tags":"","loc":"proc/str_r16p~2.html","title":"str_R16P – StringiFor"},{"text":"private elemental function str_R8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r8p~2~~CalledByGraph proc~str_r8p~2 str_R8P proc~str_a_r8p~2 str_a_R8P proc~str_a_r8p~2->proc~str_r8p~2 interface~str~2 str interface~str~2->proc~str_r8p~2 interface~str~2->proc~str_a_r8p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P","tags":"","loc":"proc/str_r8p~2.html","title":"str_R8P – StringiFor"},{"text":"private elemental function str_R4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r4p~2~~CalledByGraph proc~str_r4p~2 str_R4P proc~str_a_r4p~2 str_a_R4P proc~str_a_r4p~2->proc~str_r4p~2 interface~str~2 str interface~str~2->proc~str_r4p~2 interface~str~2->proc~str_a_r4p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P","tags":"","loc":"proc/str_r4p~2.html","title":"str_R4P – StringiFor"},{"text":"private elemental function str_I8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i8p~2~~CalledByGraph proc~str_i8p~2 str_I8P proc~str_a_i8p~2 str_a_I8P proc~str_a_i8p~2->proc~str_i8p~2 interface~str~2 str interface~str~2->proc~str_i8p~2 interface~str~2->proc~str_a_i8p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P","tags":"","loc":"proc/str_i8p~2.html","title":"str_I8P – StringiFor"},{"text":"private elemental function str_I4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. Called By proc~~str_i4p~2~~CalledByGraph proc~str_i4p~2 str_I4P proc~str_a_i4p~2 str_a_I4P proc~str_a_i4p~2->proc~str_i4p~2 interface~str~2 str interface~str~2->proc~str_i4p~2 interface~str~2->proc~str_a_i4p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P","tags":"","loc":"proc/str_i4p~2.html","title":"str_I4P – StringiFor"},{"text":"private elemental function str_I2P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i2p~2~~CalledByGraph proc~str_i2p~2 str_I2P proc~str_a_i2p~2 str_a_I2P proc~str_a_i2p~2->proc~str_i2p~2 interface~str~2 str interface~str~2->proc~str_i2p~2 interface~str~2->proc~str_a_i2p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P","tags":"","loc":"proc/str_i2p~2.html","title":"str_I2P – StringiFor"},{"text":"private elemental function str_I1P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i1p~2~~CalledByGraph proc~str_i1p~2 str_I1P proc~str_a_i1p~2 str_a_I1P proc~str_a_i1p~2->proc~str_i1p~2 interface~str~2 str interface~str~2->proc~str_i1p~2 interface~str~2->proc~str_a_i1p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P","tags":"","loc":"proc/str_i1p~2.html","title":"str_I1P – StringiFor"},{"text":"private elemental function str_bol(n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. Called By proc~~str_bol~2~~CalledByGraph proc~str_bol~2 str_bol interface~str~2 str interface~str~2->proc~str_bol~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol","tags":"","loc":"proc/str_bol~2.html","title":"str_bol – StringiFor"},{"text":"private pure function str_a_R16P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Converting real array to string. Calls proc~~str_a_r16p~2~~CallsGraph proc~str_a_r16p~2 str_a_R16P proc~str_r16p~2 str_R16P proc~str_a_r16p~2->proc~str_r16p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR16P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R16P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P","tags":"","loc":"proc/str_a_r16p~2.html","title":"str_a_R16P – StringiFor"},{"text":"private pure function str_a_R8P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. Calls proc~~str_a_r8p~2~~CallsGraph proc~str_a_r8p~2 str_a_R8P proc~str_r8p~2 str_R8P proc~str_a_r8p~2->proc~str_r8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_r8p~2~~CalledByGraph proc~str_a_r8p~2 str_a_R8P interface~str~2 str interface~str~2->proc~str_a_r8p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P","tags":"","loc":"proc/str_a_r8p~2.html","title":"str_a_R8P – StringiFor"},{"text":"private pure function str_a_R4P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. Calls proc~~str_a_r4p~2~~CallsGraph proc~str_a_r4p~2 str_a_R4P proc~str_r4p~2 str_R4P proc~str_a_r4p~2->proc~str_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_r4p~2~~CalledByGraph proc~str_a_r4p~2 str_a_R4P interface~str~2 str interface~str~2->proc~str_a_r4p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P","tags":"","loc":"proc/str_a_r4p~2.html","title":"str_a_R4P – StringiFor"},{"text":"private pure function str_a_I8P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i8p~2~~CallsGraph proc~str_a_i8p~2 str_a_I8P proc~str_i8p~2 str_I8P proc~str_a_i8p~2->proc~str_i8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i8p~2~~CalledByGraph proc~str_a_i8p~2 str_a_I8P interface~str~2 str interface~str~2->proc~str_a_i8p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P","tags":"","loc":"proc/str_a_i8p~2.html","title":"str_a_I8P – StringiFor"},{"text":"private pure function str_a_I4P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i4p~2~~CallsGraph proc~str_a_i4p~2 str_a_I4P proc~str_i4p~2 str_I4P proc~str_a_i4p~2->proc~str_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i4p~2~~CalledByGraph proc~str_a_i4p~2 str_a_I4P interface~str~2 str interface~str~2->proc~str_a_i4p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P","tags":"","loc":"proc/str_a_i4p~2.html","title":"str_a_I4P – StringiFor"},{"text":"private pure function str_a_I2P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i2p~2~~CallsGraph proc~str_a_i2p~2 str_a_I2P proc~str_i2p~2 str_I2P proc~str_a_i2p~2->proc~str_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i2p~2~~CalledByGraph proc~str_a_i2p~2 str_a_I2P interface~str~2 str interface~str~2->proc~str_a_i2p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I2P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P","tags":"","loc":"proc/str_a_i2p~2.html","title":"str_a_I2P – StringiFor"},{"text":"private pure function str_a_I1P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i1p~2~~CallsGraph proc~str_a_i1p~2 str_a_I1P proc~str_i1p~2 str_I1P proc~str_a_i1p~2->proc~str_i1p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i1p~2~~CalledByGraph proc~str_a_i1p~2 str_a_I1P interface~str~2 str interface~str~2->proc~str_a_i1p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I1P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P","tags":"","loc":"proc/str_a_i1p~2.html","title":"str_a_I1P – StringiFor"},{"text":"private elemental function strz_I8P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. Called By proc~~strz_i8p~2~~CalledByGraph proc~strz_i8p~2 strz_I8P interface~strz~2 strz interface~strz~2->proc~strz_i8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P","tags":"","loc":"proc/strz_i8p~2.html","title":"strz_I8P – StringiFor"},{"text":"private elemental function strz_I4P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i4p~2~~CalledByGraph proc~strz_i4p~2 strz_I4P interface~strz~2 strz interface~strz~2->proc~strz_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P","tags":"","loc":"proc/strz_i4p~2.html","title":"strz_I4P – StringiFor"},{"text":"private elemental function strz_I2P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i2p~2~~CalledByGraph proc~strz_i2p~2 strz_I2P interface~strz~2 strz interface~strz~2->proc~strz_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P","tags":"","loc":"proc/strz_i2p~2.html","title":"strz_I2P – StringiFor"},{"text":"private elemental function strz_I1P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i1p~2~~CalledByGraph proc~strz_i1p~2 strz_I1P interface~strz~2 strz interface~strz~2->proc~strz_i1p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P","tags":"","loc":"proc/strz_i1p~2.html","title":"strz_I1P – StringiFor"},{"text":"private function ctor_R16P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Description Convert string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P","tags":"","loc":"proc/ctor_r16p~2.html","title":"ctor_R16P – StringiFor"},{"text":"private function ctor_R8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. Called By proc~~ctor_r8p~2~~CalledByGraph proc~ctor_r8p~2 ctor_R8P interface~cton~2 cton interface~cton~2->proc~ctor_r8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P","tags":"","loc":"proc/ctor_r8p~2.html","title":"ctor_R8P – StringiFor"},{"text":"private function ctor_R4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. Called By proc~~ctor_r4p~2~~CalledByGraph proc~ctor_r4p~2 ctor_R4P interface~cton~2 cton interface~cton~2->proc~ctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P","tags":"","loc":"proc/ctor_r4p~2.html","title":"ctor_R4P – StringiFor"},{"text":"private function ctoi_I8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i8p~2~~CalledByGraph proc~ctoi_i8p~2 ctoi_I8P interface~cton~2 cton interface~cton~2->proc~ctoi_i8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P","tags":"","loc":"proc/ctoi_i8p~2.html","title":"ctoi_I8P – StringiFor"},{"text":"private function ctoi_I4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i4p~2~~CalledByGraph proc~ctoi_i4p~2 ctoi_I4P interface~cton~2 cton interface~cton~2->proc~ctoi_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P","tags":"","loc":"proc/ctoi_i4p~2.html","title":"ctoi_I4P – StringiFor"},{"text":"private function ctoi_I2P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i2p~2~~CalledByGraph proc~ctoi_i2p~2 ctoi_I2P interface~cton~2 cton interface~cton~2->proc~ctoi_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P","tags":"","loc":"proc/ctoi_i2p~2.html","title":"ctoi_I2P – StringiFor"},{"text":"private function ctoi_I1P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i1p~2~~CalledByGraph proc~ctoi_i1p~2 ctoi_I1P interface~cton~2 cton interface~cton~2->proc~ctoi_i1p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P","tags":"","loc":"proc/ctoi_i1p~2.html","title":"ctoi_I1P – StringiFor"},{"text":"private elemental function bstr_R16P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. Source Code elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P","tags":"","loc":"proc/bstr_r16p~2.html","title":"bstr_R16P – StringiFor"},{"text":"private elemental function bstr_R8P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. Called By proc~~bstr_r8p~2~~CalledByGraph proc~bstr_r8p~2 bstr_R8P interface~bstr~2 bstr interface~bstr~2->proc~bstr_r8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P","tags":"","loc":"proc/bstr_r8p~2.html","title":"bstr_R8P – StringiFor"},{"text":"private elemental function bstr_R4P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. Called By proc~~bstr_r4p~2~~CalledByGraph proc~bstr_r4p~2 bstr_R4P interface~bstr~2 bstr interface~bstr~2->proc~bstr_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P","tags":"","loc":"proc/bstr_r4p~2.html","title":"bstr_R4P – StringiFor"},{"text":"private elemental function bstr_I8P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. Called By proc~~bstr_i8p~2~~CalledByGraph proc~bstr_i8p~2 bstr_I8P interface~bstr~2 bstr interface~bstr~2->proc~bstr_i8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P","tags":"","loc":"proc/bstr_i8p~2.html","title":"bstr_I8P – StringiFor"},{"text":"private elemental function bstr_I4P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. Called By proc~~bstr_i4p~2~~CalledByGraph proc~bstr_i4p~2 bstr_I4P interface~bstr~2 bstr interface~bstr~2->proc~bstr_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P","tags":"","loc":"proc/bstr_i4p~2.html","title":"bstr_I4P – StringiFor"},{"text":"private elemental function bstr_I2P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. Called By proc~~bstr_i2p~2~~CalledByGraph proc~bstr_i2p~2 bstr_I2P interface~bstr~2 bstr interface~bstr~2->proc~bstr_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P","tags":"","loc":"proc/bstr_i2p~2.html","title":"bstr_I2P – StringiFor"},{"text":"private elemental function bstr_I1P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. Called By proc~~bstr_i1p~2~~CalledByGraph proc~bstr_i1p~2 bstr_I1P interface~bstr~2 bstr interface~bstr~2->proc~bstr_i1p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P","tags":"","loc":"proc/bstr_i1p~2.html","title":"bstr_I1P – StringiFor"},{"text":"private elemental function bctor_R16P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r16p~2~~CallsGraph proc~bctor_r16p~2 bctor_R16P interface~str~2 str proc~bctor_r16p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P","tags":"","loc":"proc/bctor_r16p~2.html","title":"bctor_R16P – StringiFor"},{"text":"private elemental function bctor_R8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r8p~2~~CallsGraph proc~bctor_r8p~2 bctor_R8P interface~str~2 str proc~bctor_r8p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctor_r8p~2~~CalledByGraph proc~bctor_r8p~2 bctor_R8P interface~bcton~2 bcton interface~bcton~2->proc~bctor_r8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P","tags":"","loc":"proc/bctor_r8p~2.html","title":"bctor_R8P – StringiFor"},{"text":"private elemental function bctor_R4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r4p~2~~CallsGraph proc~bctor_r4p~2 bctor_R4P interface~str~2 str proc~bctor_r4p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctor_r4p~2~~CalledByGraph proc~bctor_r4p~2 bctor_R4P interface~bcton~2 bcton interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P","tags":"","loc":"proc/bctor_r4p~2.html","title":"bctor_R4P – StringiFor"},{"text":"private elemental function bctoi_I8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i8p~2~~CallsGraph proc~bctoi_i8p~2 bctoi_I8P interface~str~2 str proc~bctoi_i8p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i8p~2~~CalledByGraph proc~bctoi_i8p~2 bctoi_I8P interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P","tags":"","loc":"proc/bctoi_i8p~2.html","title":"bctoi_I8P – StringiFor"},{"text":"private elemental function bctoi_I4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i4p~2~~CallsGraph proc~bctoi_i4p~2 bctoi_I4P interface~str~2 str proc~bctoi_i4p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i4p~2~~CalledByGraph proc~bctoi_i4p~2 bctoi_I4P interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P","tags":"","loc":"proc/bctoi_i4p~2.html","title":"bctoi_I4P – StringiFor"},{"text":"private elemental function bctoi_I2P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i2p~2~~CallsGraph proc~bctoi_i2p~2 bctoi_I2P interface~str~2 str proc~bctoi_i2p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i2p~2~~CalledByGraph proc~bctoi_i2p~2 bctoi_I2P interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P","tags":"","loc":"proc/bctoi_i2p~2.html","title":"bctoi_I2P – StringiFor"},{"text":"private elemental function bctoi_I1P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i1p~2~~CallsGraph proc~bctoi_i1p~2 bctoi_I1P interface~str~2 str proc~bctoi_i1p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i1p~2~~CalledByGraph proc~bctoi_i1p~2 bctoi_I1P interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i1p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P","tags":"","loc":"proc/bctoi_i1p~2.html","title":"bctoi_I1P – StringiFor"},{"text":"public interface str Convert number (real and integer) to string (number to string type casting). Calls interface~~str~2~~CallsGraph interface~str~2 str proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~str~2~~CalledByGraph interface~str~2 str proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string.","tags":"","loc":"interface/str~2.html","title":"str – StringiFor"},{"text":"public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). Calls interface~~strz~2~~CallsGraph interface~strz~2 strz proc~strz_i8p~2 strz_I8P interface~strz~2->proc~strz_i8p~2 proc~strz_i2p~2 strz_I2P interface~strz~2->proc~strz_i2p~2 proc~strz_i1p~2 strz_I1P interface~strz~2->proc~strz_i1p~2 proc~strz_i4p~2 strz_I4P interface~strz~2->proc~strz_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros.","tags":"","loc":"interface/strz~2.html","title":"strz – StringiFor"},{"text":"public interface cton Convert string to number (real and integer, string to number type casting). Calls interface~~cton~2~~CallsGraph interface~cton~2 cton proc~ctor_r4p~2 ctor_R4P interface~cton~2->proc~ctor_r4p~2 proc~ctoi_i1p~2 ctoi_I1P interface~cton~2->proc~ctoi_i1p~2 proc~ctoi_i8p~2 ctoi_I8P interface~cton~2->proc~ctoi_i8p~2 proc~ctoi_i4p~2 ctoi_I4P interface~cton~2->proc~ctoi_i4p~2 proc~ctoi_i2p~2 ctoi_I2P interface~cton~2->proc~ctoi_i2p~2 proc~ctor_r8p~2 ctor_R8P interface~cton~2->proc~ctor_r8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer.","tags":"","loc":"interface/cton~2.html","title":"cton – StringiFor"},{"text":"public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). Calls interface~~bstr~2~~CallsGraph interface~bstr~2 bstr proc~bstr_i8p~2 bstr_I8P interface~bstr~2->proc~bstr_i8p~2 proc~bstr_i4p~2 bstr_I4P interface~bstr~2->proc~bstr_i4p~2 proc~bstr_r4p~2 bstr_R4P interface~bstr~2->proc~bstr_r4p~2 proc~bstr_i2p~2 bstr_I2P interface~bstr~2->proc~bstr_i2p~2 proc~bstr_i1p~2 bstr_I1P interface~bstr~2->proc~bstr_i1p~2 proc~bstr_r8p~2 bstr_R8P interface~bstr~2->proc~bstr_r8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits.","tags":"","loc":"interface/bstr~2.html","title":"bstr – StringiFor"},{"text":"public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). Calls interface~~bcton~2~~CallsGraph interface~bcton~2 bcton proc~bctoi_i8p~2 bctoi_I8P interface~bcton~2->proc~bctoi_i8p~2 proc~bctoi_i4p~2 bctoi_I4P interface~bcton~2->proc~bctoi_i4p~2 proc~bctor_r8p~2 bctor_R8P interface~bcton~2->proc~bctor_r8p~2 proc~bctoi_i2p~2 bctoi_I2P interface~bcton~2->proc~bctoi_i2p~2 proc~bctoi_i1p~2 bctoi_I1P interface~bcton~2->proc~bctoi_i1p~2 proc~bctor_r4p~2 bctor_R4P interface~bcton~2->proc~bctor_r4p~2 interface~str~2 str proc~bctoi_i8p~2->interface~str~2 proc~bctoi_i4p~2->interface~str~2 proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2->interface~str~2 proc~bctoi_i1p~2->interface~str~2 proc~bctor_r4p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer.","tags":"","loc":"interface/bcton~2.html","title":"bcton – StringiFor"},{"text":"private elemental function digit_I8(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i8~2~~CalledByGraph proc~digit_i8~2 digit_I8 interface~digit~2 digit interface~digit~2->proc~digit_i8~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8","tags":"","loc":"proc/digit_i8~2.html","title":"digit_I8 – StringiFor"},{"text":"private elemental function digit_I4(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i4~2~~CalledByGraph proc~digit_i4~2 digit_I4 interface~digit~2 digit interface~digit~2->proc~digit_i4~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4","tags":"","loc":"proc/digit_i4~2.html","title":"digit_I4 – StringiFor"},{"text":"private elemental function digit_I2(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i2~2~~CalledByGraph proc~digit_i2~2 digit_I2 interface~digit~2 digit interface~digit~2->proc~digit_i2~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2","tags":"","loc":"proc/digit_i2~2.html","title":"digit_I2 – StringiFor"},{"text":"private elemental function digit_I1(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i1~2~~CalledByGraph proc~digit_i1~2 digit_I1 interface~digit~2 digit interface~digit~2->proc~digit_i1~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1","tags":"","loc":"proc/digit_i1~2.html","title":"digit_I1 – StringiFor"},{"text":"public subroutine check_endian() Arguments None Description Check the type of bit ordering (big or little endian) of the running architecture. Note The result is stored into the endian global variable. Calls proc~~check_endian~2~~CallsGraph proc~check_endian~2 check_endian none~is_little_endian~2 is_little_endian proc~check_endian~2->none~is_little_endian~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~check_endian~2~~CalledByGraph proc~check_endian~2 check_endian proc~penf_init~2 penf_init proc~penf_init~2->proc~check_endian~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions pure function is_little_endian() result(is_little) Arguments None Return Value logical Logical output: true is the running architecture uses little endian ordering, false otherwise. Description Check if the type of the bit ordering of the running architecture is little endian. Source Code subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian","tags":"","loc":"proc/check_endian~2.html","title":"check_endian – StringiFor"},{"text":"public subroutine penf_init() Arguments None Description Initialize PENF's variables that are not initialized into the definition specification. Calls proc~~penf_init~2~~CallsGraph proc~penf_init~2 penf_init proc~check_endian~2 check_endian proc~penf_init~2->proc~check_endian~2 none~is_little_endian~2 is_little_endian proc~check_endian~2->none~is_little_endian~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init","tags":"","loc":"proc/penf_init~2.html","title":"penf_init – StringiFor"},{"text":"public subroutine penf_print(unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print to the specified unit the PENF's environment data. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. Source Code subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print","tags":"","loc":"proc/penf_print~2.html","title":"penf_print – StringiFor"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables.","tags":"","loc":"interface/bit_size~4.html","title":"bit_size – StringiFor"},{"text":"public interface digit Compute the number of digits in decimal base of the input integer. Calls interface~~digit~2~~CallsGraph interface~digit~2 digit proc~digit_i2~2 digit_I2 interface~digit~2->proc~digit_i2~2 proc~digit_i1~2 digit_I1 interface~digit~2->proc~digit_i1~2 proc~digit_i8~2 digit_I8 interface~digit~2->proc~digit_i8~2 proc~digit_i4~2 digit_I4 interface~digit~2->proc~digit_i4~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer.","tags":"","loc":"interface/digit~2.html","title":"digit – StringiFor"},{"text":"PENF global (exposed) parameters and variables. Note All module defined entities are public. Used By module~~penf_global_parameters_variables~~UsedByGraph module~penf_global_parameters_variables penf_global_parameters_variables module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf~2 penf module~penf_global_parameters_variables->module~penf~2 module~penf penf module~penf_global_parameters_variables->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_stringify~2 penf_stringify module~penf_global_parameters_variables->module~penf_stringify~2 module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify program~test_all test_all module~penf~2->program~test_all module~stringifor stringifor module~penf~2->module~stringifor module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 module~penf_stringify->module~penf program~is_digit is_digit module~stringifor->program~is_digit program~start_end start_end module~stringifor->program~start_end program~is_integer is_integer module~stringifor->program~is_integer program~split split module~stringifor->program~split program~startcase startcase module~stringifor->program~startcase program~is_number is_number module~stringifor->program~is_number program~strim strim module~stringifor->program~strim program~is_real is_real module~stringifor->program~is_real program~sadjustlr sadjustlr module~stringifor->program~sadjustlr program~strip strip module~stringifor->program~strip program~join join module~stringifor->program~join program~sverify sverify module~stringifor->program~sverify program~partition partition module~stringifor->program~partition program~escape escape module~stringifor->program~escape program~swapcase swapcase module~stringifor->program~swapcase program~replace replace module~stringifor->program~replace program~to_number to_number module~stringifor->program~to_number program~reverse reverse module~stringifor->program~reverse program~assignments assignments module~stringifor->program~assignments program~unique unique module~stringifor->program~unique program~camelcase camelcase module~stringifor->program~camelcase program~upper_lower upper_lower module~stringifor->program~upper_lower program~search search module~stringifor->program~search program~capitalize capitalize module~stringifor->program~capitalize program~sindex sindex module~stringifor->program~sindex program~slen slen module~stringifor->program~slen program~snakecase snakecase module~stringifor->program~snakecase program~sscan sscan module~stringifor->program~sscan program~extension extension module~stringifor->program~extension program~fill fill module~stringifor->program~fill program~basename_dir basename_dir module~stringifor->program~basename_dir program~srepeat srepeat module~stringifor->program~srepeat program~free free module~stringifor->program~free program~io_basic io_basic module~stringifor->program~io_basic program~concatenation concatenation module~stringifor->program~concatenation var panmodulepenf_global_parameters_variablesUsedByGraph = svgPanZoom('#modulepenf_global_parameters_variablesUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: is_initialized = .false. Check the initialization of some variables that must be initialized. integer, public, parameter :: endianL = 1 Little endian parameter. integer, public, parameter :: endianB = 0 Big endian parameter. integer, public :: endian = endianL Bit ordering: Little endian (endianL), or Big endian (endianB). integer, public, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, public, parameter :: R8P = selected_real_kind(15, 307) 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision. character(len=*), public, parameter :: FR16P = '(E23.15E3)' Output format for kind=R16P real. character(len=*), public, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P real. character(len=*), public, parameter :: FR4P = '(E13.6E2)' Output format for kind=R4P real. character(len=*), public, parameter :: FR_P = FR8P Output format for kind=R_P real. character(len=*), public, parameter :: FI8P = '(I20)' Output format for kind=I8P integer. character(len=*), public, parameter :: FI8PZP = '(I20.19)' Output format for kind=I8P integer with zero prefixing. character(len=*), public, parameter :: FI4P = '(I11)' Output format for kind=I4P integer. character(len=*), public, parameter :: FI4PZP = '(I11.10)' Output format for kind=I4P integer with zero prefixing. character(len=*), public, parameter :: FI2P = '(I6)' Output format for kind=I2P integer. character(len=*), public, parameter :: FI2PZP = '(I6.5)' Output format for kind=I2P integer with zero prefixing. character(len=*), public, parameter :: FI1P = '(I4)' Output format for kind=I1P integer. character(len=*), public, parameter :: FI1PZP = '(I4.3)' Output format for kind=I1P integer with zero prefixing. character(len=*), public, parameter :: FI_P = FI4P Output format for kind=I_P integer. character(len=*), public, parameter :: FI_PZP = FI4PZP Output format for kind=I_P integer with zero prefixing. integer, public, parameter :: DR16P = 23 Number of digits of output format FR16P. integer, public, parameter :: DR8P = 23 Number of digits of output format FR8P. integer, public, parameter :: DR4P = 13 Number of digits of output format FR4P. integer, public, parameter :: DR_P = DR8P Number of digits of output format FR_P. integer, public, parameter :: DI8P = 20 Number of digits of output format I8P. integer, public, parameter :: DI4P = 11 Number of digits of output format I4P. integer, public, parameter :: DI2P = 6 Number of digits of output format I2P. integer, public, parameter :: DI1P = 4 Number of digits of output format I1P. integer, public, parameter :: DI_P = DI4P Number of digits of output format I_P. integer, public, parameter :: REAL_KINDS_LIST (1:4) = [R16P, R8P, R4P, R_P] List of real kinds. character(len=*), public, parameter :: REAL_FORMATS_LIST (1:4) = [FR16P, FR8P, FR4P//' ', FR_P] List of real formats. integer, public, parameter :: INTEGER_KINDS_LIST (1:5) = [I8P, I4P, I2P, I1P, I_P] List of integer kinds. character(len=*), public, parameter :: INTEGER_FORMATS_LIST (1:5) = [FI8P, FI4P, FI2P//' ', FI1P//' ', FI_P] List of integer formats. real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) Minimum value of kind=R16P real. real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) Maximum value of kind=R16P real. real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) Minimum value of kind=R8P real. real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) Maximum value of kind=R8P real. real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) Minimum value of kind=R4P real. real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) Maximum value of kind=R4P real. real(kind=R_P), public, parameter :: MinR_P = MinR8P Minimum value of kind=R_P real. real(kind=R_P), public, parameter :: MaxR_P = MaxR8P Maximum value of kind=R_P real. integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) Minimum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) Minimum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) Minimum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) Minimum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MinI_P = MinI4P Minimum value of kind=I_P integer. integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) Maximum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) Maximum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) Maximum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) Maximum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MaxI_P = MaxI4P Maximum value of kind=I_P integer. real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) Smallest representable value of kind=R16P real. real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) Smallest representable value of kind=R8P real. real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) Smallest representable value of kind=R4P real. real(kind=R_P), public, parameter :: smallR_P = smallR8P Smallest representable value of kind=R_P real. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P, 1._R16P)-nearest(1._R16P, -1._R16P) Smallest representable difference of kind=R16P real. real(kind=R8P), public, parameter :: ZeroR8 = nearest(1._R8P, 1._R8P)-nearest(1._R8P, -1._R8P) Smallest representable difference of kind=R8P real. real(kind=R4P), public, parameter :: ZeroR4 = nearest(1._R4P, 1._R4P)-nearest(1._R4P, -1._R4P) Smallest representable difference of kind=R4P real. real(kind=R_P), public, parameter :: Zero = ZeroR8 Smallest representable difference of kind=R_P real. integer(kind=I2P), public :: BIR16P Number of bits of kind=R16P real. integer(kind=I1P), public :: BIR8P Number of bits of kind=R8P real. integer(kind=I1P), public :: BIR4P Number of bits of kind=R4P real. integer(kind=I1P), public :: BIR_P Number of bits of kind=R_P real. integer(kind=I2P), public :: BYR16P Number of bytes of kind=R16P real. integer(kind=I1P), public :: BYR8P Number of bytes of kind=R8P real. integer(kind=I1P), public :: BYR4P Number of bytes of kind=R4P real. integer(kind=I1P), public :: BYR_P Number of bytes of kind=R_P real. integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) Number of bits of kind=I8P integer. integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) Number of bits of kind=I4P integer. integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) Number of bits of kind=I2P integer. integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) Number of bits of kind=I1P integer. integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) Number of bits of kind=I_P integer. integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P Number of bytes of kind=I8P integer. integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P Number of bytes of kind=I4P integer. integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P Number of bytes of kind=I2P integer. integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P Number of bytes of kind=I1P integer. integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P Number of bytes of kind=I_P integer.","tags":"","loc":"module/penf_global_parameters_variables.html","title":"penf_global_parameters_variables – StringiFor"},{"text":"Uses: penf_global_parameters_variables module~~penf_b_size~2~~UsesGraph module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_b_size~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF bit/byte size functions. Used By module~~penf_b_size~2~~UsedByGraph module~penf_b_size~2 penf_b_size module~penf~2 penf module~penf_b_size~2->module~penf~2 module~penf penf module~penf_b_size~2->module~penf module~penf_stringify penf_stringify module~penf_b_size~2->module~penf_stringify module~penf_stringify~2 penf_stringify module~penf_b_size~2->module~penf_stringify~2 program~test_all test_all module~penf~2->program~test_all module~stringifor stringifor module~penf~2->module~stringifor module~penf_stringify->module~penf~2 module~penf_stringify->module~penf program~is_digit is_digit module~stringifor->program~is_digit program~start_end start_end module~stringifor->program~start_end program~is_integer is_integer module~stringifor->program~is_integer program~split split module~stringifor->program~split program~startcase startcase module~stringifor->program~startcase program~is_number is_number module~stringifor->program~is_number program~strim strim module~stringifor->program~strim program~is_real is_real module~stringifor->program~is_real program~sadjustlr sadjustlr module~stringifor->program~sadjustlr program~strip strip module~stringifor->program~strip program~join join module~stringifor->program~join program~sverify sverify module~stringifor->program~sverify program~partition partition module~stringifor->program~partition program~escape escape module~stringifor->program~escape program~swapcase swapcase module~stringifor->program~swapcase program~replace replace module~stringifor->program~replace program~to_number to_number module~stringifor->program~to_number program~reverse reverse module~stringifor->program~reverse program~assignments assignments module~stringifor->program~assignments program~unique unique module~stringifor->program~unique program~camelcase camelcase module~stringifor->program~camelcase program~upper_lower upper_lower module~stringifor->program~upper_lower program~search search module~stringifor->program~search program~capitalize capitalize module~stringifor->program~capitalize program~sindex sindex module~stringifor->program~sindex program~slen slen module~stringifor->program~slen program~snakecase snakecase module~stringifor->program~snakecase program~sscan sscan module~stringifor->program~sscan program~extension extension module~stringifor->program~extension program~fill fill module~stringifor->program~fill program~basename_dir basename_dir module~stringifor->program~basename_dir program~srepeat srepeat module~stringifor->program~srepeat program~free free module~stringifor->program~free program~io_basic io_basic module~stringifor->program~io_basic program~concatenation concatenation module~stringifor->program~concatenation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. public interface byte_size Compute the number of bytes of a variable. private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable. Functions private elemental function bit_size_R16P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R16P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable.","tags":"","loc":"module/penf_b_size~2.html","title":"penf_b_size – StringiFor"},{"text":"Uses: iso_fortran_env penf_b_size penf_global_parameters_variables module~~penf_stringify~~UsesGraph module~penf_stringify penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~penf_b_size~2->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF string-to-number (and viceversa) facility. Used By module~~penf_stringify~~UsedByGraph module~penf_stringify penf_stringify module~penf~2 penf module~penf_stringify->module~penf~2 module~penf penf module~penf_stringify->module~penf program~test_all test_all module~penf~2->program~test_all module~stringifor stringifor module~penf~2->module~stringifor program~is_digit is_digit module~stringifor->program~is_digit program~start_end start_end module~stringifor->program~start_end program~is_integer is_integer module~stringifor->program~is_integer program~split split module~stringifor->program~split program~startcase startcase module~stringifor->program~startcase program~is_number is_number module~stringifor->program~is_number program~strim strim module~stringifor->program~strim program~is_real is_real module~stringifor->program~is_real program~sadjustlr sadjustlr module~stringifor->program~sadjustlr program~strip strip module~stringifor->program~strip program~join join module~stringifor->program~join program~sverify sverify module~stringifor->program~sverify program~partition partition module~stringifor->program~partition program~escape escape module~stringifor->program~escape program~swapcase swapcase module~stringifor->program~swapcase program~replace replace module~stringifor->program~replace program~to_number to_number module~stringifor->program~to_number program~reverse reverse module~stringifor->program~reverse program~assignments assignments module~stringifor->program~assignments program~unique unique module~stringifor->program~unique program~camelcase camelcase module~stringifor->program~camelcase program~upper_lower upper_lower module~stringifor->program~upper_lower program~search search module~stringifor->program~search program~capitalize capitalize module~stringifor->program~capitalize program~sindex sindex module~stringifor->program~sindex program~slen slen module~stringifor->program~slen program~snakecase snakecase module~stringifor->program~snakecase program~sscan sscan module~stringifor->program~sscan program~extension extension module~stringifor->program~extension program~fill fill module~stringifor->program~fill program~basename_dir basename_dir module~stringifor->program~basename_dir program~srepeat srepeat module~stringifor->program~srepeat program~free free module~stringifor->program~free program~io_basic io_basic module~stringifor->program~io_basic program~concatenation concatenation module~stringifor->program~concatenation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface str Convert number (real and integer) to string (number to string type casting). private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. public interface cton Convert string to number (real and integer, string to number type casting). private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer. Functions private elemental function strf_R16P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_R16P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R16P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Converting real array to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private function ctor_R16P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Description Convert string to real. private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. private elemental function bstr_R16P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bctor_R16P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Convert bit-string to real. private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer.","tags":"","loc":"module/penf_stringify.html","title":"penf_stringify – StringiFor"},{"text":"Uses: penf_global_parameters_variables penf_b_size penf_stringify module~~penf~2~~UsesGraph module~penf~2 penf module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Portability Environment for Fortran poor people. PENF PENF, Portability Environment for Fortran poor people A KISS library for exploiting codes portability for modern (2003+) Fortran projects. PENF is a pure Fortran (KISS) library for achieving portable codes for modern Fortran projects; PENF provides many number-to-string and viceversa facilities; PENF is Fortran 2003+ standard compliant; PENF is a Free, Open Source Project. Table of Contents What is PENF? Main features Copyrights Documentation A Taste of PENF Issues Compiler Support What is PENF? Fortran is the most popular programming language for scientific computing. With Fortran it is quite simple obtain fast code and manage large multidimensional array. Because Fortran permits the achievement of high performance it is also used on great range of different computer-architectures, and often on the fastest supercomputer in the world. Therefore Fortran programs must be portable : portability means that the code will give the same results on every different computer-architectures. One of the most important goal of the numeric code is to control the numeric error due to finite precision of numerical operations. Fortran uses the IEEE representations. Integers and reals (floating point) are represented with a finite precision. So when the code computes an operation it has a truncation error due to the truncation of the numerical finite representations. For numerical and more in general scientific applications this source of errors must be controlled. The programmer must know which is the precision associated to the code variables. Before the standard Fortran 90/95 there are not any way to select the precision of the numerical variables in a portable fashion. Modern Fortran standards (2003+) have introduced better support for codes portability. With the possibility to specify a kind parameter for variables, the standard Fortran 90+ makes available useful functions to select the kind precision in a portable parametric way. Using these functions the programmer can accurately control the precision of its own variables in a portable manner. PENF module provides an effective KISS library to achieve portability and concurrently it provides many tools to handles parametrized numbers. Go to Top Main features The library provides portable kind-parameters and many useful procedures to deal with them: integer and reals parameters for 1,2,4,8,16 bytes-like representations; integer and real formats definitions for all parameters; integer and real minimum maximum representable numbers; number-to-string and string-to-number casting procedures; endianism procedures checking. Any feature request is welcome. Go to Top Copyrights PENF is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to PENF is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the PENF documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of PENF To be written. Go to Top Used By module~~penf~2~~UsedByGraph module~penf~2 penf program~test_all test_all module~penf~2->program~test_all module~stringifor stringifor module~penf~2->module~stringifor program~is_digit is_digit module~stringifor->program~is_digit program~start_end start_end module~stringifor->program~start_end program~is_integer is_integer module~stringifor->program~is_integer program~split split module~stringifor->program~split program~startcase startcase module~stringifor->program~startcase program~is_number is_number module~stringifor->program~is_number program~strim strim module~stringifor->program~strim program~is_real is_real module~stringifor->program~is_real program~sadjustlr sadjustlr module~stringifor->program~sadjustlr program~strip strip module~stringifor->program~strip program~join join module~stringifor->program~join program~sverify sverify module~stringifor->program~sverify program~partition partition module~stringifor->program~partition program~escape escape module~stringifor->program~escape program~swapcase swapcase module~stringifor->program~swapcase program~replace replace module~stringifor->program~replace program~to_number to_number module~stringifor->program~to_number program~reverse reverse module~stringifor->program~reverse program~assignments assignments module~stringifor->program~assignments program~unique unique module~stringifor->program~unique program~camelcase camelcase module~stringifor->program~camelcase program~upper_lower upper_lower module~stringifor->program~upper_lower program~search search module~stringifor->program~search program~capitalize capitalize module~stringifor->program~capitalize program~sindex sindex module~stringifor->program~sindex program~slen slen module~stringifor->program~slen program~snakecase snakecase module~stringifor->program~snakecase program~sscan sscan module~stringifor->program~sscan program~extension extension module~stringifor->program~extension program~fill fill module~stringifor->program~fill program~basename_dir basename_dir module~stringifor->program~basename_dir program~srepeat srepeat module~stringifor->program~srepeat program~free free module~stringifor->program~free program~io_basic io_basic module~stringifor->program~io_basic program~concatenation concatenation module~stringifor->program~concatenation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. public interface digit Compute the number of digits in decimal base of the input integer. private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Functions private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Subroutines public subroutine check_endian () Arguments None Description Check the type of bit ordering (big or little endian) of the running architecture. public subroutine penf_init () Arguments None Description Initialize PENF's variables that are not initialized into the definition specification. public subroutine penf_print (unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print to the specified unit the PENF's environment data.","tags":"","loc":"module/penf~2.html","title":"penf – StringiFor"},{"text":"Uses: penf module~~stringifor~~UsesGraph module~stringifor stringifor module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor, Strings Fortran, yet another stringify Fortran module Used By module~~stringifor~~UsedByGraph module~stringifor stringifor program~is_digit is_digit module~stringifor->program~is_digit program~start_end start_end module~stringifor->program~start_end program~is_integer is_integer module~stringifor->program~is_integer program~split split module~stringifor->program~split program~startcase startcase module~stringifor->program~startcase program~is_number is_number module~stringifor->program~is_number program~strim strim module~stringifor->program~strim program~is_real is_real module~stringifor->program~is_real program~sadjustlr sadjustlr module~stringifor->program~sadjustlr program~strip strip module~stringifor->program~strip program~join join module~stringifor->program~join program~sverify sverify module~stringifor->program~sverify program~partition partition module~stringifor->program~partition program~escape escape module~stringifor->program~escape program~swapcase swapcase module~stringifor->program~swapcase program~replace replace module~stringifor->program~replace program~to_number to_number module~stringifor->program~to_number program~reverse reverse module~stringifor->program~reverse program~assignments assignments module~stringifor->program~assignments program~unique unique module~stringifor->program~unique program~camelcase camelcase module~stringifor->program~camelcase program~upper_lower upper_lower module~stringifor->program~upper_lower program~search search module~stringifor->program~search program~capitalize capitalize module~stringifor->program~capitalize program~sindex sindex module~stringifor->program~sindex program~slen slen module~stringifor->program~slen program~snakecase snakecase module~stringifor->program~snakecase program~sscan sscan module~stringifor->program~sscan program~extension extension module~stringifor->program~extension program~fill fill module~stringifor->program~fill program~basename_dir basename_dir module~stringifor->program~basename_dir program~srepeat srepeat module~stringifor->program~srepeat program~free free module~stringifor->program~free program~io_basic io_basic module~stringifor->program~io_basic program~concatenation concatenation module~stringifor->program~concatenation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: CK = selected_char_kind('DEFAULT') Default character kind. character(kind=CK,len=26), private, parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' Upper case alphabet. character(kind=CK,len=26), private, parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' Lower case alphabet. character(kind=CK,len=1), private, parameter :: SPACE = ' ' Space character. character(kind=CK,len=1), private, parameter :: TAB = achar(9) Tab character. character(kind=CK,len=1), private, parameter :: UIX_DIR_SEP = char(47) Unix/Linux directories separator (/). character(kind=CK,len=1), private, parameter :: BACKSLASH = char(92) Backslash character. Derived Types type, public :: string Components Type Visibility Attributes Name Initial character(kind=CK,len=:), private, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: basedir Return the base directory name of a string containing a file name. procedure, public, pass(self) :: basename Return the base file name of a string containing a file name. procedure, public, pass(self) :: camelcase Return a string with all words capitalized without spaces. procedure, public, pass(self) :: capitalize Return a string with its first character capitalized and the rest lowercased. procedure, public, pass(self) :: chars Return the raw characters data. procedure, public, pass(self) :: escape Escape backslashes (or custom escape character). procedure, public, pass(self) :: extension Return the extension of a string containing a file name. procedure, public, pass(self) :: fill Pad string on the left (or right) with zeros (or other char) to fill width. procedure, public, pass(self) :: free Free dynamic memory. generic, public :: join => join_strings, join_characters Return a string that is a join of an array of strings or characters. procedure, public, pass(self) :: lower Return a string with all lowercase characters. procedure, public, pass(self) :: partition Split string at separator and return the 3 parts (before, the separator and after). procedure, public, pass(self) :: replace Return a string with all occurrences of substring old replaced by new. procedure, public, pass(self) :: reverse Return a reversed string. procedure, public, pass(self) :: search Search for tagged record into string. procedure, public, pass(self) :: snakecase Return a string with all words lowercase separated by \"_\". procedure, public, pass(self) :: split Return a list of substring in the string, using sep as the delimiter string. procedure, public, pass(self) :: startcase Return a string with all words capitalized, e.g. title case. procedure, public, pass(self) :: strip Return a string with the leading and trailing characters removed. procedure, public, pass(self) :: swapcase Return a string with uppercase chars converted to lowercase and vice versa. generic, public :: to_number => to_integer_I1P, to_integer_I2P, to_integer_I4P, to_integer_I8P, to_real_R4P, to_real_R8P Cast string to number. procedure, public, pass(self) :: unique Reduce to one (unique) multiple occurrences of a substring into a string. procedure, public, pass(self) :: upper Return a string with all uppercase characters. procedure, public, pass(self) :: end_with Return true if a string ends with a specified suffix. procedure, public, pass(self) :: is_allocated Return true if the string is allocated. procedure, public, pass(self) :: is_digit Return true if all characters in the string are digits. procedure, public, pass(self) :: is_integer Return true if the string contains an integer. procedure, public, pass(self) :: is_lower Return true if all characters in the string are lowercase. procedure, public, pass(self) :: is_number Return true if the string contains a number (real or integer). procedure, public, pass(self) :: is_real Return true if the string contains an real. procedure, public, pass(self) :: is_upper Return true if all characters in the string are uppercase. procedure, public, pass(self) :: start_with Return true if a string starts with a specified prefix. generic, public :: assignment(=) => string_assign_string, string_assign_character, string_assign_integer_I1P, string_assign_integer_I2P, string_assign_integer_I4P, string_assign_integer_I8P, string_assign_real_R4P, string_assign_real_R8P Assignment operator overloading. generic, public :: operator(//) => string_concat_string, string_concat_character, character_concat_string Concatenation operator overloading. generic, public :: operator(.cat.) => string_concat_string_string, string_concat_character_string, character_concat_string_string Concatenation operator (string output) overloading. procedure, public, pass(self) :: sadjustl Adjustl replacement. procedure, public, pass(self) :: sadjustr Adjustr replacement. procedure, public, pass(self) :: scount Count replacement. procedure, public, pass(self) :: sindex Index replacement. procedure, public, pass(self) :: slen Len replacement. procedure, public, pass(self) :: slen_trim Len_trim replacement. procedure, public, nopass :: srepeat Repeat replacement. procedure, public, pass(self) :: sscan Scan replacement. procedure, public, pass(self) :: strim Trim replacement. procedure, public, pass(self) :: sverify Verify replacement. procedure, public, pass(dtv) :: read_formatted => read_formatted_ Formatted input. procedure, public, pass(dtv) :: read_formatted_internal Formatted input from internal. procedure, public, pass(dtv) :: write_formatted => write_formatted_ Formatted output. procedure, public, pass(dtv) :: write_formatted_internal Formatted output to internal. procedure, private, pass(lhs) :: string_assign_string Assignment operator from string input. procedure, private, pass(lhs) :: string_assign_character Assignment operator from character input. procedure, private, pass(lhs) :: string_assign_integer_I1P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I2P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I4P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I8P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_real_R4P Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R8P Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R16P Assignment operator from real input. procedure, private, pass(lhs) :: string_concat_string Concatenation with string. procedure, private, pass(lhs) :: string_concat_character Concatenation with character. procedure, private, pass(rhs) :: character_concat_string Concatenation with character (inverted). procedure, private, pass(lhs) :: string_concat_string_string Concatenation with string (string output). procedure, private, pass(lhs) :: string_concat_character_string Concatenation with character (string output). procedure, private, pass(rhs) :: character_concat_string_string Concatenation with character (inverted, string output). procedure, private, pass(dtv) :: read_formatted_ Formatted input. procedure, private, pass(dtv) :: write_formatted_ Formatted output. procedure, private, pass(dtv) :: read_unformatted_ Unformatted input. procedure, private, pass(dtv) :: write_unformatted_ Unformatted output. procedure, private, pass(self) :: replace_one_occurrence Replace the first occurrence of substring old by new. procedure, private, pass(self) :: join_strings Return join string of an array of strings. procedure, private, pass(self) :: join_characters Return join string of an array of characters. procedure, private, pass(self) :: to_integer_I1P Cast string to integer. procedure, private, pass(self) :: to_integer_I2P Cast string to integer. procedure, private, pass(self) :: to_integer_I4P Cast string to integer. procedure, private, pass(self) :: to_integer_I8P Cast string to integer. procedure, private, pass(self) :: to_real_R4P Cast string to real. procedure, private, pass(self) :: to_real_R8P Cast string to real. procedure, private, pass(self) :: to_real_R16P Cast string to real. Description OOP designed string class. Functions private elemental function basedir (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. Description Return the base directory name of a string containing a file name. private elemental function basename (self, sep, extension, strip_last_extension) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. character(kind=CK,len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. Description Return the base file name of a string containing a file name. private elemental function camelcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. Description Return a string with all words capitalized without spaces. private elemental function capitalize (self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with its first character capitalized and the rest lowercased. private pure function chars (self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data. private elemental function escape (self, to_escape, esc) result(escaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK,len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. Description Escape backslashes (or custom escape character). private elemental function extension (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. Description Return the extension of a string containing a file name. private elemental function fill (self, width, right, filling_char) result(filled) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK,len=1), intent(in), optional :: filling_char Filling character (default \"0\"). Return Value type( string ) Filled string. Description Pad string on the left (or right) with zeros (or other char) to fill width. private elemental function lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all lowercase characters. private pure function partition (self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )\n  (1:3) after the separator. Description Split string at separator and return the 3 parts (before, the separator and after). private elemental function replace (self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Description Return a string with all occurrences of substring old replaced by new. private elemental function reverse (self) result(reversed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. Description Return a reversed string. private elemental function snakecase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. Description Return a string with all words lowercase separated by \"_\". private function search (self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: tag_start Start tag. character(kind=CK,len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK,len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. Description Search for tagged record into string, return the first record found (if any) matching the tags. private elemental function startcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. Description Return a string with all words capitalized, e.g. title case. private elemental function strip (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The stripped string. Description Return a copy of the string with the leading and trailing characters removed. private elemental function swapcase (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a copy of the string with uppercase characters converted to lowercase and vice versa. private elemental function unique (self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Description Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. private elemental function upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all uppercase characters. private elemental function end_with (self, suffix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string ends with a specified suffix. private elemental function is_allocated (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if the string is allocated. private elemental function is_digit (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are digits. private elemental function is_integer (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains an integer. private elemental function is_lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are lowercase. private elemental function is_number (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a number (real or integer). private elemental function is_real (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a real. private elemental function is_upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are uppercase. private elemental function start_with (self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string starts with a specified prefix. private elemental function sadjustl (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. private elemental function sadjustr (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. private elemental function scount (self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore \"isolated\" occurrences. Return Value integer Number of occurrences. Description Count the number of occurences of a substring into a string. private elemental function sindex (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. private elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. private elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer <\np S\nt\nr\ni\nn\ng l\ne\nn\ng\nt\nh\n.\n<\n/\np Description Return the length of a string, ignoring any trailing blanks. private elemental function srepeat (rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. private elemental function sscan (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . private elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. private elemental function sverify (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). private elemental function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. private elemental function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. private elemental function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). private elemental function replace_one_occurrence (self, old, new) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Description Return a string with the first occurrence of substring old replaced by new. private pure function join_strings (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. private pure function join_characters (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. private elemental function to_integer_I1P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). private elemental function to_integer_I2P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). private elemental function to_integer_I4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). private elemental function to_integer_I8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). private elemental function to_real_R4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). private elemental function to_real_R8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). private elemental function to_real_R16P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. Description Cast string to real (R16P). Subroutines private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Description Free dynamic memory. private pure subroutine split (self, tokens, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. Description Return a list of substring in the string, using sep as the delimiter string. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. private elemental subroutine string_assign_integer_I1P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I2P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R16P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private subroutine read_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted input. private subroutine read_formatted_internal (dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. character(kind=CK,len=*), intent(in) :: iunit Internal unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted input from internal. private subroutine write_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. private subroutine write_formatted_internal (dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. character(kind=CK,len=*), intent(inout) :: iunit Interanl unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output to internal. private subroutine read_unformatted_ (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. private subroutine write_unformatted_ (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output.","tags":"","loc":"module/stringifor.html","title":"stringifor – StringiFor"},{"text":"PENF global (exposed) parameters and variables. Note All module defined entities are public. Variables Type Visibility Attributes Name Initial logical, public :: is_initialized = .false. Check the initialization of some variables that must be initialized. integer, public, parameter :: endianL = 1 Little endian parameter. integer, public, parameter :: endianB = 0 Big endian parameter. integer, public :: endian = endianL Bit ordering: Little endian (endianL), or Big endian (endianB). integer, public, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, public, parameter :: R8P = selected_real_kind(15, 307) 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision. character(len=*), public, parameter :: FR16P = '(E23.15E3)' Output format for kind=R16P real. character(len=*), public, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P real. character(len=*), public, parameter :: FR4P = '(E13.6E2)' Output format for kind=R4P real. character(len=*), public, parameter :: FR_P = FR8P Output format for kind=R_P real. character(len=*), public, parameter :: FI8P = '(I20)' Output format for kind=I8P integer. character(len=*), public, parameter :: FI8PZP = '(I20.19)' Output format for kind=I8P integer with zero prefixing. character(len=*), public, parameter :: FI4P = '(I11)' Output format for kind=I4P integer. character(len=*), public, parameter :: FI4PZP = '(I11.10)' Output format for kind=I4P integer with zero prefixing. character(len=*), public, parameter :: FI2P = '(I6)' Output format for kind=I2P integer. character(len=*), public, parameter :: FI2PZP = '(I6.5)' Output format for kind=I2P integer with zero prefixing. character(len=*), public, parameter :: FI1P = '(I4)' Output format for kind=I1P integer. character(len=*), public, parameter :: FI1PZP = '(I4.3)' Output format for kind=I1P integer with zero prefixing. character(len=*), public, parameter :: FI_P = FI4P Output format for kind=I_P integer. character(len=*), public, parameter :: FI_PZP = FI4PZP Output format for kind=I_P integer with zero prefixing. integer, public, parameter :: DR16P = 23 Number of digits of output format FR16P. integer, public, parameter :: DR8P = 23 Number of digits of output format FR8P. integer, public, parameter :: DR4P = 13 Number of digits of output format FR4P. integer, public, parameter :: DR_P = DR8P Number of digits of output format FR_P. integer, public, parameter :: DI8P = 20 Number of digits of output format I8P. integer, public, parameter :: DI4P = 11 Number of digits of output format I4P. integer, public, parameter :: DI2P = 6 Number of digits of output format I2P. integer, public, parameter :: DI1P = 4 Number of digits of output format I1P. integer, public, parameter :: DI_P = DI4P Number of digits of output format I_P. integer, public, parameter :: REAL_KINDS_LIST (1:4) = [R16P, R8P, R4P, R_P] List of real kinds. character(len=*), public, parameter :: REAL_FORMATS_LIST (1:4) = [FR16P, FR8P, FR4P//' ', FR_P] List of real formats. integer, public, parameter :: INTEGER_KINDS_LIST (1:5) = [I8P, I4P, I2P, I1P, I_P] List of integer kinds. character(len=*), public, parameter :: INTEGER_FORMATS_LIST (1:5) = [FI8P, FI4P, FI2P//' ', FI1P//' ', FI_P] List of integer formats. real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) Minimum value of kind=R16P real. real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) Maximum value of kind=R16P real. real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) Minimum value of kind=R8P real. real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) Maximum value of kind=R8P real. real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) Minimum value of kind=R4P real. real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) Maximum value of kind=R4P real. real(kind=R_P), public, parameter :: MinR_P = MinR8P Minimum value of kind=R_P real. real(kind=R_P), public, parameter :: MaxR_P = MaxR8P Maximum value of kind=R_P real. integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) Minimum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) Minimum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) Minimum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) Minimum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MinI_P = MinI4P Minimum value of kind=I_P integer. integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) Maximum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) Maximum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) Maximum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) Maximum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MaxI_P = MaxI4P Maximum value of kind=I_P integer. real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) Smallest representable value of kind=R16P real. real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) Smallest representable value of kind=R8P real. real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) Smallest representable value of kind=R4P real. real(kind=R_P), public, parameter :: smallR_P = smallR8P Smallest representable value of kind=R_P real. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P, 1._R16P)-nearest(1._R16P, -1._R16P) Smallest representable difference of kind=R16P real. real(kind=R8P), public, parameter :: ZeroR8 = nearest(1._R8P, 1._R8P)-nearest(1._R8P, -1._R8P) Smallest representable difference of kind=R8P real. real(kind=R4P), public, parameter :: ZeroR4 = nearest(1._R4P, 1._R4P)-nearest(1._R4P, -1._R4P) Smallest representable difference of kind=R4P real. real(kind=R_P), public, parameter :: Zero = ZeroR8 Smallest representable difference of kind=R_P real. integer(kind=I2P), public :: BIR16P Number of bits of kind=R16P real. integer(kind=I1P), public :: BIR8P Number of bits of kind=R8P real. integer(kind=I1P), public :: BIR4P Number of bits of kind=R4P real. integer(kind=I1P), public :: BIR_P Number of bits of kind=R_P real. integer(kind=I2P), public :: BYR16P Number of bytes of kind=R16P real. integer(kind=I1P), public :: BYR8P Number of bytes of kind=R8P real. integer(kind=I1P), public :: BYR4P Number of bytes of kind=R4P real. integer(kind=I1P), public :: BYR_P Number of bytes of kind=R_P real. integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) Number of bits of kind=I8P integer. integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) Number of bits of kind=I4P integer. integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) Number of bits of kind=I2P integer. integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) Number of bits of kind=I1P integer. integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) Number of bits of kind=I_P integer. integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P Number of bytes of kind=I8P integer. integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P Number of bytes of kind=I4P integer. integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P Number of bytes of kind=I2P integer. integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P Number of bytes of kind=I1P integer. integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P Number of bytes of kind=I_P integer.","tags":"","loc":"module/penf_global_parameters_variables~2.html","title":"penf_global_parameters_variables – StringiFor"},{"text":"Uses: penf_global_parameters_variables module~~penf_b_size~~UsesGraph module~penf_b_size penf_b_size module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_b_size Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF bit/byte size functions. Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. public interface byte_size Compute the number of bytes of a variable. private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable. Functions private elemental function bit_size_R16P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R16P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable.","tags":"","loc":"module/penf_b_size.html","title":"penf_b_size – StringiFor"},{"text":"Uses: iso_fortran_env penf_b_size penf_global_parameters_variables module~~penf_stringify~2~~UsesGraph module~penf_stringify~2 penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_stringify~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify~2 module~penf_b_size~2->module~penf_stringify~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF string-to-number (and viceversa) facility. Interfaces public interface str Convert number (real and integer) to string (number to string type casting). private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. public interface cton Convert string to number (real and integer, string to number type casting). private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer. Functions private elemental function strf_R16P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_R16P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R16P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Converting real array to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private function ctor_R16P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Description Convert string to real. private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. private elemental function bstr_R16P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bctor_R16P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Convert bit-string to real. private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer.","tags":"","loc":"module/penf_stringify~2.html","title":"penf_stringify – StringiFor"},{"text":"Uses: penf_global_parameters_variables penf_b_size penf_stringify module~~penf~~UsesGraph module~penf penf module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Portability Environment for Fortran poor people. PENF PENF, Portability Environment for Fortran poor people A KISS library for exploiting codes portability for modern (2003+) Fortran projects. PENF is a pure Fortran (KISS) library for achieving portable codes for modern Fortran projects; PENF provides many number-to-string and viceversa facilities; PENF is Fortran 2003+ standard compliant; PENF is a Free, Open Source Project. Table of Contents What is PENF? Main features Copyrights Documentation A Taste of PENF Issues Compiler Support What is PENF? Fortran is the most popular programming language for scientific computing. With Fortran it is quite simple obtain fast code and manage large multidimensional array. Because Fortran permits the achievement of high performance it is also used on great range of different computer-architectures, and often on the fastest supercomputer in the world. Therefore Fortran programs must be portable : portability means that the code will give the same results on every different computer-architectures. One of the most important goal of the numeric code is to control the numeric error due to finite precision of numerical operations. Fortran uses the IEEE representations. Integers and reals (floating point) are represented with a finite precision. So when the code computes an operation it has a truncation error due to the truncation of the numerical finite representations. For numerical and more in general scientific applications this source of errors must be controlled. The programmer must know which is the precision associated to the code variables. Before the standard Fortran 90/95 there are not any way to select the precision of the numerical variables in a portable fashion. Modern Fortran standards (2003+) have introduced better support for codes portability. With the possibility to specify a kind parameter for variables, the standard Fortran 90+ makes available useful functions to select the kind precision in a portable parametric way. Using these functions the programmer can accurately control the precision of its own variables in a portable manner. PENF module provides an effective KISS library to achieve portability and concurrently it provides many tools to handles parametrized numbers. Go to Top Main features The library provides portable kind-parameters and many useful procedures to deal with them: integer and reals parameters for 1,2,4,8,16 bytes-like representations; integer and real formats definitions for all parameters; integer and real minimum maximum representable numbers; number-to-string and string-to-number casting procedures; endianism procedures checking. Any feature request is welcome. Go to Top Copyrights PENF is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to PENF is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the PENF documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of PENF To be written. Go to Top Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. public interface digit Compute the number of digits in decimal base of the input integer. private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Functions private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Subroutines public subroutine check_endian () Arguments None Description Check the type of bit ordering (big or little endian) of the running architecture. public subroutine penf_init () Arguments None Description Initialize PENF's variables that are not initialized into the definition specification. public subroutine penf_print (unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print to the specified unit the PENF's environment data.","tags":"","loc":"module/penf.html","title":"penf – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~assignments~~UsesGraph program~assignments assignments iso_fortran_env iso_fortran_env iso_fortran_env->program~assignments module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~assignments module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramassignmentsUsesGraph = svgPanZoom('#programassignmentsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor assignments test. Variables Type Attributes Name Initial type( string ) :: astring A string. integer(kind=I1P) :: ainteger_I1P A integer (I1P). integer(kind=I2P) :: ainteger_I2P A integer (I2P). integer(kind=I4P) :: ainteger_I4P A integer (I4P). integer(kind=I8P) :: ainteger_I8P A integer (I8P). real(kind=R4P) :: areal_R4P A real (R4P). real(kind=R8P) :: areal_R8P A real (R8P). real(kind=R16P) :: areal_R16P A real (R16P). logical :: test_passed (7) List of passed tests. Source Code program assignments !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `assignments` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string , I1P , I2P , I4P , I8P , R4P , R8P , R16P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. integer ( I1P ) :: ainteger_I1P !< A integer (I1P). integer ( I2P ) :: ainteger_I2P !< A integer (I2P). integer ( I4P ) :: ainteger_I4P !< A integer (I4P). integer ( I8P ) :: ainteger_I8P !< A integer (I8P). real ( R4P ) :: areal_R4P !< A real (R4P). real ( R8P ) :: areal_R8P !< A real (R8P). real ( R16P ) :: areal_R16P !< A real (R16P). logical :: test_passed ( 7 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . ainteger_I1P = 127_I1P astring = ainteger_I1P test_passed ( 1 ) = astring // '' == '+127' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 1 ) ainteger_I2P = 32767_I2P astring = ainteger_I2P test_passed ( 2 ) = astring // '' == '+32767' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 2 ) ainteger_I4P = 2147483647_I4P astring = ainteger_I4P test_passed ( 3 ) = astring // '' == '+2147483647' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 3 ) ainteger_I8P = - 9223372036854775807_I8P astring = ainteger_I8P test_passed ( 4 ) = astring // '' == '-9223372036854775807' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 4 ) areal_R4P = 3.021e6_R4P astring = areal_R4P test_passed ( 5 ) = astring // '' == '+0.302100E+07' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 5 ) areal_R8P = 7.00907641e23_R8P astring = areal_R8P test_passed ( 6 ) = astring // '' == '+0.700907641000000E+024' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 6 ) areal_R16P = 1.1e200_R16P astring = areal_R16P test_passed ( 7 ) = astring // '' == '+0.110000000000000000000000000000000E+0201' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 7 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram assignments","tags":"","loc":"program/assignments.html","title":"assignments – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~basename_dir~~UsesGraph program~basename_dir basename_dir iso_fortran_env iso_fortran_env iso_fortran_env->program~basename_dir module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~basename_dir module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogrambasename_dirUsesGraph = svgPanZoom('#programbasename_dirUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor basename_dir test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (8) List of passed tests. Source Code program basename_dir !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `basename_dir` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '/bar/foo.tar.bz2' write ( stdout , \"(A)\" ) 'Original:                  \"' // astring // '\"' test_passed ( 1 ) = ( astring % basedir () // '' == '/bar' ) write ( stdout , \"(A)\" ) 'Basedir:                   \"' // astring % basedir () // '\"' test_passed ( 2 ) = ( astring % basename () // '' == 'foo.tar.bz2' ) write ( stdout , \"(A)\" ) 'Basename:                  \"' // astring % basename () // '\"' test_passed ( 3 ) = ( astring % basename ( extension = '.tar' ) // '' == 'foo' ) write ( stdout , \"(A)\" ) 'Basename (extension):      \"' // astring % basename ( extension = '.tar' ) // '\"' test_passed ( 4 ) = ( astring % basename ( strip_last_extension = . true .) // '' == 'foo.tar' ) write ( stdout , \"(A)\" ) 'Basename (last extension): \"' // astring % basename ( strip_last_extension = . true .) // '\"' astring = '\\bar\\foo.tar.bz2' write ( stdout , \"(A)\" ) 'Original (\\ sep):          \"' // astring // '\"' test_passed ( 5 ) = ( astring % basedir ( sep = '\\')//''==' \\ bar ') write(stdout, \"(A)\") ' Basedir : \"'//astring%basedir(sep='\\')//'\" ' test_passed(6) = (astring%basename(sep=' \\ ')//''==' foo . tar . bz2 ') write(stdout, \"(A)\") ' Basename : \"'//astring%basename(sep='\\')//'\" ' test_passed(7) = (astring%basename(sep=' \\ ', extension=' . tar ')//''==' foo ') write(stdout, \"(A)\") ' Basename ( extension ): \"'//astring%basename(sep='\\', extension='.tar')//'\" ' test_passed(8) = (astring%basename(sep=' \\ ', strip_last_extension=.true.)//''==' foo . tar ') write(stdout, \"(A)\") ' Basename ( last extension ): \"'//astring%basename(sep='\\', strip_last_extension=.true.)//'\" ' write(stdout, \"(A,L1)\") new_line(' a ')//' Are all tests passed ? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram basename_dir","tags":"","loc":"program/basename_dir.html","title":"basename_dir – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~camelcase~~UsesGraph program~camelcase camelcase iso_fortran_env iso_fortran_env iso_fortran_env->program~camelcase module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~camelcase module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramcamelcaseUsesGraph = svgPanZoom('#programcamelcaseUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor camelcase test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program camelcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `camelcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % camelcase () // '' == 'TheQuickBrownFoxJumpsOverTheLazyDog.' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % camelcase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram camelcase","tags":"","loc":"program/camelcase.html","title":"camelcase – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~capitalize~~UsesGraph program~capitalize capitalize iso_fortran_env iso_fortran_env iso_fortran_env->program~capitalize module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~capitalize module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramcapitalizeUsesGraph = svgPanZoom('#programcapitalizeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor capitalize test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program capitalize !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `capitalize` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'say all Hello WorLD!' test_passed ( 1 ) = astring % capitalize () // '' == 'Say all hello world!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Capitalize: \"' // astring % capitalize () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram capitalize","tags":"","loc":"program/capitalize.html","title":"capitalize – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~concatenation~~UsesGraph program~concatenation concatenation iso_fortran_env iso_fortran_env iso_fortran_env->program~concatenation module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~concatenation module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramconcatenationUsesGraph = svgPanZoom('#programconcatenationUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor concatenation test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring Another string. type( string ) :: yetanotherstring Yet another string. character(len=:), allocatable :: acharacter A character. logical :: test_passed (6) List of passed tests. Source Code program concatenation !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `concatenation` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. type ( string ) :: yetanotherstring !< Yet another string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello ' anotherstring = 'Bye bye' acharacter = 'World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // acharacter // '\"' test_passed ( 1 ) = astring // acharacter == 'Hello World!' write ( stdout , \"(A)\" ) astring // acharacter test_passed ( 2 ) = acharacter // astring == 'World!Hello ' write ( stdout , \"(A)\" ) 'Original: \"' // acharacter // '\"+\"' // astring // '\"' write ( stdout , \"(A)\" ) acharacter // astring test_passed ( 3 ) = astring // anotherstring == 'Hello Bye bye' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // anotherstring // '\"' write ( stdout , \"(A)\" ) astring // anotherstring yetanotherstring = astring . cat . acharacter test_passed ( 4 ) = yetanotherstring % chars () == 'Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // acharacter // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = acharacter . cat . astring test_passed ( 5 ) = yetanotherstring % chars () == 'World!Hello ' write ( stdout , \"(A)\" ) 'Original: \"' // acharacter // '\"+\"' // astring // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = astring . cat . anotherstring test_passed ( 6 ) = yetanotherstring % chars () == 'Hello Bye bye' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // anotherstring // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram concatenation","tags":"","loc":"program/concatenation.html","title":"concatenation – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~escape~~UsesGraph program~escape escape iso_fortran_env iso_fortran_env iso_fortran_env->program~escape module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~escape module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramescapeUsesGraph = svgPanZoom('#programescapeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor escape test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program escape !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `escape` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '&#94;\\s \\d+\\s*' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = ( astring % escape ( to_escape = '\\')//''==' &#94;\\\\ s \\\\ d + \\\\ s * ') write(stdout, \"(A)\") ' Escaped : \"'//astring%escape(to_escape='\\')//'\" ' write(stdout, \"(A,L1)\") new_line(' a ')//' Are all tests passed ? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram escape","tags":"","loc":"program/escape.html","title":"escape – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~extension~~UsesGraph program~extension extension iso_fortran_env iso_fortran_env iso_fortran_env->program~extension module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~extension module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramextensionUsesGraph = svgPanZoom('#programextensionUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor extension test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program extension !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `extension` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '/bar/foo.tar.bz2' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = ( astring % extension () // '' == '.bz2' ) write ( stdout , \"(A)\" ) 'Extension: \"' // astring % extension () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram extension","tags":"","loc":"program/extension.html","title":"extension – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~fill~~UsesGraph program~fill fill iso_fortran_env iso_fortran_env iso_fortran_env->program~fill module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~fill module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramfillUsesGraph = svgPanZoom('#programfillUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor fill test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (4) List of passed tests. Source Code program fill !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `fill` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = astring % fill ( width = 40 ) // '' == '00000000this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Fill (w=40): \"' // astring % fill ( width = 40 ) // '\"' test_passed ( 2 ) = astring % fill ( width = 50 ) // '' == '000000000000000000this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Fill (w=50): \"' // astring % fill ( width = 50 ) // '\"' test_passed ( 3 ) = astring % fill ( width = 50 , right = . true .) // '' == 'this is string example....wow!!!000000000000000000' write ( stdout , \"(A)\" ) 'Fill (w=50, right): \"' // astring % fill ( width = 50 , right = . true .) // '\"' test_passed ( 4 ) = astring % fill ( width = 40 , filling_char = '*' ) // '' == '********this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Fill (w=40, fc=*): \"' // astring % fill ( width = 40 , filling_char = '*' ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram fill","tags":"","loc":"program/fill.html","title":"fill – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~free~~UsesGraph program~free free iso_fortran_env iso_fortran_env iso_fortran_env->program~free module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~free module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramfreeUsesGraph = svgPanZoom('#programfreeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor free test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program free !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `free` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'say all Hello WorLD!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % is_allocated (). eqv .. true . write ( stdout , \"(A,L1)\" ) 'Is allocated? ' , astring % is_allocated () call astring % free test_passed ( 2 ) = astring % is_allocated (). eqv .. false . write ( stdout , \"(A,L1)\" ) 'Is allocated? ' , astring % is_allocated () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram free","tags":"","loc":"program/free.html","title":"free – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~io_basic~~UsesGraph program~io_basic io_basic iso_fortran_env iso_fortran_env iso_fortran_env->program~io_basic module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~io_basic module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramio_basicUsesGraph = svgPanZoom('#programio_basicUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor io_basic test. Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. integer :: iostat IO status code. character(len=99) :: iomsg IO status message. logical :: test_passed (2) List of passed tests. Source Code program io_basic !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `io_basic` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!' acharacter = 'New Hello World!' #ifndef __GFORTRAN__ write ( stdout , \"(DT)\" , iostat = iostat , iomsg = iomsg ) astring test_passed ( 1 ) = iostat == 0 read ( acharacter , \"(DT)\" , iostat = iostat , iomsg = iomsg ) astring test_passed ( 2 ) = iostat == 0 print \"(DT)\" , astring #else call astring % write_formatted ( stdout , \"(DT)\" , [ 1 ], iostat , iomsg ) test_passed ( 1 ) = iostat == 0 call astring % read_formatted_internal ( acharacter , \"(DT)\" , [ 1 ], iostat , iomsg ) test_passed ( 2 ) = iostat == 0 write ( stdout , \"(A)\" ) astring % chars () #endif write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram io_basic","tags":"","loc":"program/io_basic.html","title":"io_basic – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~is_digit~~UsesGraph program~is_digit is_digit iso_fortran_env iso_fortran_env iso_fortran_env->program~is_digit module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~is_digit module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramis_digitUsesGraph = svgPanZoom('#programis_digitUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor is_digit test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program is_digit !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_digit` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112.3 ' test_passed ( 1 ) = astring % is_digit (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is digit? ' , astring % is_digit () astring = '12121123' test_passed ( 2 ) = astring % is_digit (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is digit? ' , astring % is_digit () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_digit","tags":"","loc":"program/is_digit.html","title":"is_digit – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~is_integer~~UsesGraph program~is_integer is_integer iso_fortran_env iso_fortran_env iso_fortran_env->program~is_integer module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~is_integer module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramis_integerUsesGraph = svgPanZoom('#programis_integerUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor is_integer test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (6) List of passed tests. Source Code program is_integer !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_integer` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112 ' test_passed ( 1 ) = astring % is_integer (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () astring = '   -1212112' test_passed ( 2 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer (no spaces allowed)? ' , astring % is_integer ( allow_spaces = . false .) astring = '-1212112   ' test_passed ( 3 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer (no spaces allowed)? ' , astring % is_integer ( allow_spaces = . false .) astring = '+2e20' test_passed ( 4 ) = astring % is_integer (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () astring = ' -2E13 ' test_passed ( 5 ) = astring % is_integer (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () astring = ' -2 E13 ' test_passed ( 6 ) = astring % is_integer (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_integer","tags":"","loc":"program/is_integer.html","title":"is_integer – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~is_number~~UsesGraph program~is_number is_number iso_fortran_env iso_fortran_env iso_fortran_env->program~is_number module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~is_number module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramis_numberUsesGraph = svgPanZoom('#programis_numberUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor is_number test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (7) List of passed tests. Source Code program is_number !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_number` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 7 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112 ' test_passed ( 1 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = '   -121.2112 ' test_passed ( 2 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = '   -1212112' test_passed ( 3 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number (no spaces allowed)? ' , astring % is_number ( allow_spaces = . false .) astring = '-12121.12   ' test_passed ( 4 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number (no spaces allowed)? ' , astring % is_number ( allow_spaces = . false .) astring = '+2e20' test_passed ( 5 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = ' -2.4E13 ' test_passed ( 6 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = ' -2 E13 ' test_passed ( 7 ) = astring % is_number (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_number","tags":"","loc":"program/is_number.html","title":"is_number – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~is_real~~UsesGraph program~is_real is_real iso_fortran_env iso_fortran_env iso_fortran_env->program~is_real module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~is_real module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramis_realUsesGraph = svgPanZoom('#programis_realUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor is_real test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (6) List of passed tests. Source Code program is_real !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_real` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112.d0 ' test_passed ( 1 ) = astring % is_real (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () astring = '   -1212112.d0' test_passed ( 2 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real (no spaces allowed)? ' , astring % is_real ( allow_spaces = . false .) astring = '-1212112.d0   ' test_passed ( 3 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real (no spaces allowed)? ' , astring % is_real ( allow_spaces = . false .) astring = '+2.e20' test_passed ( 4 ) = astring % is_real (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () astring = ' -2.01E13 ' test_passed ( 5 ) = astring % is_real (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () astring = ' -2.01 E13 ' test_passed ( 6 ) = astring % is_real (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_real","tags":"","loc":"program/is_real.html","title":"is_real – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~join~~UsesGraph program~join join iso_fortran_env iso_fortran_env iso_fortran_env->program~join module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~join module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramjoinUsesGraph = svgPanZoom('#programjoinUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor join test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: strings (3) A set of strings. character(len=5) :: characters (3) A set of characters. logical :: test_passed (11) List of passed tests. integer :: s Counter. Source Code program join !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `join` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: strings ( 3 ) !< A set of strings. character ( 5 ) :: characters ( 3 ) !< A set of characters. logical :: test_passed ( 11 ) !< List of passed tests. integer :: s !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (default sep) \"' // astring % join ( array = strings ) // '\"' test_passed ( 1 ) = ( astring % join ( array = strings ) // '' == strings ( 1 ) // strings ( 2 ) // strings ( 3 )) write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 2 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 ) // '-' // strings ( 3 )) call strings ( 1 )% free strings ( 2 ) = 'two' strings ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 3 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 2 ) // '-' // strings ( 3 )) strings ( 1 ) = 'one' strings ( 2 ) = 'two' call strings ( 3 )% free write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 4 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 )) strings ( 1 ) = 'one' call strings ( 2 )% free strings ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 5 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (default sep) \"' // astring % join ( array = characters ) // '\"' test_passed ( 6 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // characters ( 2 ) // characters ( 3 )) write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 7 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 8 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 9 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 )) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 10 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo astring = '_' write ( stdout , \"(A)\" ) 'join (sep by astring) \"' // astring % join ( array = characters ) // '\"' test_passed ( 11 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // '_' // characters ( 2 ) // '_' // characters ( 3 )) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram join","tags":"","loc":"program/join.html","title":"join – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~partition~~UsesGraph program~partition partition iso_fortran_env iso_fortran_env iso_fortran_env->program~partition module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~partition module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogrampartitionUsesGraph = svgPanZoom('#programpartitionUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor partition test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: strings (3) A set of strings. logical :: test_passed (3) List of passed tests. Source Code program partition !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `partition` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: strings ( 3 ) !< A set of strings. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' strings = astring % partition ( sep = 'lo Wo' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'Hel' . and . strings ( 2 ) // '' == 'lo Wo' . and . strings ( 3 ) // '' == 'rLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // 'lo Wo' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' strings = astring % partition ( sep = 'Hello' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == '' . and . strings ( 2 ) // '' == 'Hello' . and . strings ( 3 ) // '' == ' WorLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // 'Hello' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' astring = 'Hello WorLD!' strings = astring % partition () test_passed ( 3 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == ' ' . and . strings ( 3 ) // '' == 'WorLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // ' ' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram partition","tags":"","loc":"program/partition.html","title":"partition – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~replace~~UsesGraph program~replace replace iso_fortran_env iso_fortran_env iso_fortran_env->program~replace module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~replace module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramreplaceUsesGraph = svgPanZoom('#programreplaceUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor replace test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program replace !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `replace` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'When YOU are sad YOU should think to me :-)' write ( stdout , \"(A)\" ) 'Original:                                 \"' // astring // '\"' test_passed ( 1 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' ) // '' == 'When THEY are sad THEY should think to me :-)' ) write ( stdout , \"(A)\" ) 'Replace \"YOU\" with \"THEY\":                \"' // astring % replace ( old = 'YOU' , new = 'THEY' ) // '\"' test_passed ( 2 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '' == 'When THEY are sad YOU should think to me :-)' ) write ( stdout , \"(A)\" ) 'Replace only the first \"YOU\" with \"THEY\": \"' // astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram replace","tags":"","loc":"program/replace.html","title":"replace – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~reverse~~UsesGraph program~reverse reverse iso_fortran_env iso_fortran_env iso_fortran_env->program~reverse module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~reverse module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramreverseUsesGraph = svgPanZoom('#programreverseUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor reverse test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program reverse !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `reverse` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'abcdefghilmnopqrstuvz' test_passed ( 1 ) = ( astring % reverse () // '' == 'zvutsrqponmlihgfedcba' ) write ( stdout , \"(A,L1)\" ) 'Original:  \"' // astring // '\", reversed: \"' // astring % reverse () // '\", is correct? ' , & astring % reverse () // '' == 'zvutsrqponmlihgfedcba' astring = '0123456789' test_passed ( 2 ) = ( astring % reverse () // '' == '9876543210' ) write ( stdout , \"(A,L1)\" ) 'Original:  \"' // astring // '\", reversed: \"' // astring % reverse () // '\", is correct? ' , & astring % reverse () // '' == '9876543210' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram reverse","tags":"","loc":"program/reverse.html","title":"reverse – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sadjustlr~~UsesGraph program~sadjustlr sadjustlr iso_fortran_env iso_fortran_env iso_fortran_env->program~sadjustlr module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~sadjustlr module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramsadjustlrUsesGraph = svgPanZoom('#programsadjustlrUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sadjustlr test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program sadjustlr !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sadjustlr` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % sadjustl () // '' == 'Hello World!   ' write ( stdout , \"(A)\" ) 'AdjustL:  \"' // astring % sadjustl () // '\"' astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 2 ) = astring % sadjustr () // '' == '   Hello World!' write ( stdout , \"(A)\" ) 'AdjustR:  \"' // astring % sadjustr () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sadjustlr","tags":"","loc":"program/sadjustlr.html","title":"sadjustlr – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~search~~UsesGraph program~search search iso_fortran_env iso_fortran_env iso_fortran_env->program~search module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~search module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramsearchUsesGraph = svgPanZoom('#programsearchUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor search test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring Another string. character(len=:), allocatable :: acharacter A character. integer :: istart Start index of searched tag. integer :: iend End index of searched tag. logical :: test_passed (5) List of passed tests. Source Code program search !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `search` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. character ( len = :), allocatable :: acharacter !< A character. integer :: istart !< Start index of searched tag. integer :: iend !< End index of searched tag. logical :: test_passed ( 5 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '<test> <first> hello </first> <first> not the first </first> </test>' anotherstring = astring % search ( tag_start = '<first>' , tag_end = '</first>' ) test_passed ( 1 ) = anotherstring // '' == '<first> hello </first>' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // anotherstring // '\", is correct? ' , test_passed ( 1 ) astring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' anotherstring = astring % search ( tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 2 ) = anotherstring // '' == '<a> <a> <a> the nested a </a> </a> </a>' write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // anotherstring // '\", is correct? ' , test_passed ( 2 ) call astring % free anotherstring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_string = anotherstring , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 3 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // anotherstring // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // astring // '\", is correct? ' , test_passed ( 3 ) call astring % free acharacter = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 4 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // acharacter // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // astring // '\", is correct? ' , test_passed ( 4 ) acharacter = '<test> <first> hello </first> <sec> <sec>not the first</sec> </sec> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<sec>' , tag_end = '</sec>' , istart = istart , iend = iend ) test_passed ( 5 ) = astring // '' == acharacter ( 31 : 67 ) write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // acharacter // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // astring // '\", is correct? ' , test_passed ( 5 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram search","tags":"","loc":"program/search.html","title":"search – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sindex~~UsesGraph program~sindex sindex iso_fortran_env iso_fortran_env iso_fortran_env->program~sindex module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~sindex module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramsindexUsesGraph = svgPanZoom('#programsindexUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sindex test. Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. character(len=:), allocatable :: anothercharacter Another character. integer :: i Index result. integer :: ic Index result comparison. logical :: test_passed (2) List of passed tests. Source Code program sindex !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sindex` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sindex ( substring = anothercharacter ) ic = index ( string = acharacter , substring = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sindex ( substring = anothercharacter , back = . true .) ic = index ( string = acharacter , substring = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sindex","tags":"","loc":"program/sindex.html","title":"sindex – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~slen~~UsesGraph program~slen slen iso_fortran_env iso_fortran_env iso_fortran_env->program~slen module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~slen module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramslenUsesGraph = svgPanZoom('#programslenUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor slen test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program slen !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `slen` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % slen () == len ( 'Hello World!   ' ) write ( stdout , \"(A,I2)\" ) 'Len: ' , astring % slen () test_passed ( 2 ) = astring % slen_trim () == len_trim ( 'Hello World!   ' ) write ( stdout , \"(A,I2)\" ) 'Len_trim: ' , astring % slen_trim () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram slen","tags":"","loc":"program/slen.html","title":"slen – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~snakecase~~UsesGraph program~snakecase snakecase iso_fortran_env iso_fortran_env iso_fortran_env->program~snakecase module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~snakecase module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramsnakecaseUsesGraph = svgPanZoom('#programsnakecaseUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor snakecase test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program snakecase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `snakecase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % snakecase () // '' == 'the_quick_brown_fox_jumps_over_the_lazy_dog.' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % snakecase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram snakecase","tags":"","loc":"program/snakecase.html","title":"snakecase – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~split~~UsesGraph program~split split iso_fortran_env iso_fortran_env iso_fortran_env->program~split module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~split module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramsplitUsesGraph = svgPanZoom('#programsplitUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor split test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ), allocatable :: strings (:) A set of strings. logical :: test_passed (5) List of passed tests. integer :: s Counter. Source Code program split !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `split` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. logical :: test_passed ( 5 ) !< List of passed tests. integer :: s !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '+ab-++cre-++cre-ab+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'ab-++cre-++cre-ab+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'ab-++cre-++cre-ab' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 3 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'Hello ' // new_line ( 'a' ) // 'World!' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"new_line\"' call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 4 ) = ( strings ( 1 ) // '' == 'Hello ' . and . strings ( 2 ) // '' == 'World!' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'Hello World!' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"default\" (namely space)' call astring % split ( tokens = strings ) test_passed ( 5 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == 'World!' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram split","tags":"","loc":"program/split.html","title":"split – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~srepeat~~UsesGraph program~srepeat srepeat iso_fortran_env iso_fortran_env iso_fortran_env->program~srepeat module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~srepeat module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramsrepeatUsesGraph = svgPanZoom('#programsrepeatUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor srepeat test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program srepeat !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `srepeat` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . test_passed ( 1 ) = astring % srepeat ( rstring = 'x' , ncopies = 5 ) // '' == 'xxxxx' write ( stdout , \"(A,I2)\" ) 'Repeat x 5 times: \"' // astring % srepeat ( rstring = 'x' , ncopies = 5 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram srepeat","tags":"","loc":"program/srepeat.html","title":"srepeat – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sscan~~UsesGraph program~sscan sscan iso_fortran_env iso_fortran_env iso_fortran_env->program~sscan module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~sscan module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramsscanUsesGraph = svgPanZoom('#programsscanUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sscan test. Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. character(len=:), allocatable :: anothercharacter Another character. integer :: i Index result. integer :: ic Index result comparison. logical :: test_passed (2) List of passed tests. Source Code program sscan !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sscan` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sscan ( set = anothercharacter ) ic = scan ( string = acharacter , set = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sscan ( set = anothercharacter , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sscan","tags":"","loc":"program/sscan.html","title":"sscan – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~start_end~~UsesGraph program~start_end start_end iso_fortran_env iso_fortran_env iso_fortran_env->program~start_end module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~start_end module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramstart_endUsesGraph = svgPanZoom('#programstart_endUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor start_end test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (8) List of passed tests. Source Code program start_end !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `start_end` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % start_with ( prefix = 'Hello' ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'start with \"Hello\"? ' , astring % start_with ( prefix = 'Hello' ) test_passed ( 2 ) = astring % start_with ( prefix = 'hell' ). eqv .. false . write ( stdout , \"(A,L1)\" ) 'start with \"hell\"? ' , astring % start_with ( prefix = 'hell' ) test_passed ( 3 ) = astring % start_with ( prefix = 'llo Wor' , start = 3 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (3:) start with \"llo Wor\"? ' , astring % start_with ( prefix = 'llo Wor' , start = 3 ) test_passed ( 4 ) = astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (4:7) start with \"lo W\"? ' , astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ) test_passed ( 5 ) = astring % end_with ( suffix = 'LD!' ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'end with \"LD!\"? ' , astring % end_with ( suffix = 'LD!' ) test_passed ( 6 ) = astring % end_with ( suffix = 'lD!' ). eqv .. false . write ( stdout , \"(A,L1)\" ) 'end with \"lD!\"? ' , astring % end_with ( suffix = 'lD!' ) test_passed ( 7 ) = astring % end_with ( suffix = 'orLD!' , start = 5 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (5:) end with \"orLD!\"? ' , astring % end_with ( suffix = 'orLD!' , start = 5 ) test_passed ( 8 ) = astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (8:12) end with \"orLD!\"? ' , astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram start_end","tags":"","loc":"program/start_end.html","title":"start_end – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~startcase~~UsesGraph program~startcase startcase iso_fortran_env iso_fortran_env iso_fortran_env->program~startcase module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~startcase module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramstartcaseUsesGraph = svgPanZoom('#programstartcaseUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor startcase test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program startcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `startcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % startcase () // '' == 'The Quick Brown Fox Jumps Over The Lazy Dog.' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % startcase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram startcase","tags":"","loc":"program/startcase.html","title":"startcase – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~strim~~UsesGraph program~strim strim iso_fortran_env iso_fortran_env iso_fortran_env->program~strim module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~strim module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramstrimUsesGraph = svgPanZoom('#programstrimUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor strim test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program strim !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strim` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % strim () // '' == 'Hello World!' write ( stdout , \"(A)\" ) 'Trimmed:  \"' // astring % strim () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strim","tags":"","loc":"program/strim.html","title":"strim – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~strip~~UsesGraph program~strip strip iso_fortran_env iso_fortran_env iso_fortran_env->program~strip module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~strip module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramstripUsesGraph = svgPanZoom('#programstripUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor strip test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program strip !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strip` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % strip () // '' == 'Hello World!' write ( stdout , \"(A,L1)\" ) 'Strip:    \"' // astring % strip () // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strip","tags":"","loc":"program/strip.html","title":"strip – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sverify~~UsesGraph program~sverify sverify iso_fortran_env iso_fortran_env iso_fortran_env->program~sverify module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~sverify module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramsverifyUsesGraph = svgPanZoom('#programsverifyUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sverify test. Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. character(len=:), allocatable :: anothercharacter Another character. integer :: i Index result. integer :: ic Index result comparison. logical :: test_passed (3) List of passed tests. Source Code program sverify !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sverify` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sverify ( set = anothercharacter ) ic = verify ( string = acharacter , set = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , test_passed ( 1 ) i = astring % sverify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , test_passed ( 2 ) anothercharacter = acharacter i = astring % sverify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 3 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Identical strings call result: ' , i , ' is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sverify","tags":"","loc":"program/sverify.html","title":"sverify – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~swapcase~~UsesGraph program~swapcase swapcase iso_fortran_env iso_fortran_env iso_fortran_env->program~swapcase module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~swapcase module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramswapcaseUsesGraph = svgPanZoom('#programswapcaseUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor swapcase test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program swapcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `swapcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % swapcase () // '' == '  hELLO wORLD!   ' write ( stdout , \"(A,L1)\" ) 'Swapcase: \"' // astring % swapcase () // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram swapcase","tags":"","loc":"program/swapcase.html","title":"swapcase – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~to_number~~UsesGraph program~to_number to_number iso_fortran_env iso_fortran_env iso_fortran_env->program~to_number module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~to_number module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramto_numberUsesGraph = svgPanZoom('#programto_numberUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor to_number test. Variables Type Attributes Name Initial type( string ) :: astring A string. integer(kind=I1P) :: integer_I1P A integer. integer(kind=I1P) :: integer_I1P_ A integer. integer(kind=I2P) :: integer_I2P A integer. integer(kind=I2P) :: integer_I2P_ A integer. integer(kind=I4P) :: integer_I4P A integer. integer(kind=I4P) :: integer_I4P_ A integer. integer(kind=I8P) :: integer_I8P A integer. integer(kind=I8P) :: integer_I8P_ A integer. real(kind=R4P) :: real_R4P A real. real(kind=R4P) :: real_R4P_ A real. real(kind=R8P) :: real_R8P A real. real(kind=R8P) :: real_R8P_ A real. real(kind=R16P) :: real_R16P A real. real(kind=R16P) :: real_R16P_ A real. logical :: test_passed (7) List of passed tests. Source Code program to_number !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `to_number` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string , I1P , I2P , I4P , I8P , R4P , R8P , R16P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. integer ( I1P ) :: integer_I1P !< A integer. integer ( I1P ) :: integer_I1P_ !< A integer. integer ( I2P ) :: integer_I2P !< A integer. integer ( I2P ) :: integer_I2P_ !< A integer. integer ( I4P ) :: integer_I4P !< A integer. integer ( I4P ) :: integer_I4P_ !< A integer. integer ( I8P ) :: integer_I8P !< A integer. integer ( I8P ) :: integer_I8P_ !< A integer. real ( R4P ) :: real_R4P !< A real. real ( R4P ) :: real_R4P_ !< A real. real ( R8P ) :: real_R8P !< A real. real ( R8P ) :: real_R8P_ !< A real. real ( R16P ) :: real_R16P !< A real. real ( R16P ) :: real_R16P_ !< A real. logical :: test_passed ( 7 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '127' integer_I1P = astring % to_number ( kind = 1_I1P ) integer_I1P_ = 127_I1P test_passed ( 1 ) = integer_I1P == integer_I1P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I4,A)\" ) 'To number: \"' , integer_I1P , '\"' astring = '32767' integer_I2P = astring % to_number ( kind = 1_I2P ) integer_I2P_ = 32767_I2P test_passed ( 2 ) = integer_I2P == integer_I2P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I6,A)\" ) 'To number: \"' , integer_I2P , '\"' astring = '2147483647' integer_I4P = astring % to_number ( kind = 1_I4P ) integer_I4P_ = 2147483647_I4P test_passed ( 3 ) = integer_I4P == integer_I4P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I11,A)\" ) 'To number: \"' , integer_I4P , '\"' astring = '-9223372036854775807' integer_I8P = astring % to_number ( kind = 1_I8P ) integer_I8P_ = - 9223372036854775807_I8P test_passed ( 4 ) = integer_I8P == integer_I8P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I20,A)\" ) 'To number: \"' , integer_I8P , '\"' astring = '3.4e9' real_R4P = astring % to_number ( kind = 1._R4P ) real_R4P_ = 3.4e9_R4P test_passed ( 5 ) = real_R4P == real_R4P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,E13.6,A)\" ) 'To number: \"' , real_R4P , '\"' astring = '-13.4345345e21' real_R8P = astring % to_number ( kind = 1._R8P ) real_R8P_ = - 1 3.4345345e21_R8P test_passed ( 6 ) = real_R8P == real_R8P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,E23.15,A)\" ) 'To number: \"' , real_R8P , '\"' astring = '1.1e200' real_R16P = astring % to_number ( kind = 1._R16P ) real_R16P_ = 1.1e200_R16P test_passed ( 7 ) = real_R16P == real_R16P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,E42.33,A)\" ) 'To number: \"' , real_R16P , '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram to_number","tags":"","loc":"program/to_number.html","title":"to_number – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~unique~~UsesGraph program~unique unique iso_fortran_env iso_fortran_env iso_fortran_env->program~unique module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~unique module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramuniqueUsesGraph = svgPanZoom('#programuniqueUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor unique test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program unique !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `unique` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '+++ab-++cre-++cre-ab+++++' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % unique ( substring = '+' ) // '' == '+ab-+cre-+cre-ab+' write ( stdout , \"(A,L1)\" ) 'Unique:   \"' // astring % unique ( substring = '+' ) // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram unique","tags":"","loc":"program/unique.html","title":"unique – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~upper_lower~~UsesGraph program~upper_lower upper_lower iso_fortran_env iso_fortran_env iso_fortran_env->program~upper_lower module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~upper_lower module~penf~2 penf module~penf~2->module~stringifor module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 var panprogramupper_lowerUsesGraph = svgPanZoom('#programupper_lowerUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor upper_lower test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1:8) List of passed tests. Source Code program upper_lower !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `upper_lower` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 : 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' test_passed ( 1 ) = astring % upper () // '' == 'HELLO WORLD!' test_passed ( 2 ) = astring % lower () // '' == 'hello world!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'UPPER:    \"' // astring % upper () // '\". Is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) 'lower:    \"' // astring % lower () // '\". Is correct? ' , test_passed ( 2 ) astring = ' Hello World' test_passed ( 3 ) = astring % is_upper (). eqv .. false . test_passed ( 4 ) = astring % is_lower (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 4 ) astring = ' HELLO WORLD' test_passed ( 5 ) = astring % is_upper (). eqv .. true . test_passed ( 6 ) = astring % is_lower (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 5 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 6 ) astring = ' hello world' test_passed ( 7 ) = astring % is_upper (). eqv .. false . test_passed ( 8 ) = astring % is_lower (). eqv .. true . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 7 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 8 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram upper_lower","tags":"","loc":"program/upper_lower.html","title":"upper_lower – StringiFor"},{"text":"Uses: penf iso_fortran_env program~~test_all~~UsesGraph program~test_all test_all module~penf~2 penf module~penf~2->program~test_all iso_fortran_env iso_fortran_env iso_fortran_env->program~test_all module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables->module~penf_b_size~2 module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF's testing program. Usage ./test_all Calls program~~test_all~~CallsGraph program~test_all test_all interface~cton cton program~test_all->interface~cton proc~penf_print penf_print program~test_all->proc~penf_print interface~str str program~test_all->interface~str proc~penf_init penf_init program~test_all->proc~penf_init interface~strz strz program~test_all->interface~strz interface~digit digit program~test_all->interface~digit interface~bstr bstr program~test_all->interface~bstr interface~bcton bcton program~test_all->interface~bcton proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~check_endian check_endian proc~penf_init->proc~check_endian proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p proc~digit_i4 digit_I4 interface~digit->proc~digit_i4 proc~digit_i8 digit_I8 interface~digit->proc~digit_i8 proc~digit_i1 digit_I1 interface~digit->proc~digit_i1 proc~digit_i2 digit_I2 interface~digit->proc~digit_i2 proc~bstr_r8p bstr_R8P interface~bstr->proc~bstr_r8p proc~bstr_i4p bstr_I4P interface~bstr->proc~bstr_i4p proc~bstr_i2p bstr_I2P interface~bstr->proc~bstr_i2p proc~bstr_i1p bstr_I1P interface~bstr->proc~bstr_i1p proc~bstr_r4p bstr_R4P interface~bstr->proc~bstr_r4p proc~bstr_i8p bstr_I8P interface~bstr->proc~bstr_i8p proc~bctor_r4p bctor_R4P interface~bcton->proc~bctor_r4p proc~bctor_r8p bctor_R8P interface~bcton->proc~bctor_r8p proc~bctoi_i1p bctoi_I1P interface~bcton->proc~bctoi_i1p proc~bctoi_i4p bctoi_I4P interface~bcton->proc~bctoi_i4p proc~bctoi_i2p bctoi_I2P interface~bcton->proc~bctoi_i2p proc~bctoi_i8p bctoi_I8P interface~bcton->proc~bctoi_i8p proc~str_a_r4p->proc~str_r4p proc~str_a_r8p->proc~str_r8p proc~str_a_i1p->proc~str_i1p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~str_a_i4p->proc~str_i4p none~is_little_endian is_little_endian proc~check_endian->none~is_little_endian proc~bctor_r4p->interface~str proc~bctor_r8p->interface~str proc~bctoi_i1p->interface~str proc~bctoi_i4p->interface~str proc~bctoi_i2p->interface~str proc~bctoi_i8p->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code program test_all !----------------------------------------------------------------------------------------------------------------------------------- !< PENF's testing program. !< !<### Usage !<```bash !< ./test_all !<``` !----------------------------------------------------------------------------------------------------------------------------------- use penf use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call penf_Init call penf_Print ( unit = stdout ) print \"(A)\" , '' print \"(A)\" , 'Testing IR_Precision tools' print \"(A)\" , 'Casting real-to-string: ' // str ( n = 1._R8P ) print \"(A)\" , 'Casting integer-to-string: ' // str ( n = 11_I8P ) print \"(A,\" // FR8P // \")\" , 'Casting string-to-real: ' , cton ( str = '2.2d0' , knd = 1._R8P ) print \"(A,\" // FI4P // \")\" , 'Casting integer-to-string: ' , cton ( str = '43' , knd = 1_I4P ) print \"(A)\" , 'Casting integer-to-string with zero padding: ' // trim ( strz ( nz_pad = 3 , n = 34_I8P )) #ifndef __GFORTRAN__ print \"(A)\" , 'Casting real-to-bit_string: ' // bstr ( n = 1._R4P ) #endif print \"(A)\" , 'Casting integer-to-bit_string: ' // bstr ( n = 1_I4P ) #ifndef __GFORTRAN__ print \"(A,\" // FR4P // \")\" , 'Casting bit_string-to-real: ' , bcton ( bstr = '00111111100000000000000000000000' , knd = 1._R4P ) #endif print \"(A,\" // FI4P // \")\" , 'Casting bit_string-to-integer: ' , bcton ( bstr = '00000000000000000000000000000001' , knd = 1_I4P ) print \"(A)\" , 'Number of digit of 1023: ' // str ( n = digit ( 1023_I4P )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_all","tags":"","loc":"program/test_all.html","title":"test_all – StringiFor"}]}