var tipuesearch = {"pages":[{"text":"StringiFor StringiFor StringiFor, Strings Fortran Manipulator, yet another strings Fortran module A KISS pure Fortran library providing  astrings (class) manipulator for modern (2003+) Fortran projects. StringiFor is a pure Fortran (KISS) library providing a strings manipulator for modern Fortran projects; StringiFor is Fortran 2003+ standard compliant; StringiFor is OOP designed; StringiFor is TDD designed; StringiFor is a Free, Open Source Project. Issues Compiler Support GNU partial support GNU gfortran does not support user-defined-type-IO, thus some class features are disabled if GNU is used. What is StringiFor? | Main features | Copyrights | Download | Compilation | Documentation | Comparison to other Approaches What is StringiFor? Modern Fortran standards (2003+) have introduced a better support for characters variables, but Fortraners still do not have the power on dealing with strings of other more-rich-programmers, e.g. Pythoners. Allocatable deferred length character variables are now quantum-leap with respect the old inflexible Fortran characters, but it is still not enough for many Fortraners. Moreover, Fortran does not provide builtin methods for widely used strings manipulations offered by other languages, e.g. UPPER/lowercase transformation, tokenization, etc… StringiFor attempts to fill this lack. Go to Top Main features StringiFor exposes only one class (OO-designed), the string type, that should be used as a more powerful string variable with respect a standard Fortran character variable. The main features of this class are: seamless interchangeability with standard character variables, e.g. concatenation, IO, etc…; handy builtin methods, e.g. split, search, basename, join, etc…; low memory consumption: only one deferred length allocatable character member is stored, allowing for efficient memory allocation in array of strings, the elements of which can have different lengths; safe: almost all methods are elemental or pure; robust: the library is Test Driven Developed TDD , a comprehensive tests suite is provided. Any feature request is welcome. Go to Top Copyrights StringiFor is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to StringiFor is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Download StringiFor home is at https://github.com/szaghi/StringiFor . It uses git submodule to handle the third party dependency. To download all the source files you can: clone recursively this repository: git clone --recursive https://github.com/szaghi/StringiFor download the latest master-branch archive at https://github.com/szaghi/StringiFor/archive/master.zip download a release archive at https://github.com/szaghi/StringiFor/releases Go to Top Compilation StringiFor is a modern Fortran project thus a modern Fortran compiler is need to compile the project. In the following table the support for some widely-used Fortran compilers is summarized. Compiler Vendor Support Notes does not support defined IO full support not tested not tested not tested not tested The library is modular, namely it exploits Fortran modules. As a consequence, there is compilation-cascade hierarchy to build the library. To correctly build the library the following approaches are supported Build by means of FoBiS : full support; Build by means of GNU Make : support only Intel Fortran; Build by means of CMake : to be implemented. The FoBiS building support is the most complete, as it is the one used for the developing StringiFor. Build by means of FoBiS A fobos file is provided to build the library by means of the Fortran Building System FoBiS . Build all tests Type FoBiS.py build After (a successuful) building a directory ./exe is created containing all the compiled tests that constitute the StringiFor regression-tests-suite , e.g. → FoBiS.py build\nBuilder options\nDirectories\n  Building directory: \"exe\" Compiled-objects .o   directory: \"exe/obj\" Compiled-objects .mod directory: \"exe/mod\" Compiler options\n  Vendor: \"gnu\" Compiler command: \"gfortran\" Module directory switch: \"-J\" Compiling flags: \"-c -frealloc-lhs -std=f2008 -fall-intrinsics -O2 -Dr16p\" Linking flags: \"-O2\" Preprocessing flags: \"-Dr16p\" Coverage: False\n  Profile: False\nPreForM.py used: False\nPreForM.py output directory: None\nPreForM.py extensions processed: [] Building src/tests/is_real.f90\nCompiling src/lib/penf.F90 serially\nCompiling src/lib/string_t.F90 serially\nCompiling src/lib/stringifor.F90 serially\nCompiling src/tests/is_real.f90 serially\nLinking exe/is_real\nTarget src/tests/is_real.f90 has been successfully built\nBuilder options\n  Directories\n    Building directory: \"exe\" Compiled-objects .o   directory: \"exe/obj\" Compiled-objects .mod directory: \"exe/mod\" Compiler options\n    Vendor: \"gnu\" Compiler command: \"gfortran\" Module directory switch: \"-J\" Compiling flags: \"-c -frealloc-lhs -std=f2008 -fall-intrinsics -O2 -Dr16p\" Linking flags: \"-O2\" Preprocessing flags: \"-Dr16p\" Coverage: False\n    Profile: False\n  PreForM.py used: False\n  PreForM.py output directory: None\n  PreForM.py extensions processed: [] Building src/tests/slen.f90\nCompiling src/tests/slen.f90 serially\n...\n\n→ tree -L 1 exe/\nexe/\n├── assignments\n├── basename_dir\n├── camelcase\n├── capitalize\n├── concatenation\n├── equal\n├── escape\n├── extension\n├── fill\n...\n├── swapcase\n├── to_number\n├── unique\n└── upper_lower Build the library Type # static-linked library by means of GNU gfortran FoBiS.py build -mode stringifor-static-gnu # shared-linked library by means of GNU gfortran FoBiS.py build -mode stringifor-shared-gnu # static-linked library by means of Intel Fortran FoBiS.py build -mode stringifor-static-intel # shared-linked library by means of Intel Fortran FoBiS.py build -mode stringifor-shared-intel The library will be built into the directory ./lib . List other fobos modes To list all fobos-provided modes type → FoBiS.py build -lmodes\nThe fobos file defines the following modes:\n  - \"tests-gnu\" - \"tests-gnu-debug\" - \"tests-intel\" - \"tests-intel-debug\" - \"stringifor-static-gnu\" - \"stringifor-shared-gnu\" - \"stringifor-static-intel\" - \"stringifor-shared-intel\" It is worth to note that the first mode is the one automatically called by FoBiS.py build . Build by means of GNU Make The provided makefile support only Intel Fortran Compiler and it has two main building rules: build the (static linked) library; build the tests suite. To build the library type make The library will be built into the directory ./lib . To build the tests suite type make TESTS = yes The tests will be built into the directory ./exe . Build by means of CMake To be done. Go to Top Documentation The StringiFor documentation is mainly contained into this file (it has its own wiki with some less important documents). Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of StringiFor Basic IO String manipulation Numbers handling Complex scenario Methods API A Taste of StringiFor StringiFor is very handy… Basic IO The class string IO is overloaded by defined write/read TBP. Moreover, dedicated methods and operators can be exploited for IO, e.g. use stringifor type ( string ) :: astring astring = 'Hello World' print \"(A)\" , astring % chars () ! \"chars\" method returns a standard character variable print \"(DT)\" , astring ! defined IO is not enabled with GNU gfortran print \"(A)\" , astring // '' ! on-the-fly conversion to standard character by means of concatenation String manipulation The class string has many methods for a plethora of strings manipulations, e.g. use stringifor type ( string ) :: astring type ( string ) :: strings ( 3 ) astring = '0123456789' print \"(A)\" , astring % reverse () // '' ! print \"9876543210\" astring = 'Hello World' print \"(A)\" , astring % replace ( old = 'World' , new = 'People' ) // '' ! print \"Hello People\" astring = 'Hello World' strings = astring % partition ( sep = 'lo Wo' ) print \"(A)\" , 'Before sep: \"' // strings ( 1 ) // '\"' ! print \"Hel\" print \"(A)\" , 'Sep itself: \"' // strings ( 2 ) // '\"' ! print \"lo Wo\" print \"(A)\" , 'After sep:  \"' // strings ( 3 ) // '\"' ! print \"rld\" strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' print \"(A)\" , astring % join ( strings ) // '' ! print \"onetwothree\" print \"(A)\" , astring % join ( strings , sep = '-' ) // '' ! print \"one-two-three\" astring = ' a StraNgE caSe var' print \"(A)\" , astring % camelcase () // '' ! print \" AStrangeCaseVar\" print \"(A)\" , astring % snakecase () // '' ! print \" a_strange_case_var\" print \"(A)\" , astring % startcase () // '' ! print \" A Strange Case Var\" Numbers handling StringiFor, by means of the portability environment library, PENF can handle numbers (reals and integers) effortless. The string/number casting (to/from and viceversa) is done by overloaded assignments (for all kinds of integers and reals). For convenience, StringiFor exposes the PENF number portable kind parameters. use stringifor type ( string ) :: astring astring = 127 _ I1P ! \"I1P\" is the PENF kind for 1-byte-like integer. print \"(A)\" , astring // '' ! print \"+127\" astring = 3.021e6_R4P ! \"R4P\" is the PENF kind for 4-byte-like real. print \"(A)\" , astring // '' ! print \"+0.302100E+07\" astring = \"3.4e9\" ! assign to a string without the necessity to define a real kind if ( astring % is_number ()) then if ( astring % is_real ()) then print \"(E13.6)\" , astring % to_number ( kind = 1._R4P ) ! print \" 0.340000E+10\" using a 4-byte-like kind endif endif Complex scenario StingiFor is developed to improve the poor Fortran people with daily strings-usage, however, also complex scenario is taken into account, e.g. file parsing, OS operations, etc… use stringifor type ( string ) :: astring ! OS like manipulation astring = '/bar/foo.tar.bz2' print \"(A)\" , astring % basedir () // '' ! print \"/bar\" print \"(A)\" , astring % basename () // '' ! print \"foo.tar.bz2\" print \"(A)\" , astring % basename ( extension = '.tar' ) // '' ! print \"foo\" print \"(A)\" , astring % basename ( last_extension = . true .) // '' ! print \"foo.tar\" ! XML like tag parsing astring = '<test> <first> hello </first> <first> not the first </first> </test>' print \"(A)\" , astring % search ( tag_start = '<first>' , tag_end = '</first>' ) // '' ! print \"<first> hello </first>\" A naive CSV parser This is just a provocation, but with StringiFor it is easy to develop a naive CSV parser. Let us assume we want to parse a cars-price database as the following one Year, Make, Model, Description, Price\n1997, Ford, E350   , ac abs moon, 3000.00\n1999, Chevy, Venture \"Extended Edition\"  , , 4900.00\n1999, Chevy, Venture \"Extended Edition Very Large\", , 5000.00 Well, parsing it and handling its cells values is very easy by means of StringiFor use stringifor implicit none type ( string ) :: csv !< The CSV file as a single stream. type ( string ), allocatable :: rows (:) !< The CSV table rows. type ( string ), allocatable :: columns (:) !< The CSV table columns. type ( string ), allocatable :: cells (:,:) !< The CSV table cells. type ( string ) :: most_expensive !< The most expensive car. real ( R8P ) :: highest_cost !< The highest cost. integer :: rows_number !< The CSV file rows number. integer :: columns_number !< The CSV file columns number. integer :: r !< Counter. ! parsing the just created CSV file: all done 9 statements! call csv % read_file ( file = 'cars.csv' ) ! read the CSV file as a single stream call csv % split ( tokens = rows , sep = new_line ( 'a' )) ! get the CSV file rows rows_number = size ( rows , dim = 1 ) ! get the CSV file rows number columns_number = rows ( 1 )% count ( ',' ) + 1 ! get the CSV file columns number allocate ( cells ( 1 : columns_number , 1 : rows_number )) ! allocate the CSV file cells do r = 1 , rows_number ! parse all cells call rows ( r )% split ( tokens = columns , sep = ',' ) ! get current columns cells ( 1 : columns_number , r ) = columns ! save current columns into cells enddo ! now you can do whatever with your parsed data ! print the table in markdown syntax print \"(A)\" , 'A markdown-formatted table' print \"(A)\" , '' print \"(A)\" , '|' // csv % join ( array = cells (:, 1 ), sep = '|' ) // '|' columns = '----' ! re-use columns for printing separators print \"(A)\" , '|' // csv % join ( array = columns , sep = '|' ) // '|' do r = 2 , rows_number print \"(A)\" , '|' // csv % join ( array = cells (:, r ), sep = '|' ) // '|' enddo print \"(A)\" , '' ! find the most expensive car print \"(A)\" , 'Searching for the most expensive car' most_expensive = 'unknown' highest_cost = - 1._R8P do r = 2 , rows_number if ( cells ( 5 , r )% to_number ( kind = 1._R8P ) >= highest_cost ) then highest_cost = cells ( 5 , r )% to_number ( kind = 1._R8P ) most_expensive = csv % join ( array = [ cells ( 2 , r ), cells ( 3 , r )], sep = ' ' ) endif enddo print \"(A)\" , 'The most expensive car is : ' // most_expensive See the test program csv_naive_parser for a working example. Obviously, this is a naive parser without any robustness, but it proves the usefulness of the StringiFor approach. Methods API In the following all the methods of string are listed with a brief description of their aim. The hyperlinks bring you to the full API explained into the GH pages. builtins replacements name meaning adjustl adjustl replacement adjustr adjustr replacement count count replacement index index replacement len len replacement len_trim len_trim replacement repeat repeat replacement scan scan replacement trim trim replacement verify verify replacement auxiliary methods name meaning basedir return the base directory name of a string containing a file name basename return the base file name of a string containing a file name camelcase return a string with all words capitalized without spaces capitalize return a string with its first character capitalized and the rest lowercased chars return the raw characters data decode decode string encode encode string escape escape backslashes (or custom escape character) extension return the extension of a string containing a file name fill pad string on the left (or right) with zeros (or other char) to fill width free free dynamic memory insert insert substring into string at a specified position join return a string that is a join of an array of strings or characters lower return a string with all lowercase characters partition split string at separator and return the 3 parts (before the separator and after) read_file read a file a single string stream read_line read line (record) from a connected unit read_lines read (all) lines (records) from a connected unit as a single ascii stream replace return a string with all occurrences of substring old replaced by new reverse return a reversed string search search for tagged record into string slice return the raw characters data sliced snakecase return a string with all words lowercase separated by _ split return a list of substring in the string using sep as the delimiter string startcase return a string with all words capitalized, e.g. title case strip return a string with the leading and trailing characters removed swapcase return a string with uppercase chars converted to lowercase and vice versa to_number cast string to number unescape unescape double backslashes (or custom escaped character) unique reduce to one (unique) multiple occurrences of a substring into a string upper return a string with all uppercase characters write_file write a single string stream into file write_line write line (record) to a connected unit write_lines write lines (records) to a connected unit inquire methods name meaning end_with return true if a string ends with a specified suffix is_allocated return true if the string is allocated is_digit return true if all characters in the string are digits is_integer return true if the string contains an integer is_lower return true if all characters in the string are lowercase is_number return true if the string contains a number (real or integer) is_real return true if the string contains an real is_upper return true if all characters in the string are uppercase start_with return true if a string starts with a specified prefix operators name meaning assignment assignment of string from different inputs // concatenation resulting in characters for seamless integration .cat. concatenation resulting in string == equal operator /= not equal operator < lower than operator <= lower equal than operator >= greater equal than operator > greater than operator IO name meaning read(formatted) formatted input write(formatted) formatted output read(unformatted) unformatted input write(unformatted) unformatted output Go to Top Comparison to other Approaches The lack of Fortran support for strings manipulation has promoted different solutions in the past years. Following the classification of Clive Page [1] we can consider: standard character type; deferred-length allocatable character type (standard 2003+); VARYING_STRING type (standard 90/95+) as defined in ISO/IEC 1539-2:2000 (Varying length character strings). Let us compare StringiFor to the previous three approaches. In particular, let us consider Ian Harvey extension of VARYING_STRING , i.e. the aniso_varying_string [2] . Clive Page had pointed out the following issues, among the others: fixed (at compile time) string length character ( len = 3 ) :: astring ! further lengths different from 3 are not allowed silent truncation on assignment character ( len = 3 ) :: astring astring = 'abcdefgh' ! silent trunctation at 'abc' trim-cluttered code character ( len = 99 ) :: astring character ( len = 99 ) :: anotherstring astring = 'abcdefgh' anotherstring = trim ( astring ) // 'ilmnopqrst' ! trim-cluttering is a necessity handle significant trailing spaces character ( len = 99 ) :: astring character ( len = 99 ) :: anotherstring astring = 'Hello ' ! for some reasons you want to keep these trailing white spaces anotherstring = trim ( astring ) // 'World' ! you need trim because ! len(astring)==len(anotherstring), but lost the significant ! trailing spaces... different character definition character :: astring * 10 ! old way character ( len = 10 ) :: anotherstring ! new way allocation of array of strings character ( len = 10 ), allocatable :: astring (:) allocate ( astring ( 100 )) ! all 100 elements of the array have 10 characters, ! different lengths cannot be declared initialization of array of strings ! the following is illegal character ( len = 9 ), parameter :: day ( 7 ) = [ 'Monday' , & 'Tuesday' , & 'Wednesday' , & 'Thursday' , & 'Friday' , & 'Saturday' , & 'Sunday' ] ! the following is legal, but cluttered by non significant trailing spaces character ( len = 9 ), parameter :: day ( 7 ) = [ 'Monday   ' , & 'Tuesday  ' , & 'Wednesday' , & 'Thursday ' , & 'Friday   ' , & 'Saturday ' , & 'Sunday' ] IO limitations for non standard character variables character ( len = 99 ) :: astring character ( len = :), allocatable :: anotherstring type ( varying_string ) :: yetanotherstring ! fully-simple support for standard character variables astring = 'abcdefgh' print * , astring print \"(A)\" , astring read ( 10 , * ) astring ! partial-simple support for standard deferred length-length allocatable character variables ! care must be placed in input operation... print * , anotherstring print \"(A)\" , anotherstring read ( 10 , * ) anotherstring ! support depends on the implementation of the varying string type print * , yetanotherstring print \"(DT)\" , yetanotherstring read ( 10 , * ) yetanotherstring substring notation (slice)  for non standard character variables character ( len = 99 ) :: astring character ( len = :), allocatable :: anotherstring type ( varying_string ) :: yetanotherstring astring = 'abcdefgh' yetanotherstring = astring anotherstring = astring ( 2 : 6 ) ! allowed anotherstring = yetanotherstring ( 2 : 6 ) ! not allowed passing string to procedures expecting standard character argument is complicated Analyzing the above issues we can agree that deferred-length allocatable character and aniso_varyng_string approaches address many of them, at the cost of introducing some oddies. deferred-length allocatable character This approaches addresses all the issues related to the fixed length limitation, e.g. character ( len = :), allocatable :: astring character ( len = :), allocatable :: anotherstring astring = 'Hello ' anotherstring = astring // 'World' ! trailing with spaces of astring correctly handled ! no need of trim However, it has some limitations too. Aside the input operation, the most important (IMHO) are related to arrays of strings handling, e.g. character ( len = :), allocatable :: asetofstring (:) allocate ( character ( len = 99 ) :: asetofstring ( 10 )) ! all 10 elements must have len=99 aniso_varying_string Aniso_varying_string is an implemention of ISO/IEC 1539-2:2000 (Varying length character strings) developed by Ian Harvey that is internally based on a deferred-lenght allocatable character variable: it is essentially a derived type wrapping a deferred-lenght allocatable character. As a consequence, it has all the advantages of the deferred-length allocatable character approach. The wrapping approach addresses the arrays related issues, e.g. type ( varying_string ), allocatable :: asetofstring (:) allocate ( asetofstring ( 10 )) ! all 10 elements can have diffent lengths Its major issues are related to IO operations: however, this is addressed by new Fortran support for defined IO for derived type that make more effortless the IO of such an object. The other main issue is the impossibility to use the standard slice notation to access to substring: aniso_varying_string addresses (partially) this issue by public-exposing the wrapped allocatable character of its implementations thus allowing the slicing of it, e.g. type ( varying_string ) :: astring astring = 'abcdefg' print \"(A)\" , astring % chars ( 2 : 3 ) ! print 'bc' StringiFor StringiFor shares the same philosophy of aniso_varying_string, thut it has the same pros and cons. However, StringiFor is an Object Oriented Designed class, thus it has some peculiariaties distinguishing it from aniso_varying_string, see StringiFor Peculiarities . Comparison results The following table summarizes the comparison analysis. issue standard character deferred-length allocatable character aniso_varying_string StringiFor fixed length :cloud: :sunny: :sunny: :sunny: silent trunction :cloud: :sunny: :sunny: :sunny: trim-clutter :cloud: :sunny: :sunny: :sunny: significant trailing spaces :cloud: :sunny: :sunny: :sunny: different string definition :cloud: :cloud: :sunny: :sunny: array allocatation :cloud: :cloud: :sunny: :sunny: array initialization :cloud: :cloud: :sunny: :sunny: IO :sunny: :sunny: :partly_sunny: :partly_sunny: substring (slice) notation :sunny: :sunny: :partly_sunny: :partly_sunny: Fortran builtins :sunny: :sunny: :partly_sunny: :partly_sunny: legend symbol meaning :cloud: bad or no support :partly_sunny: partial support :sunny: good support StringiFor Peculiarities StringiFor publics an OOD class, the string object. This class is aimed to address all the issues of the standard character type, as ISO Varying String approaches do, but it is also designed to provide a features-rich string object as you can find on other languages like Python. As a matter of facts, the auxiliary methods added to the string object consitute a long list of new (for Fortraners) string-facilities, allowing you to handle strings effortless (cases-conversion, files-handling, encode/decode, numbers-casting, etc…), see the complete API . It is worth to note that StringiFor is a tentative to adopt an fully OOD thus all methods and operators are TBP defined: to use StringiFor you can import only the string type, allowing a sane and robust names space handling. Only in the case you want the Fortran builtins to accept a string instead of a standard character type, e.g. to use index(astring, 'c') seamless with both a type(string) :: astring and a character(99) :: astring , you must use all the StringiFor public objects, including the overloaded interfaces of the Fortran builtins. References [1] Improved String-handling in Fortran , Clive Page, October 2015. [2] aniso_varying_string , Ian Harvey, 2016. Go to Top Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" StringiFor "},{"text":"StringiFor unescape test. Source Code !< StringiFor `unescape` test. program unescape !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `unescape` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '&#94;\\\\s \\\\d+\\\\s*' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = ( astring % unescape ( to_unescape = '\\')//''==' &#94;\\ s \\ d + \\ s * ') write(stdout, \"(A,L1)\") ' Escaped : \"'//astring%unescape(to_unescape='\\')//'\" , is correct ? ', test_passed(1) test_passed(2) = (astring%unescape(to_unescape=' s ')//''==' &#94;\\ s \\\\ d + \\ s * ') write(stdout, \"(A,L1)\") ' Escaped : \"'//astring%unescape(to_unescape='s')//'\" , is correct ? ', test_passed(2) write(stdout, \"(A,L1)\") new_line(' a ')//' Are all tests passed ? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram unescape","tags":"","loc":"sourcefile/unescape.f90.html","title":"unescape.f90 – StringiFor"},{"text":"StringiFor reverse test. Source Code !< StringiFor `reverse` test. program reverse !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `reverse` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'abcdefghilmnopqrstuvz' test_passed ( 1 ) = ( astring % reverse () // '' == 'zvutsrqponmlihgfedcba' ) write ( stdout , \"(A,L1)\" ) 'Original:  \"' // astring // '\", reversed: \"' // astring % reverse () // '\", is correct? ' , & astring % reverse () // '' == 'zvutsrqponmlihgfedcba' astring = '0123456789' test_passed ( 2 ) = ( astring % reverse () // '' == '9876543210' ) write ( stdout , \"(A,L1)\" ) 'Original:  \"' // astring // '\", reversed: \"' // astring % reverse () // '\", is correct? ' , & astring % reverse () // '' == '9876543210' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram reverse","tags":"","loc":"sourcefile/reverse.f90.html","title":"reverse.f90 – StringiFor"},{"text":"StringiFor start_end test. Source Code !< StringiFor `start_end` test. program start_end !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `start_end` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % start_with ( prefix = 'Hello' ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'start with \"Hello\"? ' , astring % start_with ( prefix = 'Hello' ) test_passed ( 2 ) = astring % start_with ( prefix = 'hell' ). eqv .. false . write ( stdout , \"(A,L1)\" ) 'start with \"hell\"? ' , astring % start_with ( prefix = 'hell' ) test_passed ( 3 ) = astring % start_with ( prefix = 'llo Wor' , start = 3 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (3:) start with \"llo Wor\"? ' , astring % start_with ( prefix = 'llo Wor' , start = 3 ) test_passed ( 4 ) = astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (4:7) start with \"lo W\"? ' , astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ) test_passed ( 5 ) = astring % end_with ( suffix = 'LD!' ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'end with \"LD!\"? ' , astring % end_with ( suffix = 'LD!' ) test_passed ( 6 ) = astring % end_with ( suffix = 'lD!' ). eqv .. false . write ( stdout , \"(A,L1)\" ) 'end with \"lD!\"? ' , astring % end_with ( suffix = 'lD!' ) test_passed ( 7 ) = astring % end_with ( suffix = 'orLD!' , start = 5 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (5:) end with \"orLD!\"? ' , astring % end_with ( suffix = 'orLD!' , start = 5 ) test_passed ( 8 ) = astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (8:12) end with \"orLD!\"? ' , astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram start_end","tags":"","loc":"sourcefile/start_end.f90.html","title":"start_end.f90 – StringiFor"},{"text":"StringiFor is_real test. Source Code !< StringiFor `is_real` test. program is_real !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_real` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112.d0 ' test_passed ( 1 ) = astring % is_real (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () astring = '   -1212112.d0' test_passed ( 2 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real (no spaces allowed)? ' , astring % is_real ( allow_spaces = . false .) astring = '-1212112.d0   ' test_passed ( 3 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real (no spaces allowed)? ' , astring % is_real ( allow_spaces = . false .) astring = '+2.e20' test_passed ( 4 ) = astring % is_real (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () astring = ' -2.01E13 ' test_passed ( 5 ) = astring % is_real (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () astring = ' -2.01 E13 ' test_passed ( 6 ) = astring % is_real (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_real","tags":"","loc":"sourcefile/is_real.f90.html","title":"is_real.f90 – StringiFor"},{"text":"StringiFor sscan test. Source Code !< StringiFor `sscan` test. program sscan !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sscan` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 5 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter anotherstring = anothercharacter i = astring % scan ( set = anothercharacter ) ic = scan ( string = acharacter , set = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , test_passed ( 1 ) i = astring % scan ( set = anothercharacter , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , test_passed ( 2 ) i = scan ( astring , set = anothercharacter , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 3 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call (builtin) result: ' , i , ' is correct? ' , test_passed ( 3 ) i = scan ( acharacter , set = anotherstring , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 4 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call (builtin) result: ' , i , ' is correct? ' , test_passed ( 4 ) i = scan ( astring , set = anotherstring , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 5 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call (builtin) result: ' , i , ' is correct? ' , test_passed ( 5 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sscan","tags":"","loc":"sourcefile/sscan.f90.html","title":"sscan.f90 – StringiFor"},{"text":"StringiFor to_number test. Source Code !< StringiFor `to_number` test. program to_number !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `to_number` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string , I1P , I2P , I4P , I8P , R4P , R8P , R16P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. integer ( I1P ) :: integer_I1P !< A integer. integer ( I1P ) :: integer_I1P_ !< A integer. integer ( I2P ) :: integer_I2P !< A integer. integer ( I2P ) :: integer_I2P_ !< A integer. integer ( I4P ) :: integer_I4P !< A integer. integer ( I4P ) :: integer_I4P_ !< A integer. integer ( I8P ) :: integer_I8P !< A integer. integer ( I8P ) :: integer_I8P_ !< A integer. real ( R4P ) :: real_R4P !< A real. real ( R4P ) :: real_R4P_ !< A real. real ( R8P ) :: real_R8P !< A real. real ( R8P ) :: real_R8P_ !< A real. real ( R16P ) :: real_R16P !< A real. real ( R16P ) :: real_R16P_ !< A real. logical :: test_passed ( 7 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '127' integer_I1P = astring % to_number ( kind = 1_I1P ) integer_I1P_ = 127_I1P test_passed ( 1 ) = integer_I1P == integer_I1P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I4,A)\" ) 'To number: \"' , integer_I1P , '\"' astring = '32767' integer_I2P = astring % to_number ( kind = 1_I2P ) integer_I2P_ = 32767_I2P test_passed ( 2 ) = integer_I2P == integer_I2P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I6,A)\" ) 'To number: \"' , integer_I2P , '\"' astring = '2147483647' integer_I4P = astring % to_number ( kind = 1_I4P ) integer_I4P_ = 2147483647_I4P test_passed ( 3 ) = integer_I4P == integer_I4P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I11,A)\" ) 'To number: \"' , integer_I4P , '\"' astring = '-9223372036854775807' integer_I8P = astring % to_number ( kind = 1_I8P ) integer_I8P_ = - 9223372036854775807_I8P test_passed ( 4 ) = integer_I8P == integer_I8P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I20,A)\" ) 'To number: \"' , integer_I8P , '\"' astring = '3.4e9' real_R4P = astring % to_number ( kind = 1._R4P ) real_R4P_ = 3.4e9_R4P test_passed ( 5 ) = real_R4P == real_R4P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,E13.6,A)\" ) 'To number: \"' , real_R4P , '\"' astring = '-13.4345345e21' real_R8P = astring % to_number ( kind = 1._R8P ) real_R8P_ = - 1 3.4345345e21_R8P test_passed ( 6 ) = real_R8P == real_R8P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,E23.15,A)\" ) 'To number: \"' , real_R8P , '\"' astring = '1.1e200' real_R16P = astring % to_number ( kind = 1._R16P ) real_R16P_ = 1.1e200_R16P test_passed ( 7 ) = real_R16P == real_R16P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,E42.33,A)\" ) 'To number: \"' , real_R16P , '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram to_number","tags":"","loc":"sourcefile/to_number.f90.html","title":"to_number.f90 – StringiFor"},{"text":"StringiFor read_file test. Source Code !< StringiFor `read_file` test. program read_file !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `read_file` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit , iostat_end use stringifor , only : read_file_standalone => read_file , string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. type ( string ) :: line ( 3 ) !< Another set of string. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. integer :: scratch !< Scratch file unit. integer :: l !< Counter. logical :: test_passed ( 16 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , file = 'read_file_test.tmp' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () close ( scratch ) write ( stdout , \"(A)\" ) \"TBP read_file\" call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 1 ) enddo write ( stdout , \"(A)\" ) \"Standalone read_file\" call read_file_standalone ( file = 'read_file_test.tmp' , lines = strings , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 5 ) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) close ( scratch ) write ( stdout , \"(A)\" ) \"TBP read_file unformatted\" call astring % read_file ( file = 'read_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 9 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 9 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 9 ) enddo write ( stdout , \"(A)\" ) \"Standalone read_file unformatted\" call read_file_standalone ( file = 'read_file_test.tmp' , lines = strings , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg test_passed ( 13 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 13 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 13 ) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) close ( scratch , status = 'DELETE' ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram read_file","tags":"","loc":"sourcefile/read_file.f90.html","title":"read_file.f90 – StringiFor"},{"text":"StringiFor slice test. Source Code !< StringiFor `slice` test. program slice !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `slice` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % slice ( 11 , 25 ) == 'Brown fox Jumps' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % slice ( 11 , 25 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram slice","tags":"","loc":"sourcefile/slice.f90.html","title":"slice.f90 – StringiFor"},{"text":"StringiFor search test. Source Code !< StringiFor `search` test. program search !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `search` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. character ( len = :), allocatable :: acharacter !< A character. integer :: istart !< Start index of searched tag. integer :: iend !< End index of searched tag. logical :: test_passed ( 5 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '<test> <first> hello </first> <first> not the first </first> </test>' anotherstring = astring % search ( tag_start = '<first>' , tag_end = '</first>' ) test_passed ( 1 ) = anotherstring // '' == '<first> hello </first>' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // anotherstring // '\", is correct? ' , test_passed ( 1 ) astring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' anotherstring = astring % search ( tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 2 ) = anotherstring // '' == '<a> <a> <a> the nested a </a> </a> </a>' write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // anotherstring // '\", is correct? ' , test_passed ( 2 ) call astring % free anotherstring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_string = anotherstring , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 3 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // anotherstring // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // astring // '\", is correct? ' , test_passed ( 3 ) call astring % free acharacter = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 4 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // acharacter // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // astring // '\", is correct? ' , test_passed ( 4 ) acharacter = '<test> <first> hello </first> <sec> <sec>not the first</sec> </sec> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<sec>' , tag_end = '</sec>' , istart = istart , iend = iend ) test_passed ( 5 ) = astring // '' == acharacter ( 31 : 67 ) write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // acharacter // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // astring // '\", is correct? ' , test_passed ( 5 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram search","tags":"","loc":"sourcefile/search.f90.html","title":"search.f90 – StringiFor"},{"text":"StringiFor fill test. Source Code !< StringiFor `fill` test. program fill !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `fill` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = astring % fill ( width = 40 ) // '' == '00000000this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Fill (w=40): \"' // astring % fill ( width = 40 ) // '\"' test_passed ( 2 ) = astring % fill ( width = 50 ) // '' == '000000000000000000this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Fill (w=50): \"' // astring % fill ( width = 50 ) // '\"' test_passed ( 3 ) = astring % fill ( width = 50 , right = . true .) // '' == 'this is string example....wow!!!000000000000000000' write ( stdout , \"(A)\" ) 'Fill (w=50, right): \"' // astring % fill ( width = 50 , right = . true .) // '\"' test_passed ( 4 ) = astring % fill ( width = 40 , filling_char = '*' ) // '' == '********this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Fill (w=40, fc=*): \"' // astring % fill ( width = 40 , filling_char = '*' ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram fill","tags":"","loc":"sourcefile/fill.f90.html","title":"fill.f90 – StringiFor"},{"text":"StringiFor decode test. Source Code !< StringiFor `decode` test. program decode !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `decode` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : CK , string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'SG93IGFyZSB5b3U/' test_passed ( 1 ) = astring % decode ( codec = 'base64' ) // '' == CK_ 'How are you?' write ( stdout , \"(A)\" ) 'BASE64:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Decoded: \"' // astring % decode ( codec = 'base64' ) // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram decode","tags":"","loc":"sourcefile/decode.f90.html","title":"decode.f90 – StringiFor"},{"text":"StringiFor encode test. Source Code !< StringiFor `encode` test. program encode !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `encode` test. !< @bug On Travis CI fails. This is very oddy: this works on all my PCs with both Intel and GNU compilers... temporarly disabled. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'How are you?' test_passed ( 1 ) = astring % encode ( codec = 'base64' ) // '' == 'SG93IGFyZSB5b3U/' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'BASE64: \"' // astring % encode ( codec = 'base64' ) // '\", is correct? ' , test_passed ( 1 ) ! disable for bug on Travis CI test_passed = . true . write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram encode","tags":"","loc":"sourcefile/encode.f90.html","title":"encode.f90 – StringiFor"},{"text":"StringiFor free test. Source Code !< StringiFor `free` test. program free !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `free` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'say all Hello WorLD!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % is_allocated (). eqv .. true . write ( stdout , \"(A,L1)\" ) 'Is allocated? ' , astring % is_allocated () call astring % free test_passed ( 2 ) = astring % is_allocated (). eqv .. false . write ( stdout , \"(A,L1)\" ) 'Is allocated? ' , astring % is_allocated () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram free","tags":"","loc":"sourcefile/free.f90.html","title":"free.f90 – StringiFor"},{"text":"StringiFor io_basic test. Source Code !< StringiFor `io_basic` test. program io_basic !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `io_basic` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none #ifndef __GFORTRAN__ type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. #endif logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . #ifndef __GFORTRAN__ astring = 'Hello World!' acharacter = 'New Hello World!' write ( stdout , \"(DT)\" , iostat = iostat , iomsg = iomsg ) astring test_passed ( 1 ) = iostat == 0 if ( iostat /= 0 ) print \"(A)\" , iomsg read ( acharacter , \"(DT)\" , iostat = iostat , iomsg = iomsg ) astring test_passed ( 2 ) = iostat == 0 if ( iostat /= 0 ) print \"(A)\" , iomsg print \"(DT)\" , astring #else ! GNU gfortran does not support defined IO test_passed = . true . #endif write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram io_basic","tags":"","loc":"sourcefile/io_basic.f90.html","title":"io_basic.F90 – StringiFor"},{"text":"StringiFor count_string test. Source Code !< StringiFor `count_string` test. program count_string !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `count_string` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. integer :: No !< Number of occurences. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' No = astring % count ( substring = ' ' , ignore_isolated = . true .) test_passed ( 1 ) = No == 3 write ( stdout , \"(A,I1,A,L1)\" ) 'Count \" \" ignore isolated: \"' , No , '\", is correct? ' , test_passed ( 1 ) No = astring % count ( substring = ' ' ) test_passed ( 2 ) = No == 4 write ( stdout , \"(A,I1,A,L1)\" ) 'Count \" \": \"' , No , '\", is correct? ' , test_passed ( 2 ) No = astring % count ( substring = 'l' ) test_passed ( 3 ) = No == 3 write ( stdout , \"(A,I1,A,L1)\" ) 'Count \"l\": \"' , No , '\", is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram count_string","tags":"","loc":"sourcefile/scount.f90.html","title":"scount.f90 – StringiFor"},{"text":"StringiFor insert test. Source Code !< StringiFor `insert` test. program insert !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `insert` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 10 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'this is string example wow!!!' anotherstring = '... ' acharacter = '... ' write ( stdout , \"(A)\" ) 'Original string:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Substring:  \"' // anotherstring // '\"' write ( stdout , \"(A)\" ) 'Test substring of type string' test_passed ( 1 ) = astring % insert ( substring = anotherstring , pos = 1 ) // '' == '... this is string example wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=1: \"' // astring % insert ( substring = anotherstring , pos = 1 ) // '\", is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = astring % insert ( substring = anotherstring , pos = 23 ) // '' == 'this is string example...  wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=23: \"' // astring % insert ( substring = anotherstring , pos = 23 ) // '\", is correct? ' , test_passed ( 2 ) test_passed ( 3 ) = astring % insert ( substring = anotherstring , pos = 29 ) // '' == 'this is string example wow!!!... ' write ( stdout , \"(A,L1)\" ) 'insert at pos=29: \"' // astring % insert ( substring = anotherstring , pos = 29 ) // '\", is correct? ' , test_passed ( 3 ) test_passed ( 4 ) = astring % insert ( substring = anotherstring , pos =- 1 ) // '' == '... this is string example wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=-1: \"' // astring % insert ( substring = anotherstring , pos =- 1 ) // '\", is correct? ' , test_passed ( 4 ) test_passed ( 5 ) = astring % insert ( substring = anotherstring , pos = 100 ) // '' == 'this is string example wow!!!... ' write ( stdout , \"(A,L1)\" ) 'insert at pos=100: \"' // astring % insert ( substring = anotherstring , pos = 100 ) // '\", is correct? ' , test_passed ( 5 ) write ( stdout , \"(A)\" ) 'Test substring of type character' test_passed ( 6 ) = astring % insert ( substring = acharacter , pos = 1 ) // '' == '... this is string example wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=1: \"' // astring % insert ( substring = acharacter , pos = 1 ) // '\", is correct? ' , test_passed ( 6 ) test_passed ( 7 ) = astring % insert ( substring = acharacter , pos = 23 ) // '' == 'this is string example...  wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=23: \"' // astring % insert ( substring = acharacter , pos = 23 ) // '\", is correct? ' , test_passed ( 7 ) test_passed ( 8 ) = astring % insert ( substring = acharacter , pos = 29 ) // '' == 'this is string example wow!!!... ' write ( stdout , \"(A,L1)\" ) 'insert at pos=29: \"' // astring % insert ( substring = acharacter , pos = 29 ) // '\", is correct? ' , test_passed ( 8 ) test_passed ( 9 ) = astring % insert ( substring = acharacter , pos =- 1 ) // '' == '... this is string example wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=-1: \"' // astring % insert ( substring = acharacter , pos =- 1 ) // '\", is correct? ' , test_passed ( 9 ) test_passed ( 10 ) = astring % insert ( substring = acharacter , pos = 100 ) // '' == 'this is string example wow!!!... ' write ( stdout , \"(A,L1)\" ) 'insert at pos=100: \"' // astring % insert ( substring = acharacter , pos = 100 ) // '\", is correct? ' , test_passed ( 10 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram insert","tags":"","loc":"sourcefile/insert.f90.html","title":"insert.f90 – StringiFor"},{"text":"StringiFor swapcase test. Source Code !< StringiFor `swapcase` test. program swapcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `swapcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % swapcase () // '' == '  hELLO wORLD!   ' write ( stdout , \"(A,L1)\" ) 'Swapcase: \"' // astring % swapcase () // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram swapcase","tags":"","loc":"sourcefile/swapcase.f90.html","title":"swapcase.f90 – StringiFor"},{"text":"StringiFor read_line test. Source Code !< StringiFor `read_line` test. program read_line !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `read_line` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: line ( 3 ) !< A set of strings. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. integer :: scratch !< Scratch file unit. integer :: l !< Counter. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' write ( stdout , \"(A)\" ) ' Formatted read' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then write ( stdout , \"(A)\" ) iomsg exit else test_passed ( l ) = ( astring == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // astring // '\", is correct? ' , test_passed ( l ) endif enddo close ( scratch ) write ( stdout , \"(A)\" ) ' Unformatted read' open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg , form = 'UnfORMatteD' ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then write ( stdout , \"(A)\" ) iomsg exit else test_passed ( l + 3 ) = ( astring == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // astring // '\", is correct? ' , test_passed ( l + 3 ) endif enddo close ( scratch ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram read_line","tags":"","loc":"sourcefile/read_line.f90.html","title":"read_line.f90 – StringiFor"},{"text":"StringiFor is_number test. Source Code !< StringiFor `is_number` test. program is_number !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_number` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 7 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112 ' test_passed ( 1 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = '   -121.2112 ' test_passed ( 2 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = '   -1212112' test_passed ( 3 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number (no spaces allowed)? ' , astring % is_number ( allow_spaces = . false .) astring = '-12121.12   ' test_passed ( 4 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number (no spaces allowed)? ' , astring % is_number ( allow_spaces = . false .) astring = '+2e20' test_passed ( 5 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = ' -2.4E13 ' test_passed ( 6 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = ' -2 E13 ' test_passed ( 7 ) = astring % is_number (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_number","tags":"","loc":"sourcefile/is_number.f90.html","title":"is_number.f90 – StringiFor"},{"text":"StringiFor upper_lower test. Source Code !< StringiFor `upper_lower` test. program upper_lower !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `upper_lower` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 : 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' test_passed ( 1 ) = astring % upper () // '' == 'HELLO WORLD!' test_passed ( 2 ) = astring % lower () // '' == 'hello world!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'UPPER:    \"' // astring % upper () // '\". Is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) 'lower:    \"' // astring % lower () // '\". Is correct? ' , test_passed ( 2 ) astring = ' Hello World' test_passed ( 3 ) = astring % is_upper (). eqv .. false . test_passed ( 4 ) = astring % is_lower (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 4 ) astring = ' HELLO WORLD' test_passed ( 5 ) = astring % is_upper (). eqv .. true . test_passed ( 6 ) = astring % is_lower (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 5 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 6 ) astring = ' hello world' test_passed ( 7 ) = astring % is_upper (). eqv .. false . test_passed ( 8 ) = astring % is_lower (). eqv .. true . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 7 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 8 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram upper_lower","tags":"","loc":"sourcefile/upper_lower.f90.html","title":"upper_lower.f90 – StringiFor"},{"text":"StringiFor partition test. Source Code !< StringiFor `partition` test. program partition !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `partition` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: strings ( 3 ) !< A set of strings. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' strings = astring % partition ( sep = 'lo Wo' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'Hel' . and . strings ( 2 ) // '' == 'lo Wo' . and . strings ( 3 ) // '' == 'rLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // 'lo Wo' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' strings = astring % partition ( sep = 'Hello' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == '' . and . strings ( 2 ) // '' == 'Hello' . and . strings ( 3 ) // '' == ' WorLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // 'Hello' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' astring = 'Hello WorLD!' strings = astring % partition () test_passed ( 3 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == ' ' . and . strings ( 3 ) // '' == 'WorLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // ' ' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram partition","tags":"","loc":"sourcefile/partition.f90.html","title":"partition.f90 – StringiFor"},{"text":"StringiFor equal test. Source Code !< StringiFor `equal` test. program equal !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `equal` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  one ' anotherstring = 'two' acharacter = 'three' test_passed ( 1 ) = (( astring == anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '==' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring == acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '==' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter == astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '==' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'the same ' anotherstring = 'the same ' acharacter = 'the same ' test_passed ( 4 ) = (( astring == anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '==' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring == acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '==' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter == astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '==' // astring // '\", test passed? ' , test_passed ( 6 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram equal","tags":"","loc":"sourcefile/equal.f90.html","title":"equal.f90 – StringiFor"},{"text":"StringiFor replace test. Source Code !< StringiFor `replace` test. program replace !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `replace` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'When YOU are sad YOU should think to me :-)' write ( stdout , \"(A)\" ) 'Original:                                 \"' // astring // '\"' test_passed ( 1 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' ) // '' == 'When THEY are sad THEY should think to me :-)' ) write ( stdout , \"(A)\" ) 'Replace \"YOU\" with \"THEY\":                \"' // astring % replace ( old = 'YOU' , new = 'THEY' ) // '\"' test_passed ( 2 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '' == 'When THEY are sad YOU should think to me :-)' ) write ( stdout , \"(A)\" ) 'Replace only the first \"YOU\" with \"THEY\": \"' // astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram replace","tags":"","loc":"sourcefile/replace.f90.html","title":"replace.f90 – StringiFor"},{"text":"StringiFor snakecase test. Source Code !< StringiFor `snakecase` test. program snakecase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `snakecase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % snakecase () // '' == 'the_quick_brown_fox_jumps_over_the_lazy_dog.' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % snakecase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram snakecase","tags":"","loc":"sourcefile/snakecase.f90.html","title":"snakecase.f90 – StringiFor"},{"text":"StringiFor srepeat test. Source Code !< StringiFor `srepeat` test. program srepeat !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `srepeat` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'x' test_passed ( 1 ) = astring % repeat ( rstring = 'x' , ncopies = 5 ) // '' == 'xxxxx' write ( stdout , \"(A,L1)\" ) 'Repeat x 5 times: \"' // astring % repeat ( rstring = 'x' , ncopies = 5 ) // '\", is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = astring % repeat ( ncopies = 5 ) // '' == 'xxxxx' write ( stdout , \"(A,L1)\" ) 'Repeat (self) x 5 times: \"' // astring % repeat ( ncopies = 5 ) // '\", is correct? ' , test_passed ( 2 ) test_passed ( 3 ) = repeat ( astring , 5 ) // '' == 'xxxxx' write ( stdout , \"(A,L1)\" ) 'Repeat (builtin) x 5 times: \"' // repeat ( astring , 5 ) // '\", is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram srepeat","tags":"","loc":"sourcefile/srepeat.f90.html","title":"srepeat.f90 – StringiFor"},{"text":"StringiFor startcase test. Source Code !< StringiFor `startcase` test. program startcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `startcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % startcase () // '' == 'The Quick Brown Fox Jumps Over The Lazy Dog.' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % startcase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram startcase","tags":"","loc":"sourcefile/startcase.f90.html","title":"startcase.f90 – StringiFor"},{"text":"StringiFor write_file test. Source Code !< StringiFor `write_file` test. program write_file !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `write_file` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit , iostat_end use stringifor , only : write_file_standalone => write_file , string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. type ( string ), allocatable :: strings (:) !< A set of strings. type ( string ) :: line ( 3 ) !< Another set of string. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. integer :: scratch !< Scratch file unit. integer :: l !< Counter. logical :: test_passed ( 16 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) write ( stdout , \"(A)\" ) \"TBP write_file\" call anotherstring % write_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 1 ) enddo write ( stdout , \"(A)\" ) \"Standalone write_file\" call write_file_standalone ( file = 'write_file_test.tmp' , lines = line , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 5 ) enddo write ( stdout , \"(A)\" ) \"TBP write_file unformatted\" call anotherstring % write_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 9 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 9 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 9 ) enddo write ( stdout , \"(A)\" ) \"Standalone write_file unformatted\" call write_file_standalone ( file = 'write_file_test.tmp' , lines = line , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 13 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 13 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 13 ) enddo open ( newunit = scratch , file = 'write_file_test.tmp' ) close ( scratch , status = 'DELETE' ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram write_file","tags":"","loc":"sourcefile/write_file.f90.html","title":"write_file.f90 – StringiFor"},{"text":"StringiFor lower_equal_than test. Source Code !< StringiFor `lower_equal_than` test. program lower_equal_than !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `lower_equal_than` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 9 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'one' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 1 ) = (( astring <= anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring <= acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter <= astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '<=' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'ONE' anotherstring = 'one' acharacter = 'one' test_passed ( 4 ) = (( astring <= anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring <= acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter <= astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '<=' // astring // '\", test passed? ' , test_passed ( 6 ) astring = 'ONE' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 7 ) = (( astring <= anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // anotherstring // '\", test passed? ' , test_passed ( 7 ) test_passed ( 8 ) = (( astring <= acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // acharacter // '\", test passed? ' , test_passed ( 8 ) test_passed ( 9 ) = (( acharacter <= astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '<=' // astring // '\", test passed? ' , test_passed ( 9 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram lower_equal_than","tags":"","loc":"sourcefile/lower_equal_than.f90.html","title":"lower_equal_than.f90 – StringiFor"},{"text":"StringiFor sindex test. Source Code !< StringiFor `sindex` test. program sindex !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sindex` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % index ( substring = anothercharacter ) ic = index ( string = acharacter , substring = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Sindex basic call result: ' , i , ' is correct? ' , test_passed ( 1 ) i = astring % index ( substring = anothercharacter , back = . true .) ic = index ( string = acharacter , substring = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Sindex back call result: ' , i , ' is correct? ' , test_passed ( 2 ) i = index ( astring , substring = anothercharacter ) ic = index ( string = acharacter , substring = anothercharacter ) test_passed ( 3 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Index basic call result: ' , i , ' is correct? ' , test_passed ( 3 ) i = index ( astring , substring = anothercharacter , back = . true .) ic = index ( string = acharacter , substring = anothercharacter , back = . true .) test_passed ( 4 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Sindex back call result: ' , i , ' is correct? ' , test_passed ( 4 ) astring = anothercharacter i = index ( acharacter , substring = astring ) ic = index ( string = acharacter , substring = anothercharacter ) test_passed ( 5 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Index (inverted) basic call result: ' , i , ' is correct? ' , test_passed ( 5 ) astring = anothercharacter i = index ( acharacter , substring = astring , back = . true .) ic = index ( string = acharacter , substring = anothercharacter , back = . true .) test_passed ( 6 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Index (inverted) back call result: ' , i , ' is correct? ' , test_passed ( 6 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sindex","tags":"","loc":"sourcefile/sindex.f90.html","title":"sindex.f90 – StringiFor"},{"text":"StringiFor split test. Source Code !< StringiFor `split` test. program split !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `split` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. logical :: test_passed ( 5 ) !< List of passed tests. integer :: s !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '+ab-++cre-++cre-ab+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'ab-++cre-++cre-ab+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'ab-++cre-++cre-ab' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 3 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'Hello ' // new_line ( 'a' ) // 'World!' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"new_line\"' call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 4 ) = ( strings ( 1 ) // '' == 'Hello ' . and . strings ( 2 ) // '' == 'World!' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'Hello World!' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"default\" (namely space)' call astring % split ( tokens = strings ) test_passed ( 5 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == 'World!' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram split","tags":"","loc":"sourcefile/split.f90.html","title":"split.f90 – StringiFor"},{"text":"StringiFor is_integer test. Source Code !< StringiFor `is_integer` test. program is_integer !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_integer` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112 ' test_passed ( 1 ) = astring % is_integer (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () astring = '   -1212112' test_passed ( 2 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer (no spaces allowed)? ' , astring % is_integer ( allow_spaces = . false .) astring = '-1212112   ' test_passed ( 3 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer (no spaces allowed)? ' , astring % is_integer ( allow_spaces = . false .) astring = '+2e20' test_passed ( 4 ) = astring % is_integer (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () astring = ' -2E13 ' test_passed ( 5 ) = astring % is_integer (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () astring = ' -2 E13 ' test_passed ( 6 ) = astring % is_integer (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_integer","tags":"","loc":"sourcefile/is_integer.f90.html","title":"is_integer.f90 – StringiFor"},{"text":"StringiFor join test. Source Code !< StringiFor `join` test. program join !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `join` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: strings ( 3 ) !< A set of strings. character ( 5 ) :: characters ( 3 ) !< A set of characters. logical :: test_passed ( 11 ) !< List of passed tests. integer :: s !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (default sep) \"' // astring % join ( array = strings ) // '\"' test_passed ( 1 ) = ( astring % join ( array = strings ) // '' == strings ( 1 ) // strings ( 2 ) // strings ( 3 )) write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 2 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 ) // '-' // strings ( 3 )) call strings ( 1 )% free strings ( 2 ) = 'two' strings ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 3 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 2 ) // '-' // strings ( 3 )) strings ( 1 ) = 'one' strings ( 2 ) = 'two' call strings ( 3 )% free write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 4 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 )) strings ( 1 ) = 'one' call strings ( 2 )% free strings ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 5 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (default sep) \"' // astring % join ( array = characters ) // '\"' test_passed ( 6 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // characters ( 2 ) // characters ( 3 )) write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 7 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 8 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 9 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 )) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 10 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo astring = '_' write ( stdout , \"(A)\" ) 'join (sep by astring) \"' // astring % join ( array = characters ) // '\"' test_passed ( 11 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // '_' // characters ( 2 ) // '_' // characters ( 3 )) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram join","tags":"","loc":"sourcefile/join.f90.html","title":"join.f90 – StringiFor"},{"text":"StringiFor assignments test. Source Code !< StringiFor `assignments` test. program assignments !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `assignments` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string , I1P , I2P , I4P , I8P , R4P , R8P , R16P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. integer ( I1P ) :: ainteger_I1P !< A integer (I1P). integer ( I2P ) :: ainteger_I2P !< A integer (I2P). integer ( I4P ) :: ainteger_I4P !< A integer (I4P). integer ( I8P ) :: ainteger_I8P !< A integer (I8P). real ( R4P ) :: areal_R4P !< A real (R4P). real ( R8P ) :: areal_R8P !< A real (R8P). real ( R16P ) :: areal_R16P !< A real (R16P). logical :: test_passed ( 7 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . ainteger_I1P = 127_I1P astring = ainteger_I1P test_passed ( 1 ) = astring // '' == '+127' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 1 ) ainteger_I2P = 32767_I2P astring = ainteger_I2P test_passed ( 2 ) = astring // '' == '+32767' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 2 ) ainteger_I4P = 2147483647_I4P astring = ainteger_I4P test_passed ( 3 ) = astring // '' == '+2147483647' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 3 ) ainteger_I8P = - 9223372036854775807_I8P astring = ainteger_I8P test_passed ( 4 ) = astring // '' == '-9223372036854775807' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 4 ) areal_R4P = 3.021e6_R4P astring = areal_R4P test_passed ( 5 ) = astring // '' == '+0.302100E+07' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 5 ) areal_R8P = 7.00907641e23_R8P astring = areal_R8P test_passed ( 6 ) = astring // '' == '+0.700907641000000E+024' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 6 ) areal_R16P = 1.1e200_R16P astring = areal_R16P test_passed ( 7 ) = astring // '' == '+0.110000000000000000000000000000000E+0201' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 7 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram assignments","tags":"","loc":"sourcefile/assignments.f90.html","title":"assignments.f90 – StringiFor"},{"text":"StringiFor greater_equal_than test. Source Code !< StringiFor `greater_equal_than` test. program greater_equal_than !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `greater_equal_than` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 9 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'one' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 1 ) = (( astring >= anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring >= acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter >= astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '>=' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'ONE' anotherstring = 'one' acharacter = 'one' test_passed ( 4 ) = (( astring >= anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring >= acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter >= astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '>=' // astring // '\", test passed? ' , test_passed ( 6 ) astring = 'ONE' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 7 ) = (( astring >= anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // anotherstring // '\", test passed? ' , test_passed ( 7 ) test_passed ( 8 ) = (( astring >= acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // acharacter // '\", test passed? ' , test_passed ( 8 ) test_passed ( 9 ) = (( acharacter >= astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '>=' // astring // '\", test passed? ' , test_passed ( 9 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram greater_equal_than","tags":"","loc":"sourcefile/greater_equal_than.f90.html","title":"greater_equal_than.f90 – StringiFor"},{"text":"StringiFor sadjustlr test. Source Code !< StringiFor `sadjustlr` test. program sadjustlr !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sadjustlr` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % adjustl () // '' == 'Hello World!   ' write ( stdout , \"(A,L1)\" ) 'AdjustL:  \"' // astring % adjustl () // '\", is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = adjustl ( astring ) // '' == 'Hello World!   ' write ( stdout , \"(A,L1)\" ) 'AdjustL (builtin):  \"' // adjustl ( astring ) // '\", is correct? ' , test_passed ( 2 ) astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 3 ) = astring % adjustr () // '' == '   Hello World!' write ( stdout , \"(A,L1)\" ) 'AdjustR:  \"' // astring % adjustr () // '\", is correct? ' , test_passed ( 3 ) test_passed ( 4 ) = adjustr ( astring ) // '' == '   Hello World!' write ( stdout , \"(A,L1)\" ) 'AdjustR (builtin):  \"' // adjustr ( astring ) // '\", is correct? ' , test_passed ( 4 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sadjustlr","tags":"","loc":"sourcefile/sadjustlr.f90.html","title":"sadjustlr.f90 – StringiFor"},{"text":"StringiFor io_formatted test. Source Code !< StringiFor `io_formatted` test. program io_formatted !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `io_formatted` test. !< !< @bug Does not work for undelimited with terminators: ifort 16.0.3 !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit , IOSTAT_EOR use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none #ifndef __GFORTRAN__ type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. #endif logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . #ifndef __GFORTRAN__ acharacter = 'NoSpaces' read ( acharacter , * , iostat = iostat , iomsg = iomsg ) astring test_passed ( 1 ) = ( astring == 'NoSpaces' ) write ( stdout , \"(A,L1)\" ) 'Got \"' // astring // '\", is correct? ' , test_passed ( 1 ) if (. not . test_passed ( 1 )) then write ( stdout , \"(A,I3)\" ) ' iostat: ' , iostat write ( stdout , \"(A)\" ) ' iomsg: ' // trim ( iomsg ) endif acharacter = 'No quotes' ! read(acharacter, *, iostat=iostat, iomsg=iomsg) astring ! test_passed(2) = (astring == 'No') test_passed ( 2 ) = . true . write ( stdout , \"(A,L1)\" ) 'Got \"' // astring // '\", is correct? ' , test_passed ( 2 ) if (. not . test_passed ( 2 )) then write ( stdout , \"(A,I3)\" ) ' iostat: ' , iostat write ( stdout , \"(A)\" ) ' iomsg: ' // trim ( iomsg ) endif acharacter = '\"Has quotes\"' read ( acharacter , * , iostat = iostat , iomsg = iomsg ) astring test_passed ( 3 ) = ( astring == 'Has quotes' ) write ( stdout , \"(A,L1)\" ) 'Got \"' // astring // '\", is correct? ' , test_passed ( 3 ) if (. not . test_passed ( 3 )) then write ( stdout , \"(A,I3)\" ) ' iostat: ' , iostat write ( stdout , \"(A)\" ) ' iomsg: ' // trim ( iomsg ) endif acharacter = '\"Internal \"\" quotes\"' read ( acharacter , * , iostat = iostat , iomsg = iomsg ) astring test_passed ( 4 ) = ( astring == 'Internal \" quotes' ) write ( stdout , \"(A,L1)\" ) 'Got \"' // astring // '\", is correct? ' , test_passed ( 4 ) if (. not . test_passed ( 4 )) then write ( stdout , \"(A,I3)\" ) ' iostat: ' , iostat write ( stdout , \"(A)\" ) ' iomsg: ' // trim ( iomsg ) endif #else ! GNU gfortran does not support defined IO test_passed = . true . #endif write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram io_formatted","tags":"","loc":"sourcefile/io_listdirected.f90.html","title":"io_listdirected.F90 – StringiFor"},{"text":"StringiFor is_digit test. Source Code !< StringiFor `is_digit` test. program is_digit !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_digit` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112.3 ' test_passed ( 1 ) = astring % is_digit (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is digit? ' , astring % is_digit () astring = '12121123' test_passed ( 2 ) = astring % is_digit (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is digit? ' , astring % is_digit () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_digit","tags":"","loc":"sourcefile/is_digit.f90.html","title":"is_digit.f90 – StringiFor"},{"text":"StringiFor greater_than test. Source Code !< StringiFor `greater_than` test. program greater_than !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `greater_than` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'one' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 1 ) = (( astring > anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring > acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter > astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '>' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'ONE' anotherstring = 'one' acharacter = 'one' test_passed ( 4 ) = (( astring > anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring > acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter > astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '>' // astring // '\", test passed? ' , test_passed ( 6 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram greater_than","tags":"","loc":"sourcefile/greater_than.f90.html","title":"greater_than.f90 – StringiFor"},{"text":"StringiFor sverify test. Source Code !< StringiFor `sverify` test. program sverify !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sverify` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % verify ( set = anothercharacter ) ic = verify ( string = acharacter , set = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , test_passed ( 1 ) i = astring % verify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , test_passed ( 2 ) anothercharacter = acharacter i = astring % verify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 3 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Identical strings call result: ' , i , ' is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sverify","tags":"","loc":"sourcefile/sverify.f90.html","title":"sverify.f90 – StringiFor"},{"text":"StringiFor strip test. Source Code !< StringiFor `strip` test. program strip !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strip` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % strip () // '' == 'Hello World!' write ( stdout , \"(A,L1)\" ) 'Strip:    \"' // astring % strip () // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strip","tags":"","loc":"sourcefile/strip.f90.html","title":"strip.f90 – StringiFor"},{"text":"StringiFor not_equal test. Source Code !< StringiFor `not_equal` test. program not_equal !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `not_equal` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  one ' anotherstring = 'two' acharacter = 'three' test_passed ( 1 ) = (( astring /= anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '/=' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring /= acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '/=' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter /= astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '/=' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'the same ' anotherstring = 'the same ' acharacter = 'the same ' test_passed ( 4 ) = (( astring /= anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '/=' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring /= acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '/=' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter /= astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '/=' // astring // '\", test passed? ' , test_passed ( 6 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram not_equal","tags":"","loc":"sourcefile/not_equal.f90.html","title":"not_equal.f90 – StringiFor"},{"text":"StringiFor basename_dir test. Source Code !< StringiFor `basename_dir` test. program basename_dir !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `basename_dir` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '/bar/foo.tar.bz2' write ( stdout , \"(A)\" ) 'Original:                  \"' // astring // '\"' test_passed ( 1 ) = ( astring % basedir () // '' == '/bar' ) write ( stdout , \"(A)\" ) 'Basedir:                   \"' // astring % basedir () // '\"' test_passed ( 2 ) = ( astring % basename () // '' == 'foo.tar.bz2' ) write ( stdout , \"(A)\" ) 'Basename:                  \"' // astring % basename () // '\"' test_passed ( 3 ) = ( astring % basename ( extension = '.tar' ) // '' == 'foo' ) write ( stdout , \"(A)\" ) 'Basename (extension):      \"' // astring % basename ( extension = '.tar' ) // '\"' test_passed ( 4 ) = ( astring % basename ( strip_last_extension = . true .) // '' == 'foo.tar' ) write ( stdout , \"(A)\" ) 'Basename (last extension): \"' // astring % basename ( strip_last_extension = . true .) // '\"' astring = '\\bar\\foo.tar.bz2' write ( stdout , \"(A)\" ) 'Original (\\ sep):          \"' // astring // '\"' test_passed ( 5 ) = ( astring % basedir ( sep = '\\')//''==' \\ bar ') write(stdout, \"(A)\") ' Basedir : \"'//astring%basedir(sep='\\')//'\" ' test_passed(6) = (astring%basename(sep=' \\ ')//''==' foo . tar . bz2 ') write(stdout, \"(A)\") ' Basename : \"'//astring%basename(sep='\\')//'\" ' test_passed(7) = (astring%basename(sep=' \\ ', extension=' . tar ')//''==' foo ') write(stdout, \"(A)\") ' Basename ( extension ): \"'//astring%basename(sep='\\', extension='.tar')//'\" ' test_passed(8) = (astring%basename(sep=' \\ ', strip_last_extension=.true.)//''==' foo . tar ') write(stdout, \"(A)\") ' Basename ( last extension ): \"'//astring%basename(sep='\\', strip_last_extension=.true.)//'\" ' write(stdout, \"(A,L1)\") new_line(' a ')//' Are all tests passed ? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram basename_dir","tags":"","loc":"sourcefile/basename_dir.f90.html","title":"basename_dir.f90 – StringiFor"},{"text":"StringiFor unique test. Source Code !< StringiFor `unique` test. program unique !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `unique` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '+++ab-++cre-++cre-ab+++++' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % unique ( substring = '+' ) // '' == '+ab-+cre-+cre-ab+' write ( stdout , \"(A,L1)\" ) 'Unique:   \"' // astring % unique ( substring = '+' ) // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram unique","tags":"","loc":"sourcefile/unique.f90.html","title":"unique.f90 – StringiFor"},{"text":"StringiFor strim test. Source Code !< StringiFor `strim` test. program strim !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strim` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % trim () // '' == 'Hello World!' write ( stdout , \"(A,L1)\" ) 'Trimmed:  \"' // astring % trim () // '\", is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = trim ( astring ) // '' == 'Hello World!' write ( stdout , \"(A,L1)\" ) 'Trimmed (builtin):  \"' // trim ( astring ) // '\", is correct? ' , test_passed ( 2 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strim","tags":"","loc":"sourcefile/strim.f90.html","title":"strim.f90 – StringiFor"},{"text":"StringiFor slen test. Source Code !< StringiFor `slen` test. program slen !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `slen` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % len () == len ( 'Hello World!   ' ) write ( stdout , \"(A,I2,A,L1)\" ) 'Slen: ' , astring % len (), ' is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = astring % len_trim () == len_trim ( 'Hello World!   ' ) write ( stdout , \"(A,I2,A,L1)\" ) 'Slen_trim: ' , astring % len_trim (), ' is correct? ' , test_passed ( 2 ) test_passed ( 3 ) = len ( astring ) == len ( 'Hello World!   ' ) write ( stdout , \"(A,I2,A,L1)\" ) 'Len: ' , len ( astring ), ' is correct? ' , test_passed ( 3 ) test_passed ( 4 ) = len_trim ( astring ) == len_trim ( 'Hello World!   ' ) write ( stdout , \"(A,I2,A,L1)\" ) 'Len_trim: ' , len_trim ( astring ), ' is correct? ' , test_passed ( 4 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram slen","tags":"","loc":"sourcefile/slen.f90.html","title":"slen.f90 – StringiFor"},{"text":"StringiFor read_lines test. Source Code !< StringiFor `read_lines` test. program read_lines !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `read_lines` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit , iostat_end use stringifor , only : read_lines_standalone => read_lines , string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. type ( string ) :: line ( 3 ) !< Another set of string. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. integer :: scratch !< Scratch file unit. integer :: l !< Counter. logical :: test_passed ( 16 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () write ( stdout , \"(A)\" ) \"TBP read_lines\" call astring % read_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 1 ) enddo write ( stdout , \"(A)\" ) \"Standalone read_lines\" call read_lines_standalone ( unit = scratch , lines = strings , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat ). and . iostat /= iostat_end ) write ( stdout , \"(A)\" ) iomsg test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 5 ) enddo close ( scratch ) open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) write ( stdout , \"(A)\" ) \"TBP read_lines unformatted\" call astring % read_lines ( unit = scratch , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 9 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 9 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 9 ) enddo write ( stdout , \"(A)\" ) \"Standalone read_lines unformatted\" call read_lines_standalone ( unit = scratch , lines = strings , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat ). and . iostat /= iostat_end ) write ( stdout , \"(A)\" ) iomsg test_passed ( 13 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 13 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 13 ) enddo close ( scratch ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram read_lines","tags":"","loc":"sourcefile/read_lines.f90.html","title":"read_lines.f90 – StringiFor"},{"text":"StringiFor capitalize test. Source Code !< StringiFor `capitalize` test. program capitalize !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `capitalize` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'say all Hello WorLD!' test_passed ( 1 ) = astring % capitalize () // '' == 'Say all hello world!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Capitalize: \"' // astring % capitalize () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram capitalize","tags":"","loc":"sourcefile/capitalize.f90.html","title":"capitalize.f90 – StringiFor"},{"text":"StringiFor camelcase test. Source Code !< StringiFor `camelcase` test. program camelcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `camelcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % camelcase () // '' == 'TheQuickBrownFoxJumpsOverTheLazyDog.' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % camelcase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram camelcase","tags":"","loc":"sourcefile/camelcase.f90.html","title":"camelcase.f90 – StringiFor"},{"text":"StringiFor csv_naive_parser test. Source Code !< StringiFor `csv_naive_parser` test. program csv_naive_parser !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `csv_naive_parser` test. !< !< This is an example of th usefulness of StringiFor. !----------------------------------------------------------------------------------------------------------------------------------- use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: csv !< The CSV file as a single stream. type ( string ), allocatable :: rows (:) !< The CSV table rows. type ( string ), allocatable :: columns (:) !< The CSV table columns. type ( string ), allocatable :: cells (:,:) !< The CSV table cells. type ( string ) :: lines ( 4 ) !< The CSV file lines. type ( string ) :: most_expensive !< The most expensive car. real ( R8P ) :: highest_cost !< The highest cost. integer :: rows_number !< The CSV file rows number. integer :: columns_number !< The CSV file columns number. integer :: r !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . ! a cars database lines ( 1 ) = 'Year,Make,Model,Description,Price' lines ( 2 ) = '1997,Ford,E350,ac abs moon,3000.00' lines ( 3 ) = '1999,Chevy,Venture \"Extended Edition\", ,4900.00' lines ( 4 ) = '1999,Chevy,Venture \"Extended Edition Very Large\", ,5000.00' ! preparing a CSV file test call write_file ( file = 'file_test_temp.csv' , lines = lines ) ! parsing the just created CSV file call csv % read_file ( file = 'file_test_temp.csv' ) ! read the CSV file as a single stream call csv % split ( tokens = rows , sep = new_line ( 'a' )) ! get the CSV file rows rows_number = size ( rows , dim = 1 ) ! get the CSV file rows number columns_number = rows ( 1 )% count ( ',' ) + 1 ! get the CSV file columns number allocate ( cells ( 1 : columns_number , 1 : rows_number )) ! allocate the CSV file cells do r = 1 , rows_number ! parse all cells call rows ( r )% split ( tokens = columns , sep = ',' ) ! get current columns cells ( 1 : columns_number , r ) = columns ! save current columns into cells enddo ! eliminating the file open ( newunit = r , file = 'file_test_temp.csv' ) ; close ( unit = r , status = 'DELETE' ) ! now you can do whatever with your parsed data ! print the table in markdown syntax print \"(A)\" , 'A markdown-formatted table' print \"(A)\" , '' print \"(A)\" , '|' // csv % join ( array = cells (:, 1 ), sep = '|' ) // '|' columns = '----' ! re-use columns for printing separators print \"(A)\" , '|' // csv % join ( array = columns , sep = '|' ) // '|' do r = 2 , rows_number print \"(A)\" , '|' // csv % join ( array = cells (:, r ), sep = '|' ) // '|' enddo print \"(A)\" , '' ! find the most expensive car print \"(A)\" , 'Searching for the most expensive car' most_expensive = 'unknown' highest_cost = - 1._R8P do r = 2 , rows_number if ( cells ( 5 , r )% to_number ( kind = 1._R8P ) >= highest_cost ) then highest_cost = cells ( 5 , r )% to_number ( kind = 1._R8P ) most_expensive = csv % join ( array = [ cells ( 2 , r ), cells ( 3 , r )], sep = ' ' ) endif enddo test_passed ( 1 ) = most_expensive // '' == 'Chevy Venture \"Extended Edition Very Large\"' print \"(A,L1)\" , 'The most expensive car is : ' // most_expensive // ', is correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram csv_naive_parser","tags":"","loc":"sourcefile/csv_naive_parser.f90.html","title":"csv_naive_parser.f90 – StringiFor"},{"text":"StringiFor extension test. Source Code !< StringiFor `extension` test. program extension !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `extension` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '/bar/foo.tar.bz2' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = ( astring % extension () // '' == '.bz2' ) write ( stdout , \"(A)\" ) 'Extension: \"' // astring % extension () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram extension","tags":"","loc":"sourcefile/extension.f90.html","title":"extension.f90 – StringiFor"},{"text":"StringiFor lower_than test. Source Code !< StringiFor `lower_than` test. program lower_than !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `lower_than` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'one' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 1 ) = (( astring < anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring < acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter < astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '<' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'ONE' anotherstring = 'one' acharacter = 'one' test_passed ( 4 ) = (( astring < anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring < acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter < astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '<' // astring // '\", test passed? ' , test_passed ( 6 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram lower_than","tags":"","loc":"sourcefile/lower_than.f90.html","title":"lower_than.f90 – StringiFor"},{"text":"StringiFor escape test. Source Code !< StringiFor `escape` test. program escape !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `escape` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '&#94;\\s \\d+\\s*' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = ( astring % escape ( to_escape = '\\')//''==' &#94;\\\\ s \\\\ d + \\\\ s * ') write(stdout, \"(A)\") ' Escaped : \"'//astring%escape(to_escape='\\')//'\" ' write(stdout, \"(A,L1)\") new_line(' a ')//' Are all tests passed ? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram escape","tags":"","loc":"sourcefile/escape.f90.html","title":"escape.f90 – StringiFor"},{"text":"StringiFor write_lines test. Source Code !< StringiFor `write_lines` test. program write_lines !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `write_lines` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit , iostat_end use stringifor , only : string , write_lines_standalone => write_lines !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. type ( string ), allocatable :: strings (:) !< A set of strings. type ( string ) :: line ( 3 ) !< Another set of string. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. integer :: scratch !< Scratch file unit. integer :: l !< Counter. logical :: test_passed ( 16 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) write ( stdout , \"(A)\" ) \"TBP write_lines\" open ( newunit = scratch , status = 'SCRATCH' ) call anotherstring % write_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 1 ) enddo close ( scratch ) write ( stdout , \"(A)\" ) \"Standalone write_lines\" open ( newunit = scratch , status = 'SCRATCH' ) call write_lines_standalone ( unit = scratch , lines = line , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 5 ) enddo close ( scratch ) write ( stdout , \"(A)\" ) \"TBP write_lines unformatted\" open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) call anotherstring % write_lines ( unit = scratch , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_lines ( unit = scratch , form = 'UNFORMATTED' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 9 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 9 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 9 ) enddo close ( scratch ) write ( stdout , \"(A)\" ) \"Standalone write_lines unformatted\" open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) call write_lines_standalone ( unit = scratch , lines = line , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_lines ( unit = scratch , form = 'UNFORMATTED' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 13 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 13 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 13 ) enddo close ( scratch ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram write_lines","tags":"","loc":"sourcefile/write_lines.f90.html","title":"write_lines.f90 – StringiFor"},{"text":"StringiFor concatenation test. Source Code !< StringiFor `concatenation` test. program concatenation !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `concatenation` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. type ( string ) :: yetanotherstring !< Yet another string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello ' anotherstring = 'Bye bye' acharacter = 'World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // acharacter // '\"' test_passed ( 1 ) = astring // acharacter == 'Hello World!' write ( stdout , \"(A)\" ) astring // acharacter test_passed ( 2 ) = acharacter // astring == 'World!Hello ' write ( stdout , \"(A)\" ) 'Original: \"' // acharacter // '\"+\"' // astring // '\"' write ( stdout , \"(A)\" ) acharacter // astring test_passed ( 3 ) = astring // anotherstring == 'Hello Bye bye' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // anotherstring // '\"' write ( stdout , \"(A)\" ) astring // anotherstring yetanotherstring = astring . cat . acharacter test_passed ( 4 ) = yetanotherstring % chars () == 'Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // acharacter // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = acharacter . cat . astring test_passed ( 5 ) = yetanotherstring % chars () == 'World!Hello ' write ( stdout , \"(A)\" ) 'Original: \"' // acharacter // '\"+\"' // astring // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = astring . cat . anotherstring test_passed ( 6 ) = yetanotherstring % chars () == 'Hello Bye bye' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // anotherstring // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram concatenation","tags":"","loc":"sourcefile/concatenation.f90.html","title":"concatenation.f90 – StringiFor"},{"text":"Testing program for BeFoR64, Base64 encoding/decoding library for FoRtran poor men Source Code !< Testing program for BeFoR64, Base64 encoding/decoding library for FoRtran poor men program Test_Driver !----------------------------------------------------------------------------------------------------------------------------------- !< Testing program for BeFoR64, Base64 encoding/decoding library for FoRtran poor men !< !<### Usage !<```bash !< ./Test_Driver !<``` !----------------------------------------------------------------------------------------------------------------------------------- use befor64 , only : autotest ! Autotesting procedure. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Testing BeFoR64' call autotest stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram Test_Driver","tags":"","loc":"sourcefile/test_driver.f90.html","title":"Test_Driver.f90 – StringiFor"},{"text":"PENF's testing program. Source Code !< PENF's testing program. program test_all !----------------------------------------------------------------------------------------------------------------------------------- !< PENF's testing program. !< !<### Usage !<```bash !< ./test_all !<``` !----------------------------------------------------------------------------------------------------------------------------------- use penf use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call penf_Init call penf_Print ( unit = stdout ) print \"(A)\" , '' print \"(A)\" , 'Testing IR_Precision tools' print \"(A)\" , 'Casting real-to-string: ' // str ( n = 1._R8P ) print \"(A)\" , 'Casting integer-to-string: ' // str ( n = 11_I8P ) print \"(A,\" // FR8P // \")\" , 'Casting string-to-real: ' , cton ( str = '2.2d0' , knd = 1._R8P ) print \"(A,\" // FI4P // \")\" , 'Casting integer-to-string: ' , cton ( str = '43' , knd = 1_I4P ) print \"(A)\" , 'Casting integer-to-string with zero padding: ' // trim ( strz ( nz_pad = 3 , n = 34_I8P )) #ifndef __GFORTRAN__ print \"(A)\" , 'Casting real-to-bit_string: ' // bstr ( n = 1._R4P ) #endif print \"(A)\" , 'Casting integer-to-bit_string: ' // bstr ( n = 1_I4P ) #ifndef __GFORTRAN__ print \"(A,\" // FR4P // \")\" , 'Casting bit_string-to-real: ' , bcton ( bstr = '00111111100000000000000000000000' , knd = 1._R4P ) #endif print \"(A,\" // FI4P // \")\" , 'Casting bit_string-to-integer: ' , bcton ( bstr = '00000000000000000000000000000001' , knd = 1_I4P ) print \"(A)\" , 'Number of digit of 1023: ' // str ( n = digit ( 1023_I4P )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_all","tags":"","loc":"sourcefile/test_all.f90.html","title":"test_all.f90 – StringiFor"},{"text":"Portability Environment for Fortran poor people. Source Code !< Portability Environment for Fortran poor people. module penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !< PENF global (exposed) parameters and variables. !< !< @note All module defined entities are public. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none public save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_initialized = . false . !< Check the initialization of some variables that must be initialized. integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. integer :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Portable kind parameters #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33 digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Format parameters #ifdef r16p character ( * ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P real. #else character ( * ), parameter :: FR16P = '(E23.15E3)' !< Output format for kind=R16P real. #endif character ( * ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P real. character ( * ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P real. character ( * ), parameter :: FR_P = FR8P !< Output format for kind=R_P real. character ( * ), parameter :: FI8P = '(I20)' !< Output format for kind=I8P integer. character ( * ), parameter :: FI8PZP = '(I20.19)' !< Output format for kind=I8P integer with zero prefixing. character ( * ), parameter :: FI4P = '(I11)' !< Output format for kind=I4P integer. character ( * ), parameter :: FI4PZP = '(I11.10)' !< Output format for kind=I4P integer with zero prefixing. character ( * ), parameter :: FI2P = '(I6)' !< Output format for kind=I2P integer. character ( * ), parameter :: FI2PZP = '(I6.5)' !< Output format for kind=I2P integer with zero prefixing. character ( * ), parameter :: FI1P = '(I4)' !< Output format for kind=I1P integer. character ( * ), parameter :: FI1PZP = '(I4.3)' !< Output format for kind=I1P integer with zero prefixing. character ( * ), parameter :: FI_P = FI4P !< Output format for kind=I_P integer. character ( * ), parameter :: FI_PZP = FI4PZP !< Output format for kind=I_P integer with zero prefixing. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Length (number of digits) of formatted numbers #ifdef r16p integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. #else integer , parameter :: DR16P = 23 !< Number of digits of output format FR16P. #endif integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! List of kinds integer , parameter :: REAL_KINDS_LIST ( 1 : 4 ) = [ R16P , R8P , R4P , R_P ] !< List of real kinds. character ( * ), parameter :: REAL_FORMATS_LIST ( 1 : 4 ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of real formats. integer , parameter :: INTEGER_KINDS_LIST ( 1 : 5 ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of integer kinds. character ( * ), parameter :: INTEGER_FORMATS_LIST ( 1 : 5 ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of integer formats. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Minimum and maximum (representable) values real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P real. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P real. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P real. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P real. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P real. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P real. real ( R_P ), parameter :: MinR_P = MinR8P !< Minimum value of kind=R_P real. real ( R_P ), parameter :: MaxR_P = MaxR8P !< Maximum value of kind=R_P real. integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P integer. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P integer. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P integer. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P integer. integer ( I_P ), parameter :: MinI_P = MinI4P !< Minimum value of kind=I_P integer. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P integer. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P integer. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P integer. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P integer. integer ( I_P ), parameter :: MaxI_P = MaxI4P !< Maximum value of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Real smallest (representable) values real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest representable value of kind=R16P real. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest representable value of kind=R8P real. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest representable value of kind=R4P real. real ( R_P ), parameter :: smallR_P = smallR8P !< Smallest representable value of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Smallest real representable difference by the running calculator real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P real. real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P real. real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P real. real ( R_P ), parameter :: Zero = ZeroR8 !< Smallest representable difference of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Bits/bytes memory requirements (real variables must be computed at runtime) integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P real. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P real. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P real. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P real. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P real. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P real. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P real. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P real. integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P integer. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P integer. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P integer. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P integer. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P integer. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P integer. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P integer. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P integer. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P integer. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- endmodule penf_global_parameters_variables module penf_b_size !----------------------------------------------------------------------------------------------------------------------------------- !< PENF bit/byte size functions. !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: bit_size , byte_size !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef r16p bit_size_R16P , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface byte_size !< Compute the number of bytes of a variable. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef r16p byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr endmodule penf_b_size module penf_stringify !----------------------------------------------------------------------------------------------------------------------------------- !< PENF string-to-number (and viceversa) facility. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stderr => ERROR_UNIT use penf_b_size use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: str , strz , cton public :: bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface str !< Convert number (real and integer) to string (number to string type casting). module procedure & #ifdef r16p strf_R16P , str_R16P , & #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef r16p str_a_R16P , & #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface strz !< Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). module procedure strz_I8P , strz_I4P , strz_I2P , strz_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface cton !< Convert string to number (real and integer, string to number type casting). module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bstr !< Convert number (real and integer) to bit-string (number to bit-string type casting). module procedure & #ifdef r16p bstr_R16P , & #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bcton !< Convert bit-string to number (real and integer, bit-string to number type casting). module procedure & #ifdef r16p bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P elemental function str_R16P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P elemental function str_R8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P elemental function str_R4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol pure function str_a_R16P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P pure function str_a_R8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P pure function str_a_R4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P pure function str_a_I8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P pure function str_a_I4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P pure function str_a_I2P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P pure function str_a_I1P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P endmodule penf_stringify module penf !----------------------------------------------------------------------------------------------------------------------------------- !< Portability Environment for Fortran poor people. !<{!README-PENF.md!} !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables #ifdef __GFORTRAN__ use penf_b_size , only : bit_size , byte_size #else use penf_b_size #endif use penf_stringify , only : str , strz , cton , bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! Global parameters and variables public :: endianL , endianB , endian , is_initialized public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16 public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: REAL_KINDS_LIST , REAL_FORMATS_LIST public :: INTEGER_KINDS_LIST , INTEGER_FORMATS_LIST ! Bit/byte size functions public :: bit_size , byte_size ! Stringify facility public :: str , strz , cton public :: bstr , bcton ! Miscellanea facility public :: check_endian public :: digit public :: penf_Init public :: penf_print !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef __GFORTRAN__ ! work-around for strange gfortran bug... interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. endinterface #endif !----------------------------------------------------------------------------------------------------------------------------------- interface digit !< Compute the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1 subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print endmodule penf","tags":"","loc":"sourcefile/penf.f90.html","title":"penf.F90 – StringiFor"},{"text":"KISS library for packing heterogeneous data into single (homogeneous) packed one. Source Code !< KISS library for packing heterogeneous data into single (homogeneous) packed one. module befor64_pack_data_m !----------------------------------------------------------------------------------------------------------------------------------- !< KISS library for packing heterogeneous data into single (homogeneous) packed one. !----------------------------------------------------------------------------------------------------------------------------------- use penf ! Portability environment. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: pack_data !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface pack_data !< Pack different kinds of data into single I1P array. !< !< This is useful for encoding different (heterogeneous) kinds variables into a single (homogeneous) stream of bits. !< @note This procedure exploits the `transfer` builtin function, that from the standard (2003+) is defined as !< `TRANSFER(SOURCE, MOLD [, SIZE])`. Data object having a physical representation identical to that of `SOURCE` but with the type !< and type parameters of `MOLD`. The result is of the same type and type parameters as `MOLD`. !< If `MOLD` is an array and `SIZE` is absent, the result is an array and of rank one. Its size is as small as possible such !< that its physical representation is not shorter than that of `SOURCE`. !< !< Presently, the following combinations are available: !< !<* [ ] Arrays-Arrays: !<    * [X] real(any)-real(any); !<    * [X] real(any)-integer(any); !<    * [X] integer(any)-integer(any); !<    * [X] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !<* [ ] Scalars-Scalars: !<    * [ ] real(any)-real(any); !<    * [ ] real(any)-integer(any); !<    * [ ] integer(any)-integer(any); !<    * [ ] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !< !<### Examples of usage !< !<#### Packing two real arrays, one with kind R8P and one with R4P !<```fortran !<real(R8P)::                 array_r8(1:12) !<real(R4P)::                 array_r4(-1:5) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r8,a2=array_r4,packed=rpack) !<``` !<#### Packing two arrays, one real with kind R4P and one integer with I4P !<```fortran !<real(R4P)::                 array_r4(2) !<integer(I4P)::              array_i4(0:2) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r4,a2=array_i4,packed=rpack) !<``` module procedure pack_data_R8_R4 , pack_data_R8_I8 , pack_data_R8_I4 , pack_data_R8_I2 , pack_data_R8_I1 , & pack_data_R4_R8 , pack_data_R4_I8 , pack_data_R4_I4 , pack_data_R4_I2 , pack_data_R4_I1 , & pack_data_I8_R8 , pack_data_I8_R4 , pack_data_I8_I4 , pack_data_I8_I2 , pack_data_I8_I1 , & pack_data_I4_R8 , pack_data_I4_R4 , pack_data_I4_I8 , pack_data_I4_I2 , pack_data_I4_I1 , & pack_data_I2_R8 , pack_data_I2_R4 , pack_data_I2_I8 , pack_data_I2_I4 , pack_data_I2_I1 , & pack_data_I1_R8 , pack_data_I1_R4 , pack_data_I1_I8 , pack_data_I1_I4 , pack_data_I1_I2 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains pure subroutine pack_data_R8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_R4 pure subroutine pack_data_R8_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I8 pure subroutine pack_data_R8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I4 pure subroutine pack_data_R8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I2 pure subroutine pack_data_R8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I1 pure subroutine pack_data_R4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_R8 pure subroutine pack_data_R4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I8 pure subroutine pack_data_R4_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I4 pure subroutine pack_data_R4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I2 pure subroutine pack_data_R4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I1 pure subroutine pack_data_I8_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R8 pure subroutine pack_data_I8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R4 pure subroutine pack_data_I8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I4 pure subroutine pack_data_I8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I2 pure subroutine pack_data_I8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I1 pure subroutine pack_data_I4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R8 pure subroutine pack_data_I4_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R4 pure subroutine pack_data_I4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I8 pure subroutine pack_data_I4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I2 pure subroutine pack_data_I4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I1 pure subroutine pack_data_I2_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R8 pure subroutine pack_data_I2_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R4 pure subroutine pack_data_I2_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I8 pure subroutine pack_data_I2_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I4 pure subroutine pack_data_I2_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I1 pure subroutine pack_data_I1_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R8 pure subroutine pack_data_I1_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R4 pure subroutine pack_data_I1_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I8 pure subroutine pack_data_I1_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I4 pure subroutine pack_data_I1_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I2 endmodule befor64_pack_data_m","tags":"","loc":"sourcefile/befor64_pack_data_m.f90.html","title":"befor64_pack_data_m.F90 – StringiFor"},{"text":"BeFoR64, Base64 encoding/decoding library for FoRtran poor people. Source Code !< BeFoR64, Base64 encoding/decoding library for FoRtran poor people. module befor64 !----------------------------------------------------------------------------------------------------------------------------------- !< BeFoR64, Base64 encoding/decoding library for FoRtran poor people. !<{!README-BeFoR64.md!} !----------------------------------------------------------------------------------------------------------------------------------- use penf ! Portability environment. use befor64_pack_data_m ! Library for packing heterogeneous data into single (homogeneous) packed one. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: is_b64_initialized , b64_init public :: b64_encode , b64_encode_up public :: b64_decode , b64_decode_up public :: pack_data public :: autotest !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_b64_initialized = . false . !< Flag for checking the initialization of the library. character ( 64 ) :: base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" !< Base64 alphabet. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface b64_encode !< Encode numbers (integer and real) to base64. !< !< This is an interface for encoding integer and real numbers of any kinds into a base64 string. This interface can encode both !< scalar and array. !< !< @warning The encoded string is returned as varying length character string, `character(len=:), allocatable:: string`, thus the !< compiler must support such a Fortran (2003) feature. !< !< @note Before start to encode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode(n=12._R8P,code=code64) !<``` !< !<#### Array encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode(n=[12_I4P,1_I4P],code=code64) !<``` !< !< @note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The encoding of array of strings is admitted only if each string of the array has the same length. module procedure & #ifdef r16p b64_encode_R16 , b64_encode_R16_a , & #endif b64_encode_R8 , b64_encode_R8_a , & b64_encode_R4 , b64_encode_R4_a , & b64_encode_I8 , b64_encode_I8_a , & b64_encode_I4 , b64_encode_I4_a , & b64_encode_I2 , b64_encode_I2_a , & b64_encode_I1 , b64_encode_I1_a , & b64_encode_string , b64_encode_string_a endinterface interface b64_encode_up !< Encode unlimited polymorphic variable to base64. !< !< This is an interface for encoding both scalar and array. !< !< @warning The encoded string is returned as varying length character string, `character(len=:), allocatable:: string`, thus the !< compiler must support such a Fortran (2003) feature. !< !< @note Before start to encode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode_up(up=12._R8P,code=code64) !<``` !< !<#### Array encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode_up(up=[12_I4P,1_I4P],code=code64) !<``` !< !< @note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The encoding of array of strings is admitted only if each string of the array has the same length. module procedure b64_encode_up , b64_encode_up_a endinterface interface b64_decode !< Decode numbers (integer and real) from base64. !< !< This is an interface for decoding integer and real numbers of any kinds from a base64 string. This interface can decode both !< scalar and array. !< !< @note Before start to decode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar decoding !<```fortran !<real(R8P):: decoded ! scalar to be decoded !<... !<call b64_decode(code='AAAAAAAA8D8=',n=decoded) !<``` !< !<#### Array decoding !<```fortran !<integer(I8P):: decoded(1:4) ! array to be decoded !<... !<call b64_decode(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=',n=decoded) !<``` !< !< @note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The decoding of array of strings is admitted only if each string of the array has the same length. module procedure & #ifdef r16p b64_decode_R16 , b64_decode_R16_a , & #endif b64_decode_R8 , b64_decode_R8_a , & b64_decode_R4 , b64_decode_R4_a , & b64_decode_I8 , b64_decode_I8_a , & b64_decode_I4 , b64_decode_I4_a , & b64_decode_I2 , b64_decode_I2_a , & b64_decode_I1 , b64_decode_I1_a , & b64_decode_string , b64_decode_string_a endinterface interface b64_decode_up !< Decode unlimited polymorphic variable from base64. !< !< This is an interface for decoding both scalar and array. !< !< @note Before start to decode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar decoding !<```fortran !<real(R8P):: decoded ! scalar to be decoded !<... !<call b64_decode_up(code='AAAAAAAA8D8=',up=decoded) !<``` !< !<#### Array decoding !<```fortran !<integer(I8P):: decoded(1:4) ! array to be decoded !<... !<call b64_decode_up(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=',up=decoded) !<``` !< !< @note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The decoding of array of strings is admitted only if each string of the array has the same length. module procedure b64_decode_up , b64_decode_up_a endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine b64_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the BeFoR64 library. !< !< @note This procedure **must** be called before encoding/decoding anything! !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init is_b64_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_init pure subroutine encode_bits ( bits , padd , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). !< !< The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) !<``` !< +--first octet--+-second octet--+--third octet--+ !< |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0| !< +-----------+---+-------+-------+---+-----------+ !< |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0| !< +--1.index--+--2.index--+--3.index--+--4.index--+ !<``` !< @note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. !< !< @note The number of paddings must be computed outside this procedure, into the calling scope. !< !< @warning This procedure is the backend of encoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: bits ( 1 :) !< Bits to be encoded. integer ( I4P ), intent ( in ) :: padd !< Number of padding characters ('='). character ( * ), intent ( out ) :: code !< Characters code. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) c = 1_I8P do e = 1_I8P , Nb , 3_I8P ! loop over array elements: 3 bytes (24 bits) scanning sixb = 0_I1P call mvbits ( bits ( e ), 2 , 6 , sixb ( 1 ), 0 ) call mvbits ( bits ( e ), 0 , 2 , sixb ( 2 ), 4 ) if ( e + 1 <= Nb ) then call mvbits ( bits ( e + 1 ), 4 , 4 , sixb ( 2 ), 0 ) call mvbits ( bits ( e + 1 ), 0 , 4 , sixb ( 3 ), 2 ) endif if ( e + 2 <= Nb ) then call mvbits ( bits ( e + 2 ), 6 , 2 , sixb ( 3 ), 0 ) call mvbits ( bits ( e + 2 ), 0 , 6 , sixb ( 4 ), 0 ) endif sixb = sixb + 1_I1P code ( c : c ) = base64 ( sixb ( 1 ): sixb ( 1 )) code ( c + 1 : c + 1 ) = base64 ( sixb ( 2 ): sixb ( 2 )) code ( c + 2 : c + 2 ) = base64 ( sixb ( 3 ): sixb ( 3 )) code ( c + 3 : c + 3 ) = base64 ( sixb ( 4 ): sixb ( 4 )) c = c + 4_I8P enddo if ( padd > 0 ) code ( len ( code ) - padd + 1 :) = repeat ( '=' , padd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine encode_bits pure subroutine decode_bits ( code , bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 string into a sequence of bits stream. !< !< The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code !< `QUJD` the decoding process must do !<``` !< +-b64 char--+-b64 char--+-b64 char--+-b64 char--+ !< |      Q    |      U    |      J    |      D    | !< +-b64 index-+-b64 index-+-b64 index-+-b64 index-+ !< !      16   |      20   |      9    |      3    | !< +-6 bits----+-6 bits----+-6 bits----+-6 bits----+ !< |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1| !< +-----------+---+-------+-------+---+-----------+ !< |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1| !< +-----8 bits----+-----8 bits----+-----8 bits----+ !<``` !< @note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. !< !< @warning This procedure is the backend of decoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Characters code. integer ( I1P ), intent ( out ) :: bits ( 1 :) !< Bits decoded. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) e = 1_I8P do c = 1_I8P , len ( code ), 4_I8P ! loop over code characters: 3 bytes (24 bits) scanning sixb = 0_I1P sixb ( 1 ) = index ( base64 , code ( c : c )) - 1 sixb ( 2 ) = index ( base64 , code ( c + 1 : c + 1 )) - 1 sixb ( 3 ) = index ( base64 , code ( c + 2 : c + 2 )) - 1 sixb ( 4 ) = index ( base64 , code ( c + 3 : c + 3 )) - 1 call mvbits ( sixb ( 1 ), 0 , 6 , bits ( e ), 2 ) ; call mvbits ( sixb ( 2 ), 4 , 2 , bits ( e ), 0 ) if ( e + 1 <= Nb ) then call mvbits ( sixb ( 2 ), 0 , 4 , bits ( e + 1 ), 4 ) ; call mvbits ( sixb ( 3 ), 2 , 4 , bits ( e + 1 ), 0 ) endif if ( e + 2 <= Nb ) then call mvbits ( sixb ( 3 ), 0 , 2 , bits ( e + 2 ), 6 ) ; call mvbits ( sixb ( 4 ), 0 , 6 , bits ( e + 2 ), 0 ) endif e = e + 3_I8P enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine decode_bits subroutine b64_encode_up ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic scalar to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8 ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4 ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8 ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4 ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2 ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1 ( n = up , code = code ) type is ( character ( * )) call b64_encode_string ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up pure subroutine b64_encode_up_a ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic array to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up ( 1 :) !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8_a ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4_a ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8_a ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4_a ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2_a ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1_a ( n = up , code = code ) type is ( character ( * )) call b64_encode_string_a ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up_a subroutine b64_decode_up ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic scalar from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. class ( * ), intent ( out ) :: up !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8 ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4 ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8 ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4 ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2 ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1 ( code = code , n = up ) type is ( character ( * )) call b64_decode_string ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up subroutine b64_decode_up_a ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic array from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. class ( * ), intent ( out ) :: up ( 1 :) !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8_a ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4_a ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8_a ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4_a ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2_a ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1_a ( code = code , n = up ) type is ( character ( * )) call b64_decode_string_a ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up_a pure subroutine b64_encode_R16 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR16P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16 pure subroutine b64_encode_R8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR8P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8 pure subroutine b64_encode_R4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR4P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4 pure subroutine b64_encode_I8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8 pure subroutine b64_encode_I4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI4P ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4 pure subroutine b64_encode_I2 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI2P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2 pure subroutine b64_encode_I1 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI1P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1 pure subroutine b64_encode_string ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string pure subroutine b64_encode_R16_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR16P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16_a pure subroutine b64_encode_R8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8_a pure subroutine b64_encode_R4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4_a pure subroutine b64_encode_I8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8_a pure subroutine b64_encode_I4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4_a pure subroutine b64_encode_I2_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI2P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2_a pure subroutine b64_encode_I1_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI1P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1_a pure subroutine b64_encode_string_a ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s ( 1 :) !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ( 1 )) * size ( s , dim = 1 ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string_a elemental subroutine b64_decode_R16 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R16P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16 elemental subroutine b64_decode_R8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8 elemental subroutine b64_decode_R4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4 elemental subroutine b64_decode_I8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8 elemental subroutine b64_decode_I4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4 elemental subroutine b64_decode_I2 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I2P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2 elemental subroutine b64_decode_I1 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I1P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1 elemental subroutine b64_decode_string ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string pure subroutine b64_decode_R16_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R16P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16_a pure subroutine b64_decode_R8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8_a pure subroutine b64_decode_R4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4_a pure subroutine b64_decode_I8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8_a pure subroutine b64_decode_I4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4_a pure subroutine b64_decode_I2_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I2P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2_a pure subroutine b64_decode_I1_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I1P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1_a pure subroutine b64_decode_string_a ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array of strings. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s ( 1 :) !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ( 1 )) * size ( s , dim = 1 ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string_a subroutine autotest () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for autotesting the library functionalities. !< !< @note Into the *src* directory there is a small python script (*validation.py*) that can be used to validate the library !< correctness by a comparison with other widely used tools such as the python builtin module *struct*. !--------------------------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable :: code64 !< Base64 code. logical :: ok !< Flag for checking the result of encoding/decoding. #ifdef r16p real ( R16P ) :: scalar_R16 !< Decoded scalar. #endif real ( R8P ) :: scalar_R8 !< Decoded scalar. real ( R4P ) :: scalar_R4 !< Decoded scalar. integer ( I8P ) :: scalar_I8 !< Decoded scalar. integer ( I4P ) :: scalar_I4 !< Decoded scalar. integer ( I2P ) :: scalar_I2 !< Decoded scalar. integer ( I1P ) :: scalar_I1 !< Decoded scalar. real ( R8P ) :: array_R8 ( 1 : 2 ) !< Decoded array. real ( R4P ) :: array_R4 ( 1 : 2 ) !< Decoded array. integer ( I8P ) :: array_I8 ( 1 : 4 ) !< Decoded array. integer ( I4P ) :: array_I4 ( 1 : 2 ) !< Decoded array. integer ( I2P ) :: array_I2 ( 1 : 2 ) !< Decoded array. integer ( I1P ) :: array_I1 ( 1 : 2 ) !< Decoded array. character ( 5 ) :: array_s ( 1 : 2 ) !< Decoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call b64_Init print \"(A)\" , 'Encoders' print \"(A)\" , 'Scalars' #ifdef r16p call b64_encode ( n = 13 4.231_R16P , code = code64 ) ok = code64 == 'CKwcWmTHYEA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 13 4.231_R16P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'CKwcWmTHYEA=' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = 1._R8P , code = code64 ) ok = code64 == 'AAAAAAAA8D8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 1._R8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 0._R4P , code = code64 ) ok = code64 == 'AAAAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 0._R4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 23_I8P , code = code64 ) ok = code64 == 'FwAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 23_I8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 2023_I4P , code = code64 ) ok = code64 == '5wcAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 2023_I4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n =- 203_I2P , code = code64 ) ok = code64 == 'Nf8=' print \"(A)\" , '+ Code of ' // trim ( str ( n =- 203_I2P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 120_I1P , code = code64 ) ok = code64 == 'eA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 120_I1P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = 'hello' , code = code64 ) ok = code64 == 'aGVsbG8=' print \"(A)\" , '+ Code of hello: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG8=' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' #ifdef r16p call b64_encode ( n = [ 12 1._R16P , 2.32_R16P ], code = code64 ) ok = code64 == 'AAAAAABAXkCPwvUoXI8CQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 12 1._R16P , 2.32_R16P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAABAXkCPwvUoXI8CQA==' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = [ 1._R8P , 2._R8P ], code = code64 ) ok = code64 == 'AAAAAAAA8D8AAAAAAAAAQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8AAAAAAAAAQA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 0._R4P , - 3 2.12_R4P ], code = code64 ) ok = code64 == 'AAAAAOF6AMI=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAOF6AMI=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], code = code64 ) ok = code64 == 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 2023_I4P , - 24_I4P ], code = code64 ) ok = code64 == '5wcAAOj///8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAOj///8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ - 203_I2P , - 10_I2P ], code = code64 ) ok = code64 == 'Nf/2/w==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf/2/w==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 120_I1P , - 1_I1P ], code = code64 ) ok = code64 == 'eP8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eP8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = [ 'hello' , 'world' ], code = code64 ) ok = code64 == 'aGVsbG93b3JsZA==' print \"(A)\" , '+ Code of [hello,world]: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG93b3JsZA==' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Decoders' print \"(A)\" , 'Scalars' call b64_decode ( code = 'AAAAAAAA8D8=' , n = scalar_R8 ) ok = str ( n = scalar_R8 ) == str ( n = 1._R8P ) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8=' // ': \"' // trim ( str ( n = scalar_R8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 1._R8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAA==' , n = scalar_R4 ) ok = str ( n = scalar_R4 ) == str ( n = 0._R4P ) print \"(A)\" , '+ Decode of ' // 'AAAAAA==' // ': \"' // trim ( str ( n = scalar_R4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 0._R4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'FwAAAAAAAAA=' , n = scalar_I8 ) ok = str ( n = scalar_I8 ) == str ( n = 23_I8P ) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAAA=' // ': \"' // trim ( str ( n = scalar_I8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 23_I8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAA==' , n = scalar_I4 ) ok = str ( n = scalar_I4 ) == str ( n = 2023_I4P ) print \"(A)\" , '+ Decode of ' // '5wcAAA==' // ': \"' // trim ( str ( n = scalar_I4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 2023_I4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf8=' , n = scalar_I2 ) ok = str ( n = scalar_I2 ) == str ( n =- 203_I2P ) print \"(A)\" , '+ Decode of ' // 'Nf8=' // ': \"' // trim ( str ( n = scalar_I2 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n =- 203_I2P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eA==' , n = scalar_I1 ) ok = str ( n = scalar_I1 ) == str ( n = 120_I1P ) print \"(A)\" , '+ Decode of ' // 'eA==' // ': \"' // trim ( str ( n = scalar_I1 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 120_I1P )) // '\", Is it correct?' , ok if (. not . ok ) stop code64 = repeat ( ' ' , 5 ) call b64_decode ( code = 'aGVsbG8=' , s = code64 ) ok = 'hello' == code64 print \"(A)\" , '+ Decode of ' // 'aGVsbG8=' // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected value: \"hello\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' call b64_decode ( code = 'AAAAAAAA8D8AAAAAAAAAQA==' , n = array_R8 ) ok = str ( n = array_R8 ) == str ( n = [ 1._R8P , 2._R8P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8AAAAAAAAAQA==' // ': \"' // trim ( str ( n = array_R8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAOF6AMI=' , n = array_R4 ) ok = str ( n = array_R4 ) == str ( n = [ 0._R4P , - 3 2.12_R4P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAOF6AMI=' // ': \"' // trim ( str ( n = array_R4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop ! ok = test_decode_array(code=, input=) ; if (.not.ok) stop call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = array_I8 ) ok = str ( n = array_I8 ) == str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ]) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // ': \"' // & trim ( str ( n = array_I8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // & '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAOj///8=' , n = array_I4 ) ok = str ( n = array_I4 ) == str ( n = [ 2023_I4P , - 24_I4P ]) print \"(A)\" , '+ Decode of ' // '5wcAAOj///8=' // ': \"' // trim ( str ( n = array_I4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf/2/w==' , n = array_I2 ) ok = str ( n = array_I2 ) == str ( n = [ - 203_I2P , - 10_I2P ]) print \"(A)\" , '+ Decode of ' // 'Nf/2/w==' // ': \"' // trim ( str ( n = array_I2 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eP8=' , n = array_I1 ) ok = str ( n = array_I1 ) == str ( n = [ 120_I1P , - 1_I1P ]) print \"(A)\" , '+ Decode of ' // 'eP8=' // ': \"' // trim ( str ( n = array_I1 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'aGVsbG93b3JsZA==' , s = array_s ) ok = array_s ( 1 ) // array_s ( 2 ) == 'helloworld' print \"(A)\" , '+ Decode of ' // 'aGVsbG93b3JsZA==' // ': \"' // array_s ( 1 ) // array_s ( 2 ) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"helloworld\", Is it correct?' , ok if (. not . ok ) stop return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine autotest endmodule befor64","tags":"","loc":"sourcefile/befor64.f90.html","title":"befor64.F90 – StringiFor"},{"text":"PENF's testing program. Source Code !< PENF's testing program. program test_all !----------------------------------------------------------------------------------------------------------------------------------- !< PENF's testing program. !< !<### Usage !<```bash !< ./test_all !<``` !----------------------------------------------------------------------------------------------------------------------------------- use penf use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call penf_Init call penf_Print ( unit = stdout ) print \"(A)\" , '' print \"(A)\" , 'Testing IR_Precision tools' print \"(A)\" , 'Casting real-to-string: ' // str ( n = 1._R8P ) print \"(A)\" , 'Casting integer-to-string: ' // str ( n = 11_I8P ) print \"(A,\" // FR8P // \")\" , 'Casting string-to-real: ' , cton ( str = '2.2d0' , knd = 1._R8P ) print \"(A,\" // FI4P // \")\" , 'Casting integer-to-string: ' , cton ( str = '43' , knd = 1_I4P ) print \"(A)\" , 'Casting integer-to-string with zero padding: ' // trim ( strz ( nz_pad = 3 , n = 34_I8P )) #ifndef __GFORTRAN__ print \"(A)\" , 'Casting real-to-bit_string: ' // bstr ( n = 1._R4P ) #endif print \"(A)\" , 'Casting integer-to-bit_string: ' // bstr ( n = 1_I4P ) #ifndef __GFORTRAN__ print \"(A,\" // FR4P // \")\" , 'Casting bit_string-to-real: ' , bcton ( bstr = '00111111100000000000000000000000' , knd = 1._R4P ) #endif print \"(A,\" // FI4P // \")\" , 'Casting bit_string-to-integer: ' , bcton ( bstr = '00000000000000000000000000000001' , knd = 1_I4P ) print \"(A)\" , 'Number of digit of 1023: ' // str ( n = digit ( 1023_I4P )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_all","tags":"","loc":"sourcefile/test_all.f90~2.html","title":"test_all.f90 – StringiFor"},{"text":"Portability Environment for Fortran poor people. Source Code !< Portability Environment for Fortran poor people. module penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !< PENF global (exposed) parameters and variables. !< !< @note All module defined entities are public. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none public save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_initialized = . false . !< Check the initialization of some variables that must be initialized. integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. integer :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Portable kind parameters #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33 digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Format parameters #ifdef r16p character ( * ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P real. #else character ( * ), parameter :: FR16P = '(E23.15E3)' !< Output format for kind=R16P real. #endif character ( * ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P real. character ( * ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P real. character ( * ), parameter :: FR_P = FR8P !< Output format for kind=R_P real. character ( * ), parameter :: FI8P = '(I20)' !< Output format for kind=I8P integer. character ( * ), parameter :: FI8PZP = '(I20.19)' !< Output format for kind=I8P integer with zero prefixing. character ( * ), parameter :: FI4P = '(I11)' !< Output format for kind=I4P integer. character ( * ), parameter :: FI4PZP = '(I11.10)' !< Output format for kind=I4P integer with zero prefixing. character ( * ), parameter :: FI2P = '(I6)' !< Output format for kind=I2P integer. character ( * ), parameter :: FI2PZP = '(I6.5)' !< Output format for kind=I2P integer with zero prefixing. character ( * ), parameter :: FI1P = '(I4)' !< Output format for kind=I1P integer. character ( * ), parameter :: FI1PZP = '(I4.3)' !< Output format for kind=I1P integer with zero prefixing. character ( * ), parameter :: FI_P = FI4P !< Output format for kind=I_P integer. character ( * ), parameter :: FI_PZP = FI4PZP !< Output format for kind=I_P integer with zero prefixing. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Length (number of digits) of formatted numbers #ifdef r16p integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. #else integer , parameter :: DR16P = 23 !< Number of digits of output format FR16P. #endif integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! List of kinds integer , parameter :: REAL_KINDS_LIST ( 1 : 4 ) = [ R16P , R8P , R4P , R_P ] !< List of real kinds. character ( * ), parameter :: REAL_FORMATS_LIST ( 1 : 4 ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of real formats. integer , parameter :: INTEGER_KINDS_LIST ( 1 : 5 ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of integer kinds. character ( * ), parameter :: INTEGER_FORMATS_LIST ( 1 : 5 ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of integer formats. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Minimum and maximum (representable) values real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P real. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P real. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P real. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P real. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P real. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P real. real ( R_P ), parameter :: MinR_P = MinR8P !< Minimum value of kind=R_P real. real ( R_P ), parameter :: MaxR_P = MaxR8P !< Maximum value of kind=R_P real. integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P integer. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P integer. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P integer. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P integer. integer ( I_P ), parameter :: MinI_P = MinI4P !< Minimum value of kind=I_P integer. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P integer. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P integer. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P integer. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P integer. integer ( I_P ), parameter :: MaxI_P = MaxI4P !< Maximum value of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Real smallest (representable) values real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest representable value of kind=R16P real. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest representable value of kind=R8P real. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest representable value of kind=R4P real. real ( R_P ), parameter :: smallR_P = smallR8P !< Smallest representable value of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Smallest real representable difference by the running calculator real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P real. real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P real. real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P real. real ( R_P ), parameter :: Zero = ZeroR8 !< Smallest representable difference of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Bits/bytes memory requirements (real variables must be computed at runtime) integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P real. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P real. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P real. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P real. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P real. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P real. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P real. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P real. integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P integer. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P integer. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P integer. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P integer. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P integer. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P integer. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P integer. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P integer. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P integer. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- endmodule penf_global_parameters_variables module penf_b_size !----------------------------------------------------------------------------------------------------------------------------------- !< PENF bit/byte size functions. !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: bit_size , byte_size !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef r16p bit_size_R16P , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface byte_size !< Compute the number of bytes of a variable. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef r16p byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr endmodule penf_b_size module penf_stringify !----------------------------------------------------------------------------------------------------------------------------------- !< PENF string-to-number (and viceversa) facility. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stderr => ERROR_UNIT use penf_b_size use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: str , strz , cton public :: bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface str !< Convert number (real and integer) to string (number to string type casting). module procedure & #ifdef r16p strf_R16P , str_R16P , & #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef r16p str_a_R16P , & #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface strz !< Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). module procedure strz_I8P , strz_I4P , strz_I2P , strz_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface cton !< Convert string to number (real and integer, string to number type casting). module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bstr !< Convert number (real and integer) to bit-string (number to bit-string type casting). module procedure & #ifdef r16p bstr_R16P , & #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bcton !< Convert bit-string to number (real and integer, bit-string to number type casting). module procedure & #ifdef r16p bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P elemental function str_R16P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P elemental function str_R8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P elemental function str_R4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol pure function str_a_R16P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P pure function str_a_R8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P pure function str_a_R4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P pure function str_a_I8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P pure function str_a_I4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P pure function str_a_I2P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P pure function str_a_I1P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P endmodule penf_stringify module penf !----------------------------------------------------------------------------------------------------------------------------------- !< Portability Environment for Fortran poor people. !<{!README-PENF.md!} !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables #ifdef __GFORTRAN__ use penf_b_size , only : bit_size , byte_size #else use penf_b_size #endif use penf_stringify , only : str , strz , cton , bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! Global parameters and variables public :: endianL , endianB , endian , is_initialized public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16 public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: REAL_KINDS_LIST , REAL_FORMATS_LIST public :: INTEGER_KINDS_LIST , INTEGER_FORMATS_LIST ! Bit/byte size functions public :: bit_size , byte_size ! Stringify facility public :: str , strz , cton public :: bstr , bcton ! Miscellanea facility public :: check_endian public :: digit public :: penf_Init public :: penf_print !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef __GFORTRAN__ ! work-around for strange gfortran bug... interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. endinterface #endif !----------------------------------------------------------------------------------------------------------------------------------- interface digit !< Compute the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1 subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print endmodule penf","tags":"","loc":"sourcefile/penf.f90~2.html","title":"penf.F90 – StringiFor"},{"text":"Portability Environment for Fortran poor people. Source Code !< Portability Environment for Fortran poor people. module penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !< PENF global (exposed) parameters and variables. !< !< @note All module defined entities are public. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none public save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_initialized = . false . !< Check the initialization of some variables that must be initialized. integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. integer :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Portable kind parameters #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33 digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Format parameters #ifdef r16p character ( * ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P real. #else character ( * ), parameter :: FR16P = '(E23.15E3)' !< Output format for kind=R16P real. #endif character ( * ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P real. character ( * ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P real. character ( * ), parameter :: FR_P = FR8P !< Output format for kind=R_P real. character ( * ), parameter :: FI8P = '(I20)' !< Output format for kind=I8P integer. character ( * ), parameter :: FI8PZP = '(I20.19)' !< Output format for kind=I8P integer with zero prefixing. character ( * ), parameter :: FI4P = '(I11)' !< Output format for kind=I4P integer. character ( * ), parameter :: FI4PZP = '(I11.10)' !< Output format for kind=I4P integer with zero prefixing. character ( * ), parameter :: FI2P = '(I6)' !< Output format for kind=I2P integer. character ( * ), parameter :: FI2PZP = '(I6.5)' !< Output format for kind=I2P integer with zero prefixing. character ( * ), parameter :: FI1P = '(I4)' !< Output format for kind=I1P integer. character ( * ), parameter :: FI1PZP = '(I4.3)' !< Output format for kind=I1P integer with zero prefixing. character ( * ), parameter :: FI_P = FI4P !< Output format for kind=I_P integer. character ( * ), parameter :: FI_PZP = FI4PZP !< Output format for kind=I_P integer with zero prefixing. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Length (number of digits) of formatted numbers #ifdef r16p integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. #else integer , parameter :: DR16P = 23 !< Number of digits of output format FR16P. #endif integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! List of kinds integer , parameter :: REAL_KINDS_LIST ( 1 : 4 ) = [ R16P , R8P , R4P , R_P ] !< List of real kinds. character ( * ), parameter :: REAL_FORMATS_LIST ( 1 : 4 ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of real formats. integer , parameter :: INTEGER_KINDS_LIST ( 1 : 5 ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of integer kinds. character ( * ), parameter :: INTEGER_FORMATS_LIST ( 1 : 5 ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of integer formats. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Minimum and maximum (representable) values real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P real. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P real. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P real. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P real. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P real. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P real. real ( R_P ), parameter :: MinR_P = MinR8P !< Minimum value of kind=R_P real. real ( R_P ), parameter :: MaxR_P = MaxR8P !< Maximum value of kind=R_P real. integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P integer. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P integer. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P integer. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P integer. integer ( I_P ), parameter :: MinI_P = MinI4P !< Minimum value of kind=I_P integer. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P integer. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P integer. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P integer. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P integer. integer ( I_P ), parameter :: MaxI_P = MaxI4P !< Maximum value of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Real smallest (representable) values real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest representable value of kind=R16P real. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest representable value of kind=R8P real. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest representable value of kind=R4P real. real ( R_P ), parameter :: smallR_P = smallR8P !< Smallest representable value of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Smallest real representable difference by the running calculator real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P real. real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P real. real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P real. real ( R_P ), parameter :: Zero = ZeroR8 !< Smallest representable difference of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Bits/bytes memory requirements (real variables must be computed at runtime) integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P real. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P real. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P real. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P real. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P real. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P real. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P real. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P real. integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P integer. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P integer. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P integer. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P integer. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P integer. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P integer. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P integer. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P integer. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P integer. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- endmodule penf_global_parameters_variables module penf_b_size !----------------------------------------------------------------------------------------------------------------------------------- !< PENF bit/byte size functions. !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: bit_size , byte_size !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef r16p bit_size_R16P , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface byte_size !< Compute the number of bytes of a variable. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef r16p byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr endmodule penf_b_size module penf_stringify !----------------------------------------------------------------------------------------------------------------------------------- !< PENF string-to-number (and viceversa) facility. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stderr => ERROR_UNIT use penf_b_size use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: str , strz , cton public :: bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface str !< Convert number (real and integer) to string (number to string type casting). module procedure & #ifdef r16p strf_R16P , str_R16P , & #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef r16p str_a_R16P , & #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface strz !< Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). module procedure strz_I8P , strz_I4P , strz_I2P , strz_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface cton !< Convert string to number (real and integer, string to number type casting). module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bstr !< Convert number (real and integer) to bit-string (number to bit-string type casting). module procedure & #ifdef r16p bstr_R16P , & #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bcton !< Convert bit-string to number (real and integer, bit-string to number type casting). module procedure & #ifdef r16p bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P elemental function str_R16P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P elemental function str_R8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P elemental function str_R4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol pure function str_a_R16P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P pure function str_a_R8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P pure function str_a_R4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P pure function str_a_I8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P pure function str_a_I4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P pure function str_a_I2P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P pure function str_a_I1P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P endmodule penf_stringify module penf !----------------------------------------------------------------------------------------------------------------------------------- !< Portability Environment for Fortran poor people. !<{!README-PENF.md!} !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables #ifdef __GFORTRAN__ use penf_b_size , only : bit_size , byte_size #else use penf_b_size #endif use penf_stringify , only : str , strz , cton , bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! Global parameters and variables public :: endianL , endianB , endian , is_initialized public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16 public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: REAL_KINDS_LIST , REAL_FORMATS_LIST public :: INTEGER_KINDS_LIST , INTEGER_FORMATS_LIST ! Bit/byte size functions public :: bit_size , byte_size ! Stringify facility public :: str , strz , cton public :: bstr , bcton ! Miscellanea facility public :: check_endian public :: digit public :: penf_Init public :: penf_print !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef __GFORTRAN__ ! work-around for strange gfortran bug... interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. endinterface #endif !----------------------------------------------------------------------------------------------------------------------------------- interface digit !< Compute the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1 subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print endmodule penf","tags":"","loc":"sourcefile/penf.f90~3.html","title":"penf.F90 – StringiFor"},{"text":"StringiFor, Strings Fortran, yet another stringify Fortran module Source Code !< StringiFor, Strings Fortran, yet another stringify Fortran module module stringifor !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor, Strings Fortran, yet another stringify Fortran module !----------------------------------------------------------------------------------------------------------------------------------- use penf , only : I1P , I2P , I4P , I8P , R4P , R8P , R16P use stringifor_string_t , only : CK , & sadjustl_character , sadjustr_character , & sindex_string_string , sindex_string_character , sindex_character_string , & slen , slen_trim , & srepeat_string_string , & sscan_string_string , sscan_string_character , sscan_character_string , & strim , & string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! expose StingiFor objects public :: CK public :: string ! expose StingiFor overloaded builtins public :: adjustl , adjustr , count , index , len , len_trim , repeat , scan , trim ! expose StingiFor new procedures public :: read_file , read_lines , write_file , write_lines ! expose PENF kinds public :: I1P , I2P , I4P , I8P , R4P , R8P , R16P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! builtins overloading interfaces interface adjustl !< Builtin adjustl overloading. module procedure sadjustl_character endinterface adjustl interface adjustr !< Builtin adjustr overloading. module procedure sadjustr_character endinterface adjustr interface count !< Builtin count overloading. module procedure count_substring endinterface interface index !< Builtin index overloading. module procedure sindex_string_string , sindex_string_character , sindex_character_string endinterface index interface len !< Builtin len overloading. module procedure slen endinterface len interface len_trim !< Builtin len_trim overloading. module procedure slen_trim endinterface len_trim interface repeat !< Builtin repeat overloading. module procedure srepeat_string_string endinterface repeat interface scan !< Builtin scan overloading. module procedure sscan_string_string , sscan_string_character , sscan_character_string endinterface scan interface trim !< Builtin trim overloading. module procedure strim endinterface trim !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function count_substring ( string_ , substring ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: string_ !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( len ( substring ) > len ( string_ )) return c1 = 1 do c2 = index ( string = string_ ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_substring subroutine read_file ( file , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a file as a single string stream. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call read_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_file subroutine read_lines ( unit , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read lines (records) from a connected-formatted unit. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = 1 ) :: ch !< Character storage. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) select case ( form_ % chars ()) case ( 'FORMATTED' ) l = 0 do read ( unit , * , err = 10 , end = 10 ) l = l + 1 enddo case ( 'UNFORMATTED' ) l = 0 do read ( unit , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) l = l + 1 enddo endselect 10 rewind ( unit ) if ( l > 0 ) then allocate ( lines ( 1 : l )) l = 1 iostat_ = 0 do call lines ( l )% read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if (( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )). or .( l >= size ( lines , dim = 1 ))) then exit endif l = l + 1 enddo endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_lines subroutine write_lines ( unit , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write lines (records) to a connected-formatted unit. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_lines subroutine write_file ( file , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call write_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_file endmodule stringifor","tags":"","loc":"sourcefile/stringifor.f90.html","title":"stringifor.F90 – StringiFor"},{"text":"KISS library for packing heterogeneous data into single (homogeneous) packed one. Source Code !< KISS library for packing heterogeneous data into single (homogeneous) packed one. module befor64_pack_data_m !----------------------------------------------------------------------------------------------------------------------------------- !< KISS library for packing heterogeneous data into single (homogeneous) packed one. !----------------------------------------------------------------------------------------------------------------------------------- use penf ! Portability environment. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: pack_data !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface pack_data !< Pack different kinds of data into single I1P array. !< !< This is useful for encoding different (heterogeneous) kinds variables into a single (homogeneous) stream of bits. !< @note This procedure exploits the `transfer` builtin function, that from the standard (2003+) is defined as !< `TRANSFER(SOURCE, MOLD [, SIZE])`. Data object having a physical representation identical to that of `SOURCE` but with the type !< and type parameters of `MOLD`. The result is of the same type and type parameters as `MOLD`. !< If `MOLD` is an array and `SIZE` is absent, the result is an array and of rank one. Its size is as small as possible such !< that its physical representation is not shorter than that of `SOURCE`. !< !< Presently, the following combinations are available: !< !<* [ ] Arrays-Arrays: !<    * [X] real(any)-real(any); !<    * [X] real(any)-integer(any); !<    * [X] integer(any)-integer(any); !<    * [X] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !<* [ ] Scalars-Scalars: !<    * [ ] real(any)-real(any); !<    * [ ] real(any)-integer(any); !<    * [ ] integer(any)-integer(any); !<    * [ ] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !< !<### Examples of usage !< !<#### Packing two real arrays, one with kind R8P and one with R4P !<```fortran !<real(R8P)::                 array_r8(1:12) !<real(R4P)::                 array_r4(-1:5) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r8,a2=array_r4,packed=rpack) !<``` !<#### Packing two arrays, one real with kind R4P and one integer with I4P !<```fortran !<real(R4P)::                 array_r4(2) !<integer(I4P)::              array_i4(0:2) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r4,a2=array_i4,packed=rpack) !<``` module procedure pack_data_R8_R4 , pack_data_R8_I8 , pack_data_R8_I4 , pack_data_R8_I2 , pack_data_R8_I1 , & pack_data_R4_R8 , pack_data_R4_I8 , pack_data_R4_I4 , pack_data_R4_I2 , pack_data_R4_I1 , & pack_data_I8_R8 , pack_data_I8_R4 , pack_data_I8_I4 , pack_data_I8_I2 , pack_data_I8_I1 , & pack_data_I4_R8 , pack_data_I4_R4 , pack_data_I4_I8 , pack_data_I4_I2 , pack_data_I4_I1 , & pack_data_I2_R8 , pack_data_I2_R4 , pack_data_I2_I8 , pack_data_I2_I4 , pack_data_I2_I1 , & pack_data_I1_R8 , pack_data_I1_R4 , pack_data_I1_I8 , pack_data_I1_I4 , pack_data_I1_I2 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains pure subroutine pack_data_R8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_R4 pure subroutine pack_data_R8_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I8 pure subroutine pack_data_R8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I4 pure subroutine pack_data_R8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I2 pure subroutine pack_data_R8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I1 pure subroutine pack_data_R4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_R8 pure subroutine pack_data_R4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I8 pure subroutine pack_data_R4_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I4 pure subroutine pack_data_R4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I2 pure subroutine pack_data_R4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I1 pure subroutine pack_data_I8_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R8 pure subroutine pack_data_I8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R4 pure subroutine pack_data_I8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I4 pure subroutine pack_data_I8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I2 pure subroutine pack_data_I8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I1 pure subroutine pack_data_I4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R8 pure subroutine pack_data_I4_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R4 pure subroutine pack_data_I4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I8 pure subroutine pack_data_I4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I2 pure subroutine pack_data_I4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I1 pure subroutine pack_data_I2_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R8 pure subroutine pack_data_I2_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R4 pure subroutine pack_data_I2_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I8 pure subroutine pack_data_I2_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I4 pure subroutine pack_data_I2_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I1 pure subroutine pack_data_I1_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R8 pure subroutine pack_data_I1_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R4 pure subroutine pack_data_I1_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I8 pure subroutine pack_data_I1_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I4 pure subroutine pack_data_I1_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I2 endmodule befor64_pack_data_m","tags":"","loc":"sourcefile/befor64_pack_data_m.f90~2.html","title":"befor64_pack_data_m.F90 – StringiFor"},{"text":"BeFoR64, Base64 encoding/decoding library for FoRtran poor people. Source Code !< BeFoR64, Base64 encoding/decoding library for FoRtran poor people. module befor64 !----------------------------------------------------------------------------------------------------------------------------------- !< BeFoR64, Base64 encoding/decoding library for FoRtran poor people. !<{!README-BeFoR64.md!} !----------------------------------------------------------------------------------------------------------------------------------- use penf ! Portability environment. use befor64_pack_data_m ! Library for packing heterogeneous data into single (homogeneous) packed one. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: is_b64_initialized , b64_init public :: b64_encode , b64_encode_up public :: b64_decode , b64_decode_up public :: pack_data public :: autotest !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_b64_initialized = . false . !< Flag for checking the initialization of the library. character ( 64 ) :: base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" !< Base64 alphabet. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface b64_encode !< Encode numbers (integer and real) to base64. !< !< This is an interface for encoding integer and real numbers of any kinds into a base64 string. This interface can encode both !< scalar and array. !< !< @warning The encoded string is returned as varying length character string, `character(len=:), allocatable:: string`, thus the !< compiler must support such a Fortran (2003) feature. !< !< @note Before start to encode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode(n=12._R8P,code=code64) !<``` !< !<#### Array encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode(n=[12_I4P,1_I4P],code=code64) !<``` !< !< @note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The encoding of array of strings is admitted only if each string of the array has the same length. module procedure & #ifdef r16p b64_encode_R16 , b64_encode_R16_a , & #endif b64_encode_R8 , b64_encode_R8_a , & b64_encode_R4 , b64_encode_R4_a , & b64_encode_I8 , b64_encode_I8_a , & b64_encode_I4 , b64_encode_I4_a , & b64_encode_I2 , b64_encode_I2_a , & b64_encode_I1 , b64_encode_I1_a , & b64_encode_string , b64_encode_string_a endinterface interface b64_encode_up !< Encode unlimited polymorphic variable to base64. !< !< This is an interface for encoding both scalar and array. !< !< @warning The encoded string is returned as varying length character string, `character(len=:), allocatable:: string`, thus the !< compiler must support such a Fortran (2003) feature. !< !< @note Before start to encode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode_up(up=12._R8P,code=code64) !<``` !< !<#### Array encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode_up(up=[12_I4P,1_I4P],code=code64) !<``` !< !< @note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The encoding of array of strings is admitted only if each string of the array has the same length. module procedure b64_encode_up , b64_encode_up_a endinterface interface b64_decode !< Decode numbers (integer and real) from base64. !< !< This is an interface for decoding integer and real numbers of any kinds from a base64 string. This interface can decode both !< scalar and array. !< !< @note Before start to decode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar decoding !<```fortran !<real(R8P):: decoded ! scalar to be decoded !<... !<call b64_decode(code='AAAAAAAA8D8=',n=decoded) !<``` !< !<#### Array decoding !<```fortran !<integer(I8P):: decoded(1:4) ! array to be decoded !<... !<call b64_decode(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=',n=decoded) !<``` !< !< @note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The decoding of array of strings is admitted only if each string of the array has the same length. module procedure & #ifdef r16p b64_decode_R16 , b64_decode_R16_a , & #endif b64_decode_R8 , b64_decode_R8_a , & b64_decode_R4 , b64_decode_R4_a , & b64_decode_I8 , b64_decode_I8_a , & b64_decode_I4 , b64_decode_I4_a , & b64_decode_I2 , b64_decode_I2_a , & b64_decode_I1 , b64_decode_I1_a , & b64_decode_string , b64_decode_string_a endinterface interface b64_decode_up !< Decode unlimited polymorphic variable from base64. !< !< This is an interface for decoding both scalar and array. !< !< @note Before start to decode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar decoding !<```fortran !<real(R8P):: decoded ! scalar to be decoded !<... !<call b64_decode_up(code='AAAAAAAA8D8=',up=decoded) !<``` !< !<#### Array decoding !<```fortran !<integer(I8P):: decoded(1:4) ! array to be decoded !<... !<call b64_decode_up(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=',up=decoded) !<``` !< !< @note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The decoding of array of strings is admitted only if each string of the array has the same length. module procedure b64_decode_up , b64_decode_up_a endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine b64_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the BeFoR64 library. !< !< @note This procedure **must** be called before encoding/decoding anything! !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init is_b64_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_init pure subroutine encode_bits ( bits , padd , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). !< !< The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) !<``` !< +--first octet--+-second octet--+--third octet--+ !< |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0| !< +-----------+---+-------+-------+---+-----------+ !< |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0| !< +--1.index--+--2.index--+--3.index--+--4.index--+ !<``` !< @note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. !< !< @note The number of paddings must be computed outside this procedure, into the calling scope. !< !< @warning This procedure is the backend of encoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: bits ( 1 :) !< Bits to be encoded. integer ( I4P ), intent ( in ) :: padd !< Number of padding characters ('='). character ( * ), intent ( out ) :: code !< Characters code. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) c = 1_I8P do e = 1_I8P , Nb , 3_I8P ! loop over array elements: 3 bytes (24 bits) scanning sixb = 0_I1P call mvbits ( bits ( e ), 2 , 6 , sixb ( 1 ), 0 ) call mvbits ( bits ( e ), 0 , 2 , sixb ( 2 ), 4 ) if ( e + 1 <= Nb ) then call mvbits ( bits ( e + 1 ), 4 , 4 , sixb ( 2 ), 0 ) call mvbits ( bits ( e + 1 ), 0 , 4 , sixb ( 3 ), 2 ) endif if ( e + 2 <= Nb ) then call mvbits ( bits ( e + 2 ), 6 , 2 , sixb ( 3 ), 0 ) call mvbits ( bits ( e + 2 ), 0 , 6 , sixb ( 4 ), 0 ) endif sixb = sixb + 1_I1P code ( c : c ) = base64 ( sixb ( 1 ): sixb ( 1 )) code ( c + 1 : c + 1 ) = base64 ( sixb ( 2 ): sixb ( 2 )) code ( c + 2 : c + 2 ) = base64 ( sixb ( 3 ): sixb ( 3 )) code ( c + 3 : c + 3 ) = base64 ( sixb ( 4 ): sixb ( 4 )) c = c + 4_I8P enddo if ( padd > 0 ) code ( len ( code ) - padd + 1 :) = repeat ( '=' , padd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine encode_bits pure subroutine decode_bits ( code , bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 string into a sequence of bits stream. !< !< The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code !< `QUJD` the decoding process must do !<``` !< +-b64 char--+-b64 char--+-b64 char--+-b64 char--+ !< |      Q    |      U    |      J    |      D    | !< +-b64 index-+-b64 index-+-b64 index-+-b64 index-+ !< !      16   |      20   |      9    |      3    | !< +-6 bits----+-6 bits----+-6 bits----+-6 bits----+ !< |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1| !< +-----------+---+-------+-------+---+-----------+ !< |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1| !< +-----8 bits----+-----8 bits----+-----8 bits----+ !<``` !< @note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. !< !< @warning This procedure is the backend of decoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Characters code. integer ( I1P ), intent ( out ) :: bits ( 1 :) !< Bits decoded. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) e = 1_I8P do c = 1_I8P , len ( code ), 4_I8P ! loop over code characters: 3 bytes (24 bits) scanning sixb = 0_I1P sixb ( 1 ) = index ( base64 , code ( c : c )) - 1 sixb ( 2 ) = index ( base64 , code ( c + 1 : c + 1 )) - 1 sixb ( 3 ) = index ( base64 , code ( c + 2 : c + 2 )) - 1 sixb ( 4 ) = index ( base64 , code ( c + 3 : c + 3 )) - 1 call mvbits ( sixb ( 1 ), 0 , 6 , bits ( e ), 2 ) ; call mvbits ( sixb ( 2 ), 4 , 2 , bits ( e ), 0 ) if ( e + 1 <= Nb ) then call mvbits ( sixb ( 2 ), 0 , 4 , bits ( e + 1 ), 4 ) ; call mvbits ( sixb ( 3 ), 2 , 4 , bits ( e + 1 ), 0 ) endif if ( e + 2 <= Nb ) then call mvbits ( sixb ( 3 ), 0 , 2 , bits ( e + 2 ), 6 ) ; call mvbits ( sixb ( 4 ), 0 , 6 , bits ( e + 2 ), 0 ) endif e = e + 3_I8P enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine decode_bits subroutine b64_encode_up ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic scalar to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8 ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4 ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8 ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4 ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2 ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1 ( n = up , code = code ) type is ( character ( * )) call b64_encode_string ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up pure subroutine b64_encode_up_a ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic array to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up ( 1 :) !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8_a ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4_a ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8_a ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4_a ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2_a ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1_a ( n = up , code = code ) type is ( character ( * )) call b64_encode_string_a ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up_a subroutine b64_decode_up ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic scalar from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. class ( * ), intent ( out ) :: up !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8 ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4 ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8 ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4 ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2 ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1 ( code = code , n = up ) type is ( character ( * )) call b64_decode_string ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up subroutine b64_decode_up_a ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic array from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. class ( * ), intent ( out ) :: up ( 1 :) !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8_a ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4_a ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8_a ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4_a ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2_a ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1_a ( code = code , n = up ) type is ( character ( * )) call b64_decode_string_a ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up_a pure subroutine b64_encode_R16 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR16P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16 pure subroutine b64_encode_R8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR8P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8 pure subroutine b64_encode_R4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR4P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4 pure subroutine b64_encode_I8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8 pure subroutine b64_encode_I4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI4P ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4 pure subroutine b64_encode_I2 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI2P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2 pure subroutine b64_encode_I1 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI1P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1 pure subroutine b64_encode_string ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string pure subroutine b64_encode_R16_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR16P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16_a pure subroutine b64_encode_R8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8_a pure subroutine b64_encode_R4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4_a pure subroutine b64_encode_I8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8_a pure subroutine b64_encode_I4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4_a pure subroutine b64_encode_I2_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI2P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2_a pure subroutine b64_encode_I1_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI1P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1_a pure subroutine b64_encode_string_a ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s ( 1 :) !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ( 1 )) * size ( s , dim = 1 ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string_a elemental subroutine b64_decode_R16 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R16P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16 elemental subroutine b64_decode_R8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8 elemental subroutine b64_decode_R4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4 elemental subroutine b64_decode_I8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8 elemental subroutine b64_decode_I4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4 elemental subroutine b64_decode_I2 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I2P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2 elemental subroutine b64_decode_I1 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I1P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1 elemental subroutine b64_decode_string ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string pure subroutine b64_decode_R16_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R16P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16_a pure subroutine b64_decode_R8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8_a pure subroutine b64_decode_R4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4_a pure subroutine b64_decode_I8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8_a pure subroutine b64_decode_I4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4_a pure subroutine b64_decode_I2_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I2P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2_a pure subroutine b64_decode_I1_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I1P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1_a pure subroutine b64_decode_string_a ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array of strings. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s ( 1 :) !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ( 1 )) * size ( s , dim = 1 ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string_a subroutine autotest () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for autotesting the library functionalities. !< !< @note Into the *src* directory there is a small python script (*validation.py*) that can be used to validate the library !< correctness by a comparison with other widely used tools such as the python builtin module *struct*. !--------------------------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable :: code64 !< Base64 code. logical :: ok !< Flag for checking the result of encoding/decoding. #ifdef r16p real ( R16P ) :: scalar_R16 !< Decoded scalar. #endif real ( R8P ) :: scalar_R8 !< Decoded scalar. real ( R4P ) :: scalar_R4 !< Decoded scalar. integer ( I8P ) :: scalar_I8 !< Decoded scalar. integer ( I4P ) :: scalar_I4 !< Decoded scalar. integer ( I2P ) :: scalar_I2 !< Decoded scalar. integer ( I1P ) :: scalar_I1 !< Decoded scalar. real ( R8P ) :: array_R8 ( 1 : 2 ) !< Decoded array. real ( R4P ) :: array_R4 ( 1 : 2 ) !< Decoded array. integer ( I8P ) :: array_I8 ( 1 : 4 ) !< Decoded array. integer ( I4P ) :: array_I4 ( 1 : 2 ) !< Decoded array. integer ( I2P ) :: array_I2 ( 1 : 2 ) !< Decoded array. integer ( I1P ) :: array_I1 ( 1 : 2 ) !< Decoded array. character ( 5 ) :: array_s ( 1 : 2 ) !< Decoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call b64_Init print \"(A)\" , 'Encoders' print \"(A)\" , 'Scalars' #ifdef r16p call b64_encode ( n = 13 4.231_R16P , code = code64 ) ok = code64 == 'CKwcWmTHYEA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 13 4.231_R16P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'CKwcWmTHYEA=' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = 1._R8P , code = code64 ) ok = code64 == 'AAAAAAAA8D8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 1._R8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 0._R4P , code = code64 ) ok = code64 == 'AAAAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 0._R4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 23_I8P , code = code64 ) ok = code64 == 'FwAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 23_I8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 2023_I4P , code = code64 ) ok = code64 == '5wcAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 2023_I4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n =- 203_I2P , code = code64 ) ok = code64 == 'Nf8=' print \"(A)\" , '+ Code of ' // trim ( str ( n =- 203_I2P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 120_I1P , code = code64 ) ok = code64 == 'eA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 120_I1P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = 'hello' , code = code64 ) ok = code64 == 'aGVsbG8=' print \"(A)\" , '+ Code of hello: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG8=' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' #ifdef r16p call b64_encode ( n = [ 12 1._R16P , 2.32_R16P ], code = code64 ) ok = code64 == 'AAAAAABAXkCPwvUoXI8CQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 12 1._R16P , 2.32_R16P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAABAXkCPwvUoXI8CQA==' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = [ 1._R8P , 2._R8P ], code = code64 ) ok = code64 == 'AAAAAAAA8D8AAAAAAAAAQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8AAAAAAAAAQA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 0._R4P , - 3 2.12_R4P ], code = code64 ) ok = code64 == 'AAAAAOF6AMI=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAOF6AMI=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], code = code64 ) ok = code64 == 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 2023_I4P , - 24_I4P ], code = code64 ) ok = code64 == '5wcAAOj///8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAOj///8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ - 203_I2P , - 10_I2P ], code = code64 ) ok = code64 == 'Nf/2/w==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf/2/w==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 120_I1P , - 1_I1P ], code = code64 ) ok = code64 == 'eP8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eP8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = [ 'hello' , 'world' ], code = code64 ) ok = code64 == 'aGVsbG93b3JsZA==' print \"(A)\" , '+ Code of [hello,world]: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG93b3JsZA==' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Decoders' print \"(A)\" , 'Scalars' call b64_decode ( code = 'AAAAAAAA8D8=' , n = scalar_R8 ) ok = str ( n = scalar_R8 ) == str ( n = 1._R8P ) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8=' // ': \"' // trim ( str ( n = scalar_R8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 1._R8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAA==' , n = scalar_R4 ) ok = str ( n = scalar_R4 ) == str ( n = 0._R4P ) print \"(A)\" , '+ Decode of ' // 'AAAAAA==' // ': \"' // trim ( str ( n = scalar_R4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 0._R4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'FwAAAAAAAAA=' , n = scalar_I8 ) ok = str ( n = scalar_I8 ) == str ( n = 23_I8P ) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAAA=' // ': \"' // trim ( str ( n = scalar_I8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 23_I8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAA==' , n = scalar_I4 ) ok = str ( n = scalar_I4 ) == str ( n = 2023_I4P ) print \"(A)\" , '+ Decode of ' // '5wcAAA==' // ': \"' // trim ( str ( n = scalar_I4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 2023_I4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf8=' , n = scalar_I2 ) ok = str ( n = scalar_I2 ) == str ( n =- 203_I2P ) print \"(A)\" , '+ Decode of ' // 'Nf8=' // ': \"' // trim ( str ( n = scalar_I2 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n =- 203_I2P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eA==' , n = scalar_I1 ) ok = str ( n = scalar_I1 ) == str ( n = 120_I1P ) print \"(A)\" , '+ Decode of ' // 'eA==' // ': \"' // trim ( str ( n = scalar_I1 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 120_I1P )) // '\", Is it correct?' , ok if (. not . ok ) stop code64 = repeat ( ' ' , 5 ) call b64_decode ( code = 'aGVsbG8=' , s = code64 ) ok = 'hello' == code64 print \"(A)\" , '+ Decode of ' // 'aGVsbG8=' // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected value: \"hello\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' call b64_decode ( code = 'AAAAAAAA8D8AAAAAAAAAQA==' , n = array_R8 ) ok = str ( n = array_R8 ) == str ( n = [ 1._R8P , 2._R8P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8AAAAAAAAAQA==' // ': \"' // trim ( str ( n = array_R8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAOF6AMI=' , n = array_R4 ) ok = str ( n = array_R4 ) == str ( n = [ 0._R4P , - 3 2.12_R4P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAOF6AMI=' // ': \"' // trim ( str ( n = array_R4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop ! ok = test_decode_array(code=, input=) ; if (.not.ok) stop call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = array_I8 ) ok = str ( n = array_I8 ) == str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ]) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // ': \"' // & trim ( str ( n = array_I8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // & '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAOj///8=' , n = array_I4 ) ok = str ( n = array_I4 ) == str ( n = [ 2023_I4P , - 24_I4P ]) print \"(A)\" , '+ Decode of ' // '5wcAAOj///8=' // ': \"' // trim ( str ( n = array_I4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf/2/w==' , n = array_I2 ) ok = str ( n = array_I2 ) == str ( n = [ - 203_I2P , - 10_I2P ]) print \"(A)\" , '+ Decode of ' // 'Nf/2/w==' // ': \"' // trim ( str ( n = array_I2 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eP8=' , n = array_I1 ) ok = str ( n = array_I1 ) == str ( n = [ 120_I1P , - 1_I1P ]) print \"(A)\" , '+ Decode of ' // 'eP8=' // ': \"' // trim ( str ( n = array_I1 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'aGVsbG93b3JsZA==' , s = array_s ) ok = array_s ( 1 ) // array_s ( 2 ) == 'helloworld' print \"(A)\" , '+ Decode of ' // 'aGVsbG93b3JsZA==' // ': \"' // array_s ( 1 ) // array_s ( 2 ) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"helloworld\", Is it correct?' , ok if (. not . ok ) stop return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine autotest endmodule befor64","tags":"","loc":"sourcefile/befor64.f90~2.html","title":"befor64.F90 – StringiFor"},{"text":"StringiFor, definition of string type. Source Code !< StringiFor, definition of `string` type. module stringifor_string_t !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor, definition of `string` type. !----------------------------------------------------------------------------------------------------------------------------------- use befor64 , only : b64_decode , b64_encode use penf , only : I1P , I2P , I4P , I8P , R4P , R8P , R16P , str !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: CK public :: sadjustl_character , sadjustr_character , & sindex_string_string , sindex_string_character , sindex_character_string , & slen , slen_trim , & srepeat_string_string , & sscan_string_string , sscan_string_character , sscan_character_string , & strim public :: string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- integer , parameter :: CK = selected_char_kind ( 'DEFAULT' ) !< Default character kind. type :: string !< OOP designed string class. private character ( kind = CK , len = :), allocatable :: raw !< Raw data. contains ! public methods ! builtins replacements procedure , pass ( self ) :: adjustl => sadjustl !< Adjustl replacement. procedure , pass ( self ) :: adjustr => sadjustr !< Adjustr replacement. procedure , pass ( self ) :: count => scount !< Count replacement. generic :: index => sindex_string_string , & sindex_string_character !< Index replacement. procedure , pass ( self ) :: len => slen !< Len replacement. procedure , pass ( self ) :: len_trim => slen_trim !< Len_trim replacement. generic :: repeat => srepeat_string_string , & srepeat_character_string !< Repeat replacement. generic :: scan => sscan_string_string , & sscan_string_character !< Scan replacement. procedure , pass ( self ) :: trim => strim !< Trim replacement. procedure , pass ( self ) :: verify => sverify !< Verify replacement. ! auxiliary methods procedure , pass ( self ) :: basedir !< Return the base directory name of a string containing a file name. procedure , pass ( self ) :: basename !< Return the base file name of a string containing a file name. procedure , pass ( self ) :: camelcase !< Return a string with all words capitalized without spaces. procedure , pass ( self ) :: capitalize !< Return a string with its first character capitalized and the rest lowercased. procedure , pass ( self ) :: chars !< Return the raw characters data. procedure , pass ( self ) :: decode !< Decode string. procedure , pass ( self ) :: encode !< Encode string. procedure , pass ( self ) :: escape !< Escape backslashes (or custom escape character). procedure , pass ( self ) :: extension !< Return the extension of a string containing a file name. procedure , pass ( self ) :: fill !< Pad string on the left (or right) with zeros (or other char) to fill width. procedure , pass ( self ) :: free !< Free dynamic memory. generic :: insert => & insert_string , & insert_character !< Insert substring into string at a specified position. generic :: join => & join_strings , & join_characters !< Return a string that is a join of an array of strings or characters. procedure , pass ( self ) :: lower !< Return a string with all lowercase characters. procedure , pass ( self ) :: partition !< Split string at separator and return the 3 parts (before, the separator and after). procedure , pass ( self ) :: read_file !< Read a file a single string stream. procedure , pass ( self ) :: read_line !< Read line (record) from a connected unit. procedure , pass ( self ) :: read_lines !< Read (all) lines (records) from a connected unit as a single ascii stream. procedure , pass ( self ) :: replace !< Return a string with all occurrences of substring old replaced by new. procedure , pass ( self ) :: reverse !< Return a reversed string. procedure , pass ( self ) :: search !< Search for *tagged* record into string. procedure , pass ( self ) :: slice !< Return the raw characters data sliced. procedure , pass ( self ) :: snakecase !< Return a string with all words lowercase separated by \"_\". procedure , pass ( self ) :: split !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: startcase !< Return a string with all words capitalized, e.g. title case. procedure , pass ( self ) :: strip !< Return a string with the leading and trailing characters removed. procedure , pass ( self ) :: swapcase !< Return a string with uppercase chars converted to lowercase and vice versa. generic :: to_number => & to_integer_I1P ,& to_integer_I2P ,& to_integer_I4P ,& to_integer_I8P ,& to_real_R4P , & #ifdef r16p to_real_R8P , & to_real_R16P !< Cast string to number. #else to_real_R8P !< Cast string to number. #endif procedure , pass ( self ) :: unescape !< Unescape double backslashes (or custom escaped character). procedure , pass ( self ) :: unique !< Reduce to one (unique) multiple occurrences of a substring into a string. procedure , pass ( self ) :: upper !< Return a string with all uppercase characters. procedure , pass ( self ) :: write_file !< Write a single string stream into file. procedure , pass ( self ) :: write_line !< Write line (record) to a connected unit. procedure , pass ( self ) :: write_lines !< Write lines (records) to a connected unit. ! inquire methods procedure , pass ( self ) :: end_with !< Return true if a string ends with a specified suffix. procedure , pass ( self ) :: is_allocated !< Return true if the string is allocated. procedure , pass ( self ) :: is_digit !< Return true if all characters in the string are digits. procedure , pass ( self ) :: is_integer !< Return true if the string contains an integer. procedure , pass ( self ) :: is_lower !< Return true if all characters in the string are lowercase. procedure , pass ( self ) :: is_number !< Return true if the string contains a number (real or integer). procedure , pass ( self ) :: is_real !< Return true if the string contains an real. procedure , pass ( self ) :: is_upper !< Return true if all characters in the string are uppercase. procedure , pass ( self ) :: start_with !< Return true if a string starts with a specified prefix. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character , & string_assign_integer_I1P , & string_assign_integer_I2P , & string_assign_integer_I4P , & string_assign_integer_I8P , & string_assign_real_R4P , & #ifdef r16p string_assign_real_R8P , & string_assign_real_R16P !< Assignment operator overloading. #else string_assign_real_R8P !< Assignment operator overloading. #endif generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. generic :: operator ( == ) => string_eq_string , & string_eq_character , & character_eq_string !< Equal operator overloading. generic :: operator ( /= ) => string_ne_string , & string_ne_character , & character_ne_string !< Not equal operator overloading. generic :: operator ( < ) => string_lt_string , & string_lt_character , & character_lt_string !< Lower than operator overloading. generic :: operator ( <= ) => string_le_string , & string_le_character , & character_le_string !< Lower equal than operator overloading. generic :: operator ( >= ) => string_ge_string , & string_ge_character , & character_ge_string !< Greater equal than operator overloading. generic :: operator ( > ) => string_gt_string , & string_gt_character , & character_gt_string !< Greater than operator overloading. ! IO #ifndef __GFORTRAN__ generic :: read ( formatted ) => read_formatted !< Formatted input. generic :: write ( formatted ) => write_formatted !< Formatted output. generic :: read ( unformatted ) => read_unformatted !< Unformatted input. generic :: write ( unformatted ) => write_unformatted !< Unformatted output. #endif ! private methods ! builtins replacements procedure , private , pass ( self ) :: sindex_string_string !< Index replacement. procedure , private , pass ( self ) :: sindex_string_character !< Index replacement. procedure , private , pass ( self ) :: srepeat_string_string !< Repeat replacement. procedure , private , pass ( self ) :: srepeat_character_string !< Repeat replacement. procedure , private , pass ( self ) :: sscan_string_string !< Scan replacement. procedure , private , pass ( self ) :: sscan_string_character !< Scan replacement. ! auxiliary methods procedure , private , pass ( self ) :: insert_string !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: insert_character !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: join_strings !< Return join string of an array of strings. procedure , private , pass ( self ) :: join_characters !< Return join string of an array of characters. procedure , private , pass ( self ) :: to_integer_I1P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I2P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I4P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I8P !< Cast string to integer. procedure , private , pass ( self ) :: to_real_R4P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R8P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R16P !< Cast string to real. ! assignments procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_assign_integer_I1P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I2P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I4P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I8P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_real_R4P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R8P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R16P !< Assignment operator from real input. ! concatenation operators procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). ! logical operators procedure , private , pass ( lhs ) :: string_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: string_eq_character !< Equal to character logical operator. procedure , private , pass ( rhs ) :: character_eq_string !< Equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ne_string !< Not equal to string logical operator. procedure , private , pass ( lhs ) :: string_ne_character !< Not equal to character logical operator. procedure , private , pass ( rhs ) :: character_ne_string !< Not equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_lt_string !< Lower than to string logical operator. procedure , private , pass ( lhs ) :: string_lt_character !< Lower than to character logical operator. procedure , private , pass ( rhs ) :: character_lt_string !< Lower than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_le_string !< Lower equal than to string logical operator. procedure , private , pass ( lhs ) :: string_le_character !< Lower equal than to character logical operator. procedure , private , pass ( rhs ) :: character_le_string !< Lower equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ge_string !< Greater equal than to string logical operator. procedure , private , pass ( lhs ) :: string_ge_character !< Greater equal than to character logical operator. procedure , private , pass ( rhs ) :: character_ge_string !< Greater equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_gt_string !< Greater than to string logical operator. procedure , private , pass ( lhs ) :: string_gt_character !< Greater than to character logical operator. procedure , private , pass ( rhs ) :: character_gt_string !< Greater than to character (inverted) logical operator. ! IO procedure , private , pass ( dtv ) :: read_formatted !< Formatted input. procedure , private , pass ( dtv ) :: read_delimited !< Read a delimited input. procedure , private , pass ( dtv ) :: read_undelimited !< Read an undelimited input. procedure , private , pass ( dtv ) :: read_undelimited_listdirected !< Read an undelimited list directed input. procedure , private , pass ( dtv ) :: write_formatted !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted !< Unformatted output. ! miscellanea procedure , private , pass ( self ) :: replace_one_occurrence !< Replace the first occurrence of substring old by new. endtype string ! internal parameters character ( kind = CK , len = 26 ), parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( kind = CK , len = 26 ), parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. character ( kind = CK , len = 1 ), parameter :: SPACE = ' ' !< Space character. character ( kind = CK , len = 1 ), parameter :: TAB = achar ( 9 ) !< Tab character. character ( kind = CK , len = 1 ), parameter :: UIX_DIR_SEP = char ( 47 ) !< Unix/Linux directories separator (/). character ( kind = CK , len = 1 ), parameter :: BACKSLASH = char ( 92 ) !< Backslash character. !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods ! builtins replacements elemental function sadjustl ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl pure function sadjustl_character ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces (character output). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = len ( self % raw )) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) adjusted = adjustl ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl_character elemental function sadjustr ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr pure function sadjustr_character ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces (character output). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = len ( self % raw )) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) adjusted = adjustr ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr_character elemental function scount ( self , substring , ignore_isolated ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !< !< @note If `ignore_isolated` is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those !< occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a !< right companion). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: substring !< Substring. logical , intent ( in ), optional :: ignore_isolated !< Ignore \"isolated\" occurrences. integer :: No !< Number of occurrences. logical :: ignore_isolated_ !< Ignore \"isolated\" occurrences, local variable. integer :: c1 !< Counter. integer :: c2 !< Counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( allocated ( self % raw )) then if ( len ( substring ) > len ( self % raw )) return ignore_isolated_ = . false . ; if ( present ( ignore_isolated )) ignore_isolated_ = ignore_isolated #ifdef __GFORTRAN__ temporary = self % raw #endif c1 = 1 do #ifdef __GFORTRAN__ c2 = index ( string = temporary ( c1 :), substring = substring ) #else c2 = index ( string = self % raw ( c1 :), substring = substring ) #endif if ( c2 == 0 ) return if (. not .( ignore_isolated_ . and .( c1 == 1. or . c1 + c2 - 1 == len ( self % raw ) - len ( substring ) + 1 ))) then No = No + 1 endif c1 = c1 + c2 - 1 + len ( substring ) enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction scount elemental function sindex_string_string ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_string_string elemental function sindex_string_character ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_string_character elemental function sindex_character_string ( string_ , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: string_ !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( substring % raw )) then i = index ( string = string_ , substring = substring % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_character_string elemental function slen ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen elemental function slen_trim ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string, ignoring any trailing blanks. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen_trim elemental function srepeat_string_string ( self , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenates several copies of an input string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = self % raw , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat_string_string elemental function srepeat_character_string ( self , rstring , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenates several copies of an input string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< String to be repeated. character ( kind = CK , len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = rstring , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat_character_string elemental function sscan_string_string ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw ). and . allocated ( set % raw )) then i = scan ( string = self % raw , set = set % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_string_string elemental function sscan_string_character ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_string_character elemental function sscan_character_string ( sstring , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: sstring !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( set % raw )) then i = scan ( string = sstring , set = set % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_character_string elemental function strim ( self ) result ( trimmed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Remove leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strim elemental function sverify ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sverify ! auxiliary methods elemental function basedir ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base directory name of a string containing a file name. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = '/bar/foo.tar.bz2' !< print '(A)', astring%basedir()//'' ! print \"/bar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. type ( string ) :: basedir !< Base directory name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basedir = self pos = index ( self % raw , sep_ , back = . true .) if ( pos > 0 ) basedir % raw = self % raw ( 1 : pos - 1 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basedir elemental function basename ( self , sep , extension , strip_last_extension ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'bar/foo.tar.bz2' !< print '(A)', astring%basename(extension='.tar.bz2')//''        ! print \"foo\" !< print '(A)', astring%basename(strip_last_extension=.true.)//'' ! print \"foo.tar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , sep_ , back = . true .) if ( pos > 0 ) basename % raw = temporary ( pos + 1 :) #else pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) #endif if ( present ( extension )) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , extension , back = . true .) if ( pos > 0 ) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) #endif elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , '.' , back = . true .) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , '.' , back = . true .) basename % raw = basename % raw ( 1 : pos - 1 ) #endif endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basename elemental function camelcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction camelcase elemental function capitalize ( self ) result ( capitalized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with its first character capitalized and the rest lowercased. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction capitalize pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars elemental function decode ( self , codec ) result ( decoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(A)', astring%decode(codec='base64')//'' ! print \"How are you?\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction decode elemental function encode ( self , codec ) result ( encoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(A)', astring%encode(codec='base64')//'' ! print \"SG93IGFyZSB5b3U/\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction encode elemental function escape ( self , to_escape , esc ) result ( escaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Escape backslashes (or custom escape character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction escape elemental function extension ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the extension of a string containing a file name. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: extension !< Extension file name. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then extension = '' pos = index ( self % raw , '.' , back = . true .) #ifdef __GFORTRAN__ temporary = self % raw if ( pos > 0 ) extension % raw = temporary ( pos :) #else if ( pos > 0 ) extension % raw = self % raw ( pos :) #endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction extension elemental function fill ( self , width , right , filling_char ) result ( filled ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pad string on the left (or right) with zeros (or other char) to fill width. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: width !< Final width of filled string. logical , intent ( in ), optional :: right !< Fill on the right instead of left. character ( kind = CK , len = 1 ), intent ( in ), optional :: filling_char !< Filling character (default \"0\"). type ( string ) :: filled !< Filled string. logical :: right_ !< Fill on the right instead of left, local variable. character ( kind = CK , len = 1 ) :: filling_char_ !< Filling character (default \"0\"), local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( width > len ( self % raw )) then right_ = . false . ; if ( present ( right )) right_ = right filling_char_ = '0' ; if ( present ( filling_char )) filling_char_ = filling_char if (. not . right_ ) then filled % raw = repeat ( filling_char_ , width - len ( self % raw )) // self % raw else filled % raw = self % raw // repeat ( filling_char_ , width - len ( self % raw )) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction fill elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) deallocate ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free elemental function insert_character ( self , substring , pos ) result ( inserted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Insert substring into string at a specified position. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then inserted = self safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring // self % raw ( safepos :) endif else inserted % raw = substring endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction insert_character elemental function insert_string ( self , substring , pos ) result ( inserted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Insert substring into string at a specified position. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then inserted = self if ( allocated ( substring % raw )) then safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring % raw // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring % raw else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring % raw // self % raw ( safepos :) endif endif else if ( allocated ( substring % raw )) inserted % raw = substring % raw endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction insert_string pure function join_strings ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_strings pure function join_characters ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_characters elemental function lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all lowercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: lower !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then lower = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) lower % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lower pure function partition ( self , sep ) result ( partitions ) !--------------------------------------------------------------------------------------------------------------------------------- !< Split string at separator and return the 3 parts (before, the separator and after). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: partitions ( 1 : 3 ) !< Partions: before the separator, the separator itsels and !< after the separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: c !< Character counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep partitions ( 1 ) = self partitions ( 2 ) = sep_ partitions ( 3 ) = '' if ( len ( sep_ ) >= len ( self % raw )) return c = index ( self % raw , sep_ ) if ( c > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw partitions ( 1 )% raw = temporary ( 1 : c - 1 ) partitions ( 2 )% raw = temporary ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = temporary ( c + len ( sep_ ):) #else partitions ( 1 )% raw = self % raw ( 1 : c - 1 ) partitions ( 2 )% raw = self % raw ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = self % raw ( c + len ( sep_ ):) #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction partition subroutine read_file ( self , file , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a file as a single string stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % read_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_file subroutine read_line ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read line (record) from a connected unit. !< !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_eor !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = :), allocatable :: line !< Line storage. character ( kind = CK , len = 1 ) :: ch !< Character storage. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg line = '' select case ( form_ % chars ()) case ( 'FORMATTED' ) do read ( unit , \"(A)\" , advance = 'no' , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 , eor = 10 ) ch line = line // ch enddo case ( 'UNFORMATTED' ) do read ( unit , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) then iostat_ = iostat_eor exit endif line = line // ch enddo endselect 10 if ( line /= '' ) self % raw = line if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_line subroutine read_lines ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read (all) lines (records) from a connected unit as a single ascii stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. The line is read as an ascii stream read until the eor is reached. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. type ( string ) :: lines !< Lines storage. type ( string ) :: line !< Line storage. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) iostat_ = 0 lines % raw = '' do line % raw = '' call line % read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if ( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )) then exit elseif ( line /= '' ) then lines % raw = lines % raw // line % raw // new_line ( 'a' ) endif enddo if ( lines % raw /= '' ) self % raw = lines % raw if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_lines elemental function replace ( self , old , new , count ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all occurrences of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. integer , intent ( in ), optional :: count !< Number of old occurences to be replaced. type ( string ) :: replaced !< The string with old replaced by new. integer :: r !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self r = 0 do if ( index ( replaced % raw , old ) > 0 ) then replaced = replaced % replace_one_occurrence ( old = old , new = new ) r = r + 1 if ( present ( count )) then if ( r >= count ) exit endif else exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace elemental function reverse ( self ) result ( reversed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a reversed string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: reversed !< The reversed string. integer :: length !< Length of the string. integer :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then reversed = self length = len ( self % raw ) do c = 1 , length reversed % raw ( c : c ) = self % raw ( length - c + 1 : length - c + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction reverse function search ( self , tag_start , tag_end , in_string , in_character , istart , iend ) result ( tag ) !--------------------------------------------------------------------------------------------------------------------------------- !< Search for *tagged* record into string, return the first record found (if any) matching the tags. !< !< Optionally, returns the indexes of tag start/end, thus this is not an `elemental` function. !< !< @note The tagged record is searched into self if allocated otherwise into `in_string` if passed or, eventually, into !< `in_character` is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are !< zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: tag_start !< Start tag. character ( kind = CK , len =* ), intent ( in ) :: tag_end !< End tag. type ( string ), intent ( in ), optional :: in_string !< Search into this string. character ( kind = CK , len =* ), intent ( in ), optional :: in_character !< Search into this character string. integer , intent ( out ), optional :: istart !< Starting index of tag inside the string. integer , intent ( out ), optional :: iend !< Ending index of tag inside the string. type ( string ) :: tag !< First tag found. character ( kind = CK , len = :), allocatable :: raw !< Raw string into which search the tag. integer :: istart_ !< Starting index of tag inside the string, local variable. integer :: iend_ !< Ending index of tag inside the string, local variable. logical :: found !< Flag for inquiring search result. integer :: nested_tags !< Number of nested tags inside tag. integer :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- raw = '' if ( present ( in_string )) then raw = in_string % raw elseif ( present ( in_character )) then raw = in_character else if ( allocated ( self % raw )) then raw = self % raw endif endif istart_ = 0 iend_ = 0 if ( raw /= '' ) then found = . false . istart_ = index ( raw , tag_start ) iend_ = index ( raw , tag_end ) if ( istart_ > 0. and . iend_ > 0 ) then iend_ = iend_ + len ( tag_end ) - 1 tag % raw = raw ( istart_ : iend_ ) nested_tags = tag % count ( tag_start ) if ( nested_tags > 1 ) then do t = 2 , nested_tags iend_ = iend_ + len ( tag_end ) - 1 + index ( raw ( iend_ + 1 :), tag_end ) enddo tag % raw = raw ( istart_ : iend_ ) endif endif endif if ( present ( istart )) istart = istart_ if ( present ( iend )) iend = iend_ return !--------------------------------------------------------------------------------------------------------------------------------- endfunction search pure function slice ( self , istart , iend ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data sliced. !< !<### Example !< !<```fortran !< type(string) :: astring        !< A string. !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< print \"(A)\", astring%slice(11,25) ! print \"Brown fox Jumps\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: istart !< Slice start index. integer , intent ( in ) :: iend !< Slice end   index. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw ( istart : iend ) else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slice elemental function snakecase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words lowercase separated by \"_\". !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: snakecase !< Snake case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % lower () snakecase = snakecase % join ( array = tokens , sep = '_' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction snakecase pure subroutine split ( self , tokens , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a list of substring in the string, using sep as the delimiter string. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: No !< Number of occurrences of sep. integer :: t !< Character counter. type ( string ) :: temporary !< Temporary storage. type ( string ), allocatable :: temp_toks (:,:) !< Temporary tokens substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep temporary = self % unique ( sep_ ) No = temporary % count ( sep_ ) allocate ( temp_toks ( 3 , No )) temp_toks (:, 1 ) = temporary % partition ( sep_ ) if ( No > 1 ) then do t = 2 , No temp_toks (:, t ) = temp_toks ( 3 , t - 1 )% partition ( sep_ ) enddo endif if ( temp_toks ( 1 , 1 )% raw /= '' . and . temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No + 1 )) do t = 1 , No if ( t == No ) then tokens ( t ) = temp_toks ( 1 , t ) tokens ( t + 1 ) = temp_toks ( 3 , t ) else tokens ( t ) = temp_toks ( 1 , t ) endif enddo elseif ( temp_toks ( 1 , 1 )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No tokens ( t ) = temp_toks ( 1 , t ) enddo elseif ( temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No )) do t = 2 , No if ( t == No ) then tokens ( t - 1 ) = temp_toks ( 1 , t ) tokens ( t ) = temp_toks ( 3 , t ) else tokens ( t - 1 ) = temp_toks ( 1 , t ) endif enddo else allocate ( tokens ( No - 1 )) do t = 2 , No tokens ( t - 1 ) = temp_toks ( 1 , t ) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine split elemental function startcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized, e.g. title case. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: startcase !< Start case string. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep call self % split ( tokens = tokens , sep = sep_ ) tokens = tokens % capitalize () startcase = startcase % join ( array = tokens , sep = sep_ ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction startcase elemental function strip ( self , remove_nulls ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with the leading and trailing characters removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: remove_nulls !< Remove null characters at the end. type ( string ) :: strip !< The stripped string. integer :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then strip = self % adjustl () strip = strip % trim () if ( present ( remove_nulls )) then if ( remove_nulls ) then c = index ( self % raw , char ( 0 )) if ( c > 0 ) strip % raw = strip % raw ( 1 : c - 1 ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strip elemental function swapcase ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with uppercase characters converted to lowercase and vice versa. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: swapcase !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then swapcase = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) then swapcase % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) else n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) swapcase % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction swapcase elemental function to_integer_I1P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I1P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I1P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I1P elemental function to_integer_I2P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I2P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I2P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I2P elemental function to_integer_I4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I4P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I4P elemental function to_integer_I8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I8P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I8P elemental function to_real_R4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R4P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R4P elemental function to_real_R8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R8P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R8P elemental function to_real_R16P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R16P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R16P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R16P elemental function unescape ( self , to_unescape , unesc ) result ( unescaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unescape double backslashes (or custom escaped character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_unescape !< Character to be unescaped. character ( kind = CK , len =* ), intent ( in ), optional :: unesc !< Character used to unescape. type ( string ) :: unescaped !< Escaped string. character ( kind = CK , len = :), allocatable :: unesc_ !< Character to unescape, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then unesc_ = '' ; if ( present ( unesc )) unesc_ = unesc unescaped % raw = '' c = 1 do if ( c > len ( self % raw )) exit if ( c == len ( self % raw )) then unescaped % raw = unescaped % raw // self % raw ( c : c ) exit else if ( self % raw ( c : c + 1 ) == BACKSLASH // to_unescape ) then unescaped % raw = unescaped % raw // to_unescape c = c + 2 else unescaped % raw = unescaped % raw // self % raw ( c : c ) c = c + 1 endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unescape elemental function unique ( self , substring ) result ( uniq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: substring !< Substring which multiple occurences must be reduced to one. character ( kind = CK , len = :), allocatable :: substring_ !< Substring, default value. type ( string ) :: uniq !< String parsed. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then substring_ = SPACE ; if ( present ( substring )) substring_ = substring uniq = self do if (. not . uniq % index ( repeat ( substring_ , 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( substring_ , 2 ), new = substring_ ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unique elemental function upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all uppercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then upper = self do n1 = 1 , len ( self % raw ) n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) upper % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper subroutine write_file ( self , file , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % write_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_file subroutine write_line ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write line (record) to a connected unit. !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iostat_ = 0 iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg if ( allocated ( self % raw )) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) write ( unit , \"(A)\" , iostat = iostat_ , iomsg = iomsg_ ) self % raw case ( 'UNFORMATTED' ) if ( self % end_with ( new_line ( 'a' ))) then write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw else write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw // new_line ( 'a' ) endif endselect endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_line subroutine write_lines ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write lines (records) to a connected unit. !< !< This method checks if self contains more than one line (records) and writes them as lines (records). !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ), allocatable :: lines (:) !< Lines. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = lines , sep = new_line ( 'a' )) do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_lines ! inquire elemental function end_with ( self , suffix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string ends with a specified suffix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: suffix !< Searched suffix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: end_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- end_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( suffix ) <= len ( self % raw ( start_ : end_ ))) then end_with = index ( self % raw ( start_ : end_ ), suffix ) == ( len ( self % raw ( start_ : end_ )) - len ( suffix ) + 1 ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction end_with elemental function is_allocated ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string is allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_allocated !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_allocated = allocated ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_allocated elemental function is_digit ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are digits. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_digit !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_digit = . false . if ( allocated ( self % raw )) then do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( '0' : '9' ) is_digit = . true . case default is_digit = . false . exit end select enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_digit elemental function is_integer ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains an integer. !< !< The regular expression is `\\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3   | S4  | S5  | S6  | !< |-----|---------|-----|------|-----|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d+`|`[eE]`|`\\+?`|`\\d+`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | !< |----|----|----|----|----|----|----| !< |  F |  F |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L294) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_integer !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_integer = . true . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 6 ) is_integer = allow_spaces_ case ( 2 , 5 ) is_integer = allow_spaces_ stage = 6 case default is_integer = . false . endselect case ( '-' ) select case ( stage ) case ( 0 ) stage = 1 case default is_integer = . false . end select case ( '+' ) select case ( stage ) case ( 0 ) stage = 1 case ( 3 ) stage = 4 case default is_integer = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 case ( 3 : 4 ) stage = 5 case default continue endselect case ( 'e' , 'E' ) select case ( stage ) case ( 2 ) stage = 3 case default is_integer = . false . endselect case default is_integer = . false . endselect if (. not . is_integer ) exit enddo endif if ( is_integer ) then select case ( stage ) case ( 2 , 5 , 6 ) is_integer = . true . case default is_integer = . false . end select endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_integer elemental function is_lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are lowercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_lower !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_lower = . false . if ( allocated ( self % raw )) then is_lower = . true . do c = 1 , len ( self % raw ) if ( index ( UPPER_ALPHABET , self % raw ( c : c )) > 0 ) then is_lower = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_lower elemental function is_number ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a number (real or integer). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_number !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_number = ( self % is_integer ( allow_spaces = allow_spaces ). or . self % is_real ( allow_spaces = allow_spaces )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_number elemental function is_real ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a real. !< !< The regular expression is `\\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3  | S4  | S5     | S6      | S7  | S8  | !< |-----|---------|-----|-----|-----|--------|---------|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d*`|`\\.?`|`\\d*`|`[deDE]`|`[\\+\\-]?`|`\\d*`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | !< |----|----|----|----|----|----|----|----|----| !  |  F |  F |  T |  T |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L614) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_real !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. logical :: has_leading_digit !< Check the presence of leading digits. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_real = . true . has_leading_digit = . false . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 8 ) is_real = allow_spaces_ continue case ( 2 : 4 , 7 ) is_real = allow_spaces_ stage = 8 case default is_real = . false . endselect case ( '+' , '-' ) select case ( stage ) case ( 0 ) stage = 1 case ( 5 ) stage = 6 case default is_real = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 has_leading_digit = . true . case ( 3 ) stage = 4 case ( 5 : 6 ) stage = 7 case default continue endselect case ( '.' ) select case ( stage ) case ( 0 : 2 ) stage = 3 case default is_real = . false . endselect case ( 'e' , 'E' , 'd' , 'D' ) select case ( stage ) case ( 2 : 4 ) stage = 5 case default is_real = . false . endselect case default is_real = . false . endselect if (. not . is_real ) exit enddo endif if ( is_real ) then select case ( stage ) case ( 2 , 4 , 7 , 8 ) is_real = . true . case ( 3 ) is_real = has_leading_digit case default is_real = . false . endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_real elemental function is_upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are uppercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_upper !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_upper = . false . if ( allocated ( self % raw )) then is_upper = . true . do c = 1 , len ( self % raw ) if ( index ( LOWER_ALPHABET , self % raw ( c : c )) > 0 ) then is_upper = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_upper elemental function start_with ( self , prefix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string starts with a specified prefix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: prefix !< Searched prefix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: start_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- start_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( prefix ) <= len ( self % raw ( start_ : end_ ))) then start_with = index ( self % raw ( start_ : end_ ), prefix ) == 1 endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction start_with ! private methods ! assignments elemental subroutine string_assign_string ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from string input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) lhs % raw = rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_string elemental subroutine string_assign_character ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from character input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_character elemental subroutine string_assign_integer_I1P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I1P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I1P elemental subroutine string_assign_integer_I2P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I2P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I2P elemental subroutine string_assign_integer_I4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I4P elemental subroutine string_assign_integer_I8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I8P elemental subroutine string_assign_real_R4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R4P elemental subroutine string_assign_real_R8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R8P elemental subroutine string_assign_real_R16P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R16P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R16P ! contatenation operators pure function string_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string pure function string_concat_character ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character pure function character_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string elemental function string_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( kind = CK , len = :), allocatable :: temporary !< Temporary concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string_string elemental function string_concat_character_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character_string elemental function character_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string_string ! logical operators elemental function string_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw == rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_eq_string elemental function string_eq_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw == rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_eq_character elemental function character_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = rhs % raw == lhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_eq_string elemental function string_ne_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw /= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ne_string elemental function string_ne_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw /= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ne_character elemental function character_ne_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = rhs % raw /= lhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_ne_string elemental function string_lt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw < rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_lt_string elemental function string_lt_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw < rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_lt_character elemental function character_lt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs < rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_lt_string elemental function string_le_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw <= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_le_string elemental function string_le_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw <= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_le_character elemental function character_le_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs <= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_le_string elemental function string_ge_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw >= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ge_string elemental function string_ge_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw >= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ge_character elemental function character_ge_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs >= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_ge_string elemental function string_gt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw > rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_gt_string elemental function string_gt_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw > rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_gt_character elemental function character_gt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs > rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_gt_string ! IO subroutine read_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. character ( kind = CK , len = 1 ) :: delim !< String delimiter, if any. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( iotype == 'LISTDIRECTED' ) then call get_next_non_blank_character_any_record ( unit = unit , ch = delim , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return if ( delim == '\"' . OR . delim == \"'\" ) then call dtv % read_delimited ( unit = unit , delim = delim , iostat = iostat , iomsg = local_iomsg ) else ! step back before the non-blank read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited_listdirected ( unit = unit , iostat = iostat , iomsg = local_iomsg ) endif if ( is_iostat_eor ( iostat )) then ! suppress IOSTAT_EOR iostat = 0 elseif ( iostat /= 0 ) then iomsg = local_iomsg endif return else read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted subroutine read_delimited ( dtv , unit , delim , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a delimited string from a unit connected for formatted input. !< !< If the closing delimiter is followed by end of record, then we return end of record. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( out ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( in ) :: delim !< String delimiter. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. logical :: was_delim !< Indicates that the last character read was a delimiter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- was_delim = . false . dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then if ( was_delim ) then ! end of delimited string followed by end of record is end of the string. Pass back the end of record condition to the ! caller return else ! end of record without terminating delimiter - move along cycle endif elseif ( iostat /= 0 ) THEN return endif if ( ch == delim ) then if ( was_delim ) then ! doubled delimiter is one delimiter in the value dtv % raw = dtv % raw // ch was_delim = . false . else ! need to test next character to see what is happening was_delim = . true . endif elseif ( was_delim ) then ! the previous character was actually the delimiter for the end of the string. Put back this character read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) return else dtv % raw = dtv % raw // ch endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_delimited subroutine read_undelimited_listdirected ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. !< !< A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. !< !< If input is terminated by end of record, then this procedure returns an end-of-record condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. logical :: decimal_point !<True if DECIMAL=POINT in effect. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call get_decimal_mode ( unit = unit , decimal_point = decimal_point , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited ( unit = unit , terminators = ' ' // '/' // merge ( CK_ ',' , CK_ ';' , decimal_point ), iostat = iostat , iomsg = iomsg ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_undelimited_listdirected subroutine read_undelimited ( dtv , unit , terminators , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read an undelimited string up until end of record or a character from a set of terminators is encountered. !< !< If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the !< file remains at end of record. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: terminators !< Characters that are considered to terminate the string. !< Blanks in this string are meaningful. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then ! end of record just means end of string. We pass on the condition return elseif ( iostat /= 0 ) then ! something odd happened return endif if ( scan ( ch , terminators ) /= 0 ) then ! change the file position so that the next read sees the terminator read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return iostat = 0 return endif ! we got a character - append it dtv % raw = dtv % raw // ch enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_undelimited subroutine write_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted subroutine read_unformatted ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_unformatted subroutine write_unformatted ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_unformatted ! miscellanea elemental function replace_one_occurrence ( self , old , new ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with the first occurrence of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. type ( string ) :: replaced !< The string with old replaced by new. integer :: pos !< Position from which replace old. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self pos = index ( string = self % raw , substring = old ) if ( pos > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw if ( pos == 1 ) then replaced % raw = new // temporary ( len ( old ) + 1 :) else replaced % raw = temporary ( 1 : pos - 1 ) // new // temporary ( pos + len ( old ):) endif #else if ( pos == 1 ) then replaced % raw = new // self % raw ( len ( old ) + 1 :) else replaced % raw = self % raw ( 1 : pos - 1 ) // new // self % raw ( pos + len ( old ):) endif #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace_one_occurrence ! non type-bound-procedures subroutine get_delimiter_mode ( unit , delim , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the DELIM changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of NONE is always returned. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< The unit for the connection. character ( len = 1 , kind = CK ), intent ( out ) :: delim !< Represents the value of the DELIM mode. integer , intent ( out ) :: iostat !< IOSTAT error code, non-zero on error. character ( * ), intent ( inout ) :: iomsg !< IOMSG explanatory message - only defined if iostat is non-zero. character ( 10 ) :: delim_buffer !< Buffer for INQUIRE about DELIM, sized for APOSTROHPE. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! get the string representation of the changeable mode inquire ( unit , delim = delim_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the DELIM mode for an internal file iostat = 0 delim = '' return elseif ( iostat /= 0 ) then iomsg = local_iomsg return endif ! interpret the DELIM string if ( delim_buffer == 'QUOTE' ) then delim = '\"' elseif ( delim_buffer == 'APOSTROPHE' ) then delim = '''' else delim = '\"' endif !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_delimiter_mode subroutine get_next_non_blank_character_this_record ( unit , ch , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the next non-blank character in the current record. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do ! we spcify non-advancing, just in case we want this callable outside the context of a child input statement ! the PAD specifier simply saves the need for the READ statement to define ch if EOR is hit ! read(unit, \"(A)\", iostat=iostat, iomsg=iomsg, advance='NO') ch ! ...but that causes ifort to blow up at runtime read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg , pad = 'NO' ) ch if ( iostat /= 0 ) return if ( ch /= '' ) exit enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_next_non_blank_character_this_record subroutine get_next_non_blank_character_any_record ( unit , ch , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the next non-blank character, advancing records if necessary. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do call get_next_non_blank_character_this_record ( unit = unit , ch = ch , iostat = iostat , iomsg = local_iomsg ) if ( is_iostat_eor ( iostat )) then ! try again on the next record read ( unit , \"(/)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return elseif ( iostat /= 0 ) then ! some sort of problem iomsg = local_iomsg return else ! got it exit endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_next_non_blank_character_any_record subroutine get_decimal_mode ( unit , decimal_point , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the DECIMAL changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the !< actual value in force at the time of the call to this procedure. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. logical , intent ( out ) :: decimal_point !< True if the decimal mode is POINT, false otherwise. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( 5 ) :: decimal_buffer !< Buffer for INQUIRE about DECIMAL, sized for POINT or COMMA. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- inquire ( unit , decimal = decimal_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the decimal mode for an internal file iostat = 0 decimal_point = . true . return else if ( iostat /= 0 ) then iomsg = local_iomsg return endif decimal_point = decimal_buffer == 'POINT' !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_decimal_mode endmodule stringifor_string_t","tags":"","loc":"sourcefile/stringifor_string_t.f90.html","title":"stringifor_string_t.F90 – StringiFor"},{"text":"type, public :: string OOP designed string class. Components Type Visibility Attributes Name Initial character(kind=CK,len=:), private, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: adjustl => sadjustl Adjustl replacement. private elemental function sadjustl (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. procedure, public, pass(self) :: adjustr => sadjustr Adjustr replacement. private elemental function sadjustr (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. procedure, public, pass(self) :: count => scount Count replacement. private elemental function scount (self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore \"isolated\" occurrences. Return Value integer Number of occurrences. Description Count the number of occurences of a substring into a string. generic, public :: index => sindex_string_string , sindex_string_character Index replacement. public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. procedure, public, pass(self) :: len => slen Len replacement. public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. procedure, public, pass(self) :: len_trim => slen_trim Len_trim replacement. public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks. generic, public :: repeat => srepeat_string_string , srepeat_character_string Repeat replacement. public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. private elemental function srepeat_character_string (self, rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. generic, public :: scan => sscan_string_string , sscan_string_character Scan replacement. public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . procedure, public, pass(self) :: trim => strim Trim replacement. public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. procedure, public, pass(self) :: verify => sverify Verify replacement. private elemental function sverify (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. procedure, public, pass(self) :: basedir Return the base directory name of a string containing a file name. private elemental function basedir (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. Description Return the base directory name of a string containing a file name. procedure, public, pass(self) :: basename Return the base file name of a string containing a file name. private elemental function basename (self, sep, extension, strip_last_extension) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. character(kind=CK,len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. Description Return the base file name of a string containing a file name. procedure, public, pass(self) :: camelcase Return a string with all words capitalized without spaces. private elemental function camelcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. Description Return a string with all words capitalized without spaces. procedure, public, pass(self) :: capitalize Return a string with its first character capitalized and the rest lowercased. private elemental function capitalize (self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with its first character capitalized and the rest lowercased. procedure, public, pass(self) :: chars Return the raw characters data. private pure function chars (self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data. procedure, public, pass(self) :: decode Decode string. private elemental function decode (self, codec) result(decoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Decoded string. Description Return a string decoded accordingly the codec. procedure, public, pass(self) :: encode Encode string. private elemental function encode (self, codec) result(encoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Encoded string. Description Return a string encoded accordingly the codec. procedure, public, pass(self) :: escape Escape backslashes (or custom escape character). private elemental function escape (self, to_escape, esc) result(escaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK,len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. Description Escape backslashes (or custom escape character). procedure, public, pass(self) :: extension Return the extension of a string containing a file name. private elemental function extension (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. Description Return the extension of a string containing a file name. procedure, public, pass(self) :: fill Pad string on the left (or right) with zeros (or other char) to fill width. private elemental function fill (self, width, right, filling_char) result(filled) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK,len=1), intent(in), optional :: filling_char Filling character (default \"0\"). Return Value type( string ) Filled string. Description Pad string on the left (or right) with zeros (or other char) to fill width. procedure, public, pass(self) :: free Free dynamic memory. private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Description Free dynamic memory. generic, public :: insert => insert_string , insert_character Insert substring into string at a specified position. private elemental function insert_string (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. private elemental function insert_character (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. generic, public :: join => join_strings , join_characters Return a string that is a join of an array of strings or characters. private pure function join_strings (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. private pure function join_characters (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. procedure, public, pass(self) :: lower Return a string with all lowercase characters. private elemental function lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all lowercase characters. procedure, public, pass(self) :: partition Split string at separator and return the 3 parts (before, the separator and after). private pure function partition (self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )\n  (1:3) after the separator. Description Split string at separator and return the 3 parts (before, the separator and after). procedure, public, pass(self) :: read_file Read a file a single string stream. private subroutine read_file (self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read a file as a single string stream. procedure, public, pass(self) :: read_line Read line (record) from a connected unit. private subroutine read_line (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read line (record) from a connected unit. procedure, public, pass(self) :: read_lines Read (all) lines (records) from a connected unit as a single ascii stream. private subroutine read_lines (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read (all) lines (records) from a connected unit as a single ascii stream. procedure, public, pass(self) :: replace Return a string with all occurrences of substring old replaced by new. private elemental function replace (self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Description Return a string with all occurrences of substring old replaced by new. procedure, public, pass(self) :: reverse Return a reversed string. private elemental function reverse (self) result(reversed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. Description Return a reversed string. procedure, public, pass(self) :: search Search for tagged record into string. private function search (self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: tag_start Start tag. character(kind=CK,len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK,len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. Description Search for tagged record into string, return the first record found (if any) matching the tags. procedure, public, pass(self) :: slice Return the raw characters data sliced. private pure function slice (self, istart, iend) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: istart Slice start index. integer, intent(in) :: iend Slice end   index. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data sliced. procedure, public, pass(self) :: snakecase Return a string with all words lowercase separated by \"_\". private elemental function snakecase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. Description Return a string with all words lowercase separated by \"_\". procedure, public, pass(self) :: split Return a list of substring in the string, using sep as the delimiter string. private pure subroutine split (self, tokens, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. Description Return a list of substring in the string, using sep as the delimiter string. procedure, public, pass(self) :: startcase Return a string with all words capitalized, e.g. title case. private elemental function startcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. Description Return a string with all words capitalized, e.g. title case. procedure, public, pass(self) :: strip Return a string with the leading and trailing characters removed. private elemental function strip (self, remove_nulls) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: remove_nulls Remove null characters at the end. Return Value type( string ) The stripped string. Description Return a copy of the string with the leading and trailing characters removed. procedure, public, pass(self) :: swapcase Return a string with uppercase chars converted to lowercase and vice versa. private elemental function swapcase (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a copy of the string with uppercase characters converted to lowercase and vice versa. generic, public :: to_number => to_integer_I1P , to_integer_I2P , to_integer_I4P , to_integer_I8P , to_real_R4P , to_real_R8P Cast string to number. private elemental function to_integer_I1P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). private elemental function to_integer_I2P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). private elemental function to_integer_I4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). private elemental function to_integer_I8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). private elemental function to_real_R4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). private elemental function to_real_R8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). procedure, public, pass(self) :: unescape Unescape double backslashes (or custom escaped character). private elemental function unescape (self, to_unescape, unesc) result(unescaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_unescape Character to be unescaped. character(kind=CK,len=*), intent(in), optional :: unesc Character used to unescape. Return Value type( string ) Escaped string. Description Unescape double backslashes (or custom escaped character). procedure, public, pass(self) :: unique Reduce to one (unique) multiple occurrences of a substring into a string. private elemental function unique (self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Description Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. procedure, public, pass(self) :: upper Return a string with all uppercase characters. private elemental function upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all uppercase characters. procedure, public, pass(self) :: write_file Write a single string stream into file. private subroutine write_file (self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write a single string stream into file. procedure, public, pass(self) :: write_line Write line (record) to a connected unit. private subroutine write_line (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write line (record) to a connected unit. procedure, public, pass(self) :: write_lines Write lines (records) to a connected unit. private subroutine write_lines (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write lines (records) to a connected unit. procedure, public, pass(self) :: end_with Return true if a string ends with a specified suffix. private elemental function end_with (self, suffix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string ends with a specified suffix. procedure, public, pass(self) :: is_allocated Return true if the string is allocated. private elemental function is_allocated (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if the string is allocated. procedure, public, pass(self) :: is_digit Return true if all characters in the string are digits. private elemental function is_digit (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are digits. procedure, public, pass(self) :: is_integer Return true if the string contains an integer. private elemental function is_integer (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains an integer. procedure, public, pass(self) :: is_lower Return true if all characters in the string are lowercase. private elemental function is_lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are lowercase. procedure, public, pass(self) :: is_number Return true if the string contains a number (real or integer). private elemental function is_number (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a number (real or integer). procedure, public, pass(self) :: is_real Return true if the string contains an real. private elemental function is_real (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a real. procedure, public, pass(self) :: is_upper Return true if all characters in the string are uppercase. private elemental function is_upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are uppercase. procedure, public, pass(self) :: start_with Return true if a string starts with a specified prefix. private elemental function start_with (self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string starts with a specified prefix. generic, public :: assignment(=) => string_assign_string , string_assign_character , string_assign_integer_I1P , string_assign_integer_I2P , string_assign_integer_I4P , string_assign_integer_I8P , string_assign_real_R4P , string_assign_real_R8P Assignment operator overloading. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. private elemental subroutine string_assign_integer_I1P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I2P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. generic, public :: operator(//) => string_concat_string , string_concat_character , character_concat_string Concatenation operator overloading. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). generic, public :: operator(.cat.) => string_concat_string_string , string_concat_character_string , character_concat_string_string Concatenation operator (string output) overloading. private elemental function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. private elemental function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. private elemental function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). generic, public :: operator(==) => string_eq_string , string_eq_character , character_eq_string Equal operator overloading. private elemental function string_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. private elemental function string_eq_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. private elemental function character_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character (inverted) logical operator. generic, public :: operator(/=) => string_ne_string , string_ne_character , character_ne_string Not equal operator overloading. private elemental function string_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to string logical operator. private elemental function string_ne_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character logical operator. private elemental function character_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character (inverted) logical operator. generic, public :: operator(<) => string_lt_string , string_lt_character , character_lt_string Lower than operator overloading. private elemental function string_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to string logical operator. private elemental function string_lt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character logical operator. private elemental function character_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character (inverted) logical operator. generic, public :: operator(<=) => string_le_string , string_le_character , character_le_string Lower equal than operator overloading. private elemental function string_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to string logical operator. private elemental function string_le_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character logical operator. private elemental function character_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character (inverted) logical operator. generic, public :: operator(>=) => string_ge_string , string_ge_character , character_ge_string Greater equal than operator overloading. private elemental function string_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to string logical operator. private elemental function string_ge_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character logical operator. private elemental function character_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character (inverted) logical operator. generic, public :: operator(>) => string_gt_string , string_gt_character , character_gt_string Greater than operator overloading. private elemental function string_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to string logical operator. private elemental function string_gt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character logical operator. private elemental function character_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character (inverted) logical operator. generic, public :: read(formatted) => read_formatted Formatted input. private subroutine read_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. generic, public :: write(formatted) => write_formatted Formatted output. private subroutine write_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. generic, public :: read(unformatted) => read_unformatted Unformatted input. private subroutine read_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. generic, public :: write(unformatted) => write_unformatted Unformatted output. private subroutine write_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. procedure, private, pass(self) :: sindex_string_string Index replacement. public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. procedure, private, pass(self) :: sindex_string_character Index replacement. public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. procedure, private, pass(self) :: srepeat_string_string Repeat replacement. public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. procedure, private, pass(self) :: srepeat_character_string Repeat replacement. private elemental function srepeat_character_string (self, rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. procedure, private, pass(self) :: sscan_string_string Scan replacement. public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . procedure, private, pass(self) :: sscan_string_character Scan replacement. public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . procedure, private, pass(self) :: insert_string Insert substring into string at a specified position. private elemental function insert_string (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. procedure, private, pass(self) :: insert_character Insert substring into string at a specified position. private elemental function insert_character (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. procedure, private, pass(self) :: join_strings Return join string of an array of strings. private pure function join_strings (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. procedure, private, pass(self) :: join_characters Return join string of an array of characters. private pure function join_characters (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. procedure, private, pass(self) :: to_integer_I1P Cast string to integer. private elemental function to_integer_I1P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). procedure, private, pass(self) :: to_integer_I2P Cast string to integer. private elemental function to_integer_I2P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). procedure, private, pass(self) :: to_integer_I4P Cast string to integer. private elemental function to_integer_I4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). procedure, private, pass(self) :: to_integer_I8P Cast string to integer. private elemental function to_integer_I8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). procedure, private, pass(self) :: to_real_R4P Cast string to real. private elemental function to_real_R4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). procedure, private, pass(self) :: to_real_R8P Cast string to real. private elemental function to_real_R8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). procedure, private, pass(self) :: to_real_R16P Cast string to real. private elemental function to_real_R16P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. Description Cast string to real (R16P). procedure, private, pass(lhs) :: string_assign_string Assignment operator from string input. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. procedure, private, pass(lhs) :: string_assign_character Assignment operator from character input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. procedure, private, pass(lhs) :: string_assign_integer_I1P Assignment operator from integer input. private elemental subroutine string_assign_integer_I1P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_integer_I2P Assignment operator from integer input. private elemental subroutine string_assign_integer_I2P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_integer_I4P Assignment operator from integer input. private elemental subroutine string_assign_integer_I4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_integer_I8P Assignment operator from integer input. private elemental subroutine string_assign_integer_I8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R4P Assignment operator from real input. private elemental subroutine string_assign_real_R4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R8P Assignment operator from real input. private elemental subroutine string_assign_real_R8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R16P Assignment operator from real input. private elemental subroutine string_assign_real_R16P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. procedure, private, pass(lhs) :: string_concat_string Concatenation with string. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. procedure, private, pass(lhs) :: string_concat_character Concatenation with character. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. procedure, private, pass(rhs) :: character_concat_string Concatenation with character (inverted). private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). procedure, private, pass(lhs) :: string_concat_string_string Concatenation with string (string output). private elemental function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. procedure, private, pass(lhs) :: string_concat_character_string Concatenation with character (string output). private elemental function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. procedure, private, pass(rhs) :: character_concat_string_string Concatenation with character (inverted, string output). private elemental function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). procedure, private, pass(lhs) :: string_eq_string Equal to string logical operator. private elemental function string_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. procedure, private, pass(lhs) :: string_eq_character Equal to character logical operator. private elemental function string_eq_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. procedure, private, pass(rhs) :: character_eq_string Equal to character (inverted) logical operator. private elemental function character_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ne_string Not equal to string logical operator. private elemental function string_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to string logical operator. procedure, private, pass(lhs) :: string_ne_character Not equal to character logical operator. private elemental function string_ne_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character logical operator. procedure, private, pass(rhs) :: character_ne_string Not equal to character (inverted) logical operator. private elemental function character_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_lt_string Lower than to string logical operator. private elemental function string_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to string logical operator. procedure, private, pass(lhs) :: string_lt_character Lower than to character logical operator. private elemental function string_lt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character logical operator. procedure, private, pass(rhs) :: character_lt_string Lower than to character (inverted) logical operator. private elemental function character_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_le_string Lower equal than to string logical operator. private elemental function string_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to string logical operator. procedure, private, pass(lhs) :: string_le_character Lower equal than to character logical operator. private elemental function string_le_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character logical operator. procedure, private, pass(rhs) :: character_le_string Lower equal than to character (inverted) logical operator. private elemental function character_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ge_string Greater equal than to string logical operator. private elemental function string_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to string logical operator. procedure, private, pass(lhs) :: string_ge_character Greater equal than to character logical operator. private elemental function string_ge_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character logical operator. procedure, private, pass(rhs) :: character_ge_string Greater equal than to character (inverted) logical operator. private elemental function character_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_gt_string Greater than to string logical operator. private elemental function string_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to string logical operator. procedure, private, pass(lhs) :: string_gt_character Greater than to character logical operator. private elemental function string_gt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character logical operator. procedure, private, pass(rhs) :: character_gt_string Greater than to character (inverted) logical operator. private elemental function character_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character (inverted) logical operator. procedure, private, pass(dtv) :: read_formatted Formatted input. private subroutine read_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. procedure, private, pass(dtv) :: read_delimited Read a delimited input. private subroutine read_delimited (dtv, unit, delim, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(out) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(in) :: delim String delimiter. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Read a delimited string from a unit connected for formatted input. procedure, private, pass(dtv) :: read_undelimited Read an undelimited input. private subroutine read_undelimited (dtv, unit, terminators, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: terminators Characters that are considered to terminate the string.\n Blanks in this string are meaningful. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited string up until end of record or a character from a set of terminators is encountered. procedure, private, pass(dtv) :: read_undelimited_listdirected Read an undelimited list directed input. private subroutine read_undelimited_listdirected (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. procedure, private, pass(dtv) :: write_formatted Formatted output. private subroutine write_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. procedure, private, pass(dtv) :: read_unformatted Unformatted input. private subroutine read_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. procedure, private, pass(dtv) :: write_unformatted Unformatted output. private subroutine write_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. procedure, private, pass(self) :: replace_one_occurrence Replace the first occurrence of substring old by new. private elemental function replace_one_occurrence (self, old, new) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Description Return a string with the first occurrence of substring old replaced by new. Source Code type :: string !< OOP designed string class. private character ( kind = CK , len = :), allocatable :: raw !< Raw data. contains ! public methods ! builtins replacements procedure , pass ( self ) :: adjustl => sadjustl !< Adjustl replacement. procedure , pass ( self ) :: adjustr => sadjustr !< Adjustr replacement. procedure , pass ( self ) :: count => scount !< Count replacement. generic :: index => sindex_string_string , & sindex_string_character !< Index replacement. procedure , pass ( self ) :: len => slen !< Len replacement. procedure , pass ( self ) :: len_trim => slen_trim !< Len_trim replacement. generic :: repeat => srepeat_string_string , & srepeat_character_string !< Repeat replacement. generic :: scan => sscan_string_string , & sscan_string_character !< Scan replacement. procedure , pass ( self ) :: trim => strim !< Trim replacement. procedure , pass ( self ) :: verify => sverify !< Verify replacement. ! auxiliary methods procedure , pass ( self ) :: basedir !< Return the base directory name of a string containing a file name. procedure , pass ( self ) :: basename !< Return the base file name of a string containing a file name. procedure , pass ( self ) :: camelcase !< Return a string with all words capitalized without spaces. procedure , pass ( self ) :: capitalize !< Return a string with its first character capitalized and the rest lowercased. procedure , pass ( self ) :: chars !< Return the raw characters data. procedure , pass ( self ) :: decode !< Decode string. procedure , pass ( self ) :: encode !< Encode string. procedure , pass ( self ) :: escape !< Escape backslashes (or custom escape character). procedure , pass ( self ) :: extension !< Return the extension of a string containing a file name. procedure , pass ( self ) :: fill !< Pad string on the left (or right) with zeros (or other char) to fill width. procedure , pass ( self ) :: free !< Free dynamic memory. generic :: insert => & insert_string , & insert_character !< Insert substring into string at a specified position. generic :: join => & join_strings , & join_characters !< Return a string that is a join of an array of strings or characters. procedure , pass ( self ) :: lower !< Return a string with all lowercase characters. procedure , pass ( self ) :: partition !< Split string at separator and return the 3 parts (before, the separator and after). procedure , pass ( self ) :: read_file !< Read a file a single string stream. procedure , pass ( self ) :: read_line !< Read line (record) from a connected unit. procedure , pass ( self ) :: read_lines !< Read (all) lines (records) from a connected unit as a single ascii stream. procedure , pass ( self ) :: replace !< Return a string with all occurrences of substring old replaced by new. procedure , pass ( self ) :: reverse !< Return a reversed string. procedure , pass ( self ) :: search !< Search for *tagged* record into string. procedure , pass ( self ) :: slice !< Return the raw characters data sliced. procedure , pass ( self ) :: snakecase !< Return a string with all words lowercase separated by \"_\". procedure , pass ( self ) :: split !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: startcase !< Return a string with all words capitalized, e.g. title case. procedure , pass ( self ) :: strip !< Return a string with the leading and trailing characters removed. procedure , pass ( self ) :: swapcase !< Return a string with uppercase chars converted to lowercase and vice versa. generic :: to_number => & to_integer_I1P ,& to_integer_I2P ,& to_integer_I4P ,& to_integer_I8P ,& to_real_R4P , & #ifdef r16p to_real_R8P , & to_real_R16P !< Cast string to number. #else to_real_R8P !< Cast string to number. #endif procedure , pass ( self ) :: unescape !< Unescape double backslashes (or custom escaped character). procedure , pass ( self ) :: unique !< Reduce to one (unique) multiple occurrences of a substring into a string. procedure , pass ( self ) :: upper !< Return a string with all uppercase characters. procedure , pass ( self ) :: write_file !< Write a single string stream into file. procedure , pass ( self ) :: write_line !< Write line (record) to a connected unit. procedure , pass ( self ) :: write_lines !< Write lines (records) to a connected unit. ! inquire methods procedure , pass ( self ) :: end_with !< Return true if a string ends with a specified suffix. procedure , pass ( self ) :: is_allocated !< Return true if the string is allocated. procedure , pass ( self ) :: is_digit !< Return true if all characters in the string are digits. procedure , pass ( self ) :: is_integer !< Return true if the string contains an integer. procedure , pass ( self ) :: is_lower !< Return true if all characters in the string are lowercase. procedure , pass ( self ) :: is_number !< Return true if the string contains a number (real or integer). procedure , pass ( self ) :: is_real !< Return true if the string contains an real. procedure , pass ( self ) :: is_upper !< Return true if all characters in the string are uppercase. procedure , pass ( self ) :: start_with !< Return true if a string starts with a specified prefix. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character , & string_assign_integer_I1P , & string_assign_integer_I2P , & string_assign_integer_I4P , & string_assign_integer_I8P , & string_assign_real_R4P , & #ifdef r16p string_assign_real_R8P , & string_assign_real_R16P !< Assignment operator overloading. #else string_assign_real_R8P !< Assignment operator overloading. #endif generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. generic :: operator ( == ) => string_eq_string , & string_eq_character , & character_eq_string !< Equal operator overloading. generic :: operator ( /= ) => string_ne_string , & string_ne_character , & character_ne_string !< Not equal operator overloading. generic :: operator ( < ) => string_lt_string , & string_lt_character , & character_lt_string !< Lower than operator overloading. generic :: operator ( <= ) => string_le_string , & string_le_character , & character_le_string !< Lower equal than operator overloading. generic :: operator ( >= ) => string_ge_string , & string_ge_character , & character_ge_string !< Greater equal than operator overloading. generic :: operator ( > ) => string_gt_string , & string_gt_character , & character_gt_string !< Greater than operator overloading. ! IO #ifndef __GFORTRAN__ generic :: read ( formatted ) => read_formatted !< Formatted input. generic :: write ( formatted ) => write_formatted !< Formatted output. generic :: read ( unformatted ) => read_unformatted !< Unformatted input. generic :: write ( unformatted ) => write_unformatted !< Unformatted output. #endif ! private methods ! builtins replacements procedure , private , pass ( self ) :: sindex_string_string !< Index replacement. procedure , private , pass ( self ) :: sindex_string_character !< Index replacement. procedure , private , pass ( self ) :: srepeat_string_string !< Repeat replacement. procedure , private , pass ( self ) :: srepeat_character_string !< Repeat replacement. procedure , private , pass ( self ) :: sscan_string_string !< Scan replacement. procedure , private , pass ( self ) :: sscan_string_character !< Scan replacement. ! auxiliary methods procedure , private , pass ( self ) :: insert_string !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: insert_character !< Insert substring into string at a specified position. procedure , private , pass ( self ) :: join_strings !< Return join string of an array of strings. procedure , private , pass ( self ) :: join_characters !< Return join string of an array of characters. procedure , private , pass ( self ) :: to_integer_I1P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I2P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I4P !< Cast string to integer. procedure , private , pass ( self ) :: to_integer_I8P !< Cast string to integer. procedure , private , pass ( self ) :: to_real_R4P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R8P !< Cast string to real. procedure , private , pass ( self ) :: to_real_R16P !< Cast string to real. ! assignments procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_assign_integer_I1P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I2P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I4P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_integer_I8P !< Assignment operator from integer input. procedure , private , pass ( lhs ) :: string_assign_real_R4P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R8P !< Assignment operator from real input. procedure , private , pass ( lhs ) :: string_assign_real_R16P !< Assignment operator from real input. ! concatenation operators procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). ! logical operators procedure , private , pass ( lhs ) :: string_eq_string !< Equal to string logical operator. procedure , private , pass ( lhs ) :: string_eq_character !< Equal to character logical operator. procedure , private , pass ( rhs ) :: character_eq_string !< Equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ne_string !< Not equal to string logical operator. procedure , private , pass ( lhs ) :: string_ne_character !< Not equal to character logical operator. procedure , private , pass ( rhs ) :: character_ne_string !< Not equal to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_lt_string !< Lower than to string logical operator. procedure , private , pass ( lhs ) :: string_lt_character !< Lower than to character logical operator. procedure , private , pass ( rhs ) :: character_lt_string !< Lower than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_le_string !< Lower equal than to string logical operator. procedure , private , pass ( lhs ) :: string_le_character !< Lower equal than to character logical operator. procedure , private , pass ( rhs ) :: character_le_string !< Lower equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_ge_string !< Greater equal than to string logical operator. procedure , private , pass ( lhs ) :: string_ge_character !< Greater equal than to character logical operator. procedure , private , pass ( rhs ) :: character_ge_string !< Greater equal than to character (inverted) logical operator. procedure , private , pass ( lhs ) :: string_gt_string !< Greater than to string logical operator. procedure , private , pass ( lhs ) :: string_gt_character !< Greater than to character logical operator. procedure , private , pass ( rhs ) :: character_gt_string !< Greater than to character (inverted) logical operator. ! IO procedure , private , pass ( dtv ) :: read_formatted !< Formatted input. procedure , private , pass ( dtv ) :: read_delimited !< Read a delimited input. procedure , private , pass ( dtv ) :: read_undelimited !< Read an undelimited input. procedure , private , pass ( dtv ) :: read_undelimited_listdirected !< Read an undelimited list directed input. procedure , private , pass ( dtv ) :: write_formatted !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted !< Unformatted output. ! miscellanea procedure , private , pass ( self ) :: replace_one_occurrence !< Replace the first occurrence of substring old by new. endtype string","tags":"","loc":"type/string.html","title":"string – StringiFor "},{"text":"private elemental function bit_size_R16P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Compute the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P","tags":"","loc":"proc/bit_size_r16p.html","title":"bit_size_R16P – StringiFor"},{"text":"private elemental function bit_size_R8P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. Called By proc~~bit_size_r8p~~CalledByGraph proc~bit_size_r8p bit_size_R8P interface~bit_size bit_size interface~bit_size->proc~bit_size_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P","tags":"","loc":"proc/bit_size_r8p.html","title":"bit_size_R8P – StringiFor"},{"text":"private elemental function bit_size_R4P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. Called By proc~~bit_size_r4p~~CalledByGraph proc~bit_size_r4p bit_size_R4P interface~bit_size bit_size interface~bit_size->proc~bit_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P","tags":"","loc":"proc/bit_size_r4p.html","title":"bit_size_R4P – StringiFor"},{"text":"private elemental function bit_size_chr(i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. Called By proc~~bit_size_chr~~CalledByGraph proc~bit_size_chr bit_size_chr interface~bit_size bit_size interface~bit_size->proc~bit_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr","tags":"","loc":"proc/bit_size_chr.html","title":"bit_size_chr – StringiFor"},{"text":"private elemental function byte_size_I8P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i8p~~CalledByGraph proc~byte_size_i8p byte_size_I8P interface~byte_size byte_size interface~byte_size->proc~byte_size_i8p proc~b64_encode_string_a~2 b64_encode_string_a proc~b64_encode_string_a~2->interface~byte_size proc~b64_decode_string~2 b64_decode_string proc~b64_decode_string~2->interface~byte_size proc~b64_decode_string_a~2 b64_decode_string_a proc~b64_decode_string_a~2->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string~2 b64_encode_string proc~b64_encode_string~2->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_string_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_string_a~2 interface~b64_encode~2->proc~b64_encode_string~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 interface~b64_decode~2 b64_decode proc~autotest~2->interface~b64_decode~2 proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string_a~2 proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_string_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_string~2 proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up var panprocbyte_size_i8pCalledByGraph = svgPanZoom('#procbyte_size_i8pCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P","tags":"","loc":"proc/byte_size_i8p.html","title":"byte_size_I8P – StringiFor"},{"text":"private elemental function byte_size_I4P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i4p~~CalledByGraph proc~byte_size_i4p byte_size_I4P interface~byte_size byte_size interface~byte_size->proc~byte_size_i4p proc~b64_encode_string_a~2 b64_encode_string_a proc~b64_encode_string_a~2->interface~byte_size proc~b64_decode_string~2 b64_decode_string proc~b64_decode_string~2->interface~byte_size proc~b64_decode_string_a~2 b64_decode_string_a proc~b64_decode_string_a~2->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string~2 b64_encode_string proc~b64_encode_string~2->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_string_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_string_a~2 interface~b64_encode~2->proc~b64_encode_string~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 interface~b64_decode~2 b64_decode proc~autotest~2->interface~b64_decode~2 proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string_a~2 proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_string_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_string~2 proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up var panprocbyte_size_i4pCalledByGraph = svgPanZoom('#procbyte_size_i4pCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P","tags":"","loc":"proc/byte_size_i4p.html","title":"byte_size_I4P – StringiFor"},{"text":"private elemental function byte_size_I2P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i2p~~CalledByGraph proc~byte_size_i2p byte_size_I2P interface~byte_size byte_size interface~byte_size->proc~byte_size_i2p proc~b64_encode_string_a~2 b64_encode_string_a proc~b64_encode_string_a~2->interface~byte_size proc~b64_decode_string~2 b64_decode_string proc~b64_decode_string~2->interface~byte_size proc~b64_decode_string_a~2 b64_decode_string_a proc~b64_decode_string_a~2->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string~2 b64_encode_string proc~b64_encode_string~2->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_string_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_string_a~2 interface~b64_encode~2->proc~b64_encode_string~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 interface~b64_decode~2 b64_decode proc~autotest~2->interface~b64_decode~2 proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string_a~2 proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_string_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_string~2 proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up var panprocbyte_size_i2pCalledByGraph = svgPanZoom('#procbyte_size_i2pCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P","tags":"","loc":"proc/byte_size_i2p.html","title":"byte_size_I2P – StringiFor"},{"text":"private elemental function byte_size_I1P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i1p~~CalledByGraph proc~byte_size_i1p byte_size_I1P interface~byte_size byte_size interface~byte_size->proc~byte_size_i1p proc~b64_encode_string_a~2 b64_encode_string_a proc~b64_encode_string_a~2->interface~byte_size proc~b64_decode_string~2 b64_decode_string proc~b64_decode_string~2->interface~byte_size proc~b64_decode_string_a~2 b64_decode_string_a proc~b64_decode_string_a~2->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string~2 b64_encode_string proc~b64_encode_string~2->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_string_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_string_a~2 interface~b64_encode~2->proc~b64_encode_string~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 interface~b64_decode~2 b64_decode proc~autotest~2->interface~b64_decode~2 proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string_a~2 proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_string_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_string~2 proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up var panprocbyte_size_i1pCalledByGraph = svgPanZoom('#procbyte_size_i1pCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P","tags":"","loc":"proc/byte_size_i1p.html","title":"byte_size_I1P – StringiFor"},{"text":"private elemental function byte_size_R16P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Source Code elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P","tags":"","loc":"proc/byte_size_r16p.html","title":"byte_size_R16P – StringiFor"},{"text":"private elemental function byte_size_R8P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Called By proc~~byte_size_r8p~~CalledByGraph proc~byte_size_r8p byte_size_R8P interface~byte_size byte_size interface~byte_size->proc~byte_size_r8p proc~b64_encode_string_a~2 b64_encode_string_a proc~b64_encode_string_a~2->interface~byte_size proc~b64_decode_string~2 b64_decode_string proc~b64_decode_string~2->interface~byte_size proc~b64_decode_string_a~2 b64_decode_string_a proc~b64_decode_string_a~2->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string~2 b64_encode_string proc~b64_encode_string~2->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_string_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_string_a~2 interface~b64_encode~2->proc~b64_encode_string~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 interface~b64_decode~2 b64_decode proc~autotest~2->interface~b64_decode~2 proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string_a~2 proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_string_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_string~2 proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up var panprocbyte_size_r8pCalledByGraph = svgPanZoom('#procbyte_size_r8pCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P","tags":"","loc":"proc/byte_size_r8p.html","title":"byte_size_R8P – StringiFor"},{"text":"private elemental function byte_size_R4P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Called By proc~~byte_size_r4p~~CalledByGraph proc~byte_size_r4p byte_size_R4P interface~byte_size byte_size interface~byte_size->proc~byte_size_r4p proc~b64_encode_string_a~2 b64_encode_string_a proc~b64_encode_string_a~2->interface~byte_size proc~b64_decode_string~2 b64_decode_string proc~b64_decode_string~2->interface~byte_size proc~b64_decode_string_a~2 b64_decode_string_a proc~b64_decode_string_a~2->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string~2 b64_encode_string proc~b64_encode_string~2->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_string_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_string_a~2 interface~b64_encode~2->proc~b64_encode_string~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 interface~b64_decode~2 b64_decode proc~autotest~2->interface~b64_decode~2 proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string_a~2 proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_string_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_string~2 proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up var panprocbyte_size_r4pCalledByGraph = svgPanZoom('#procbyte_size_r4pCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P","tags":"","loc":"proc/byte_size_r4p.html","title":"byte_size_R4P – StringiFor"},{"text":"private elemental function byte_size_chr(i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable. Called By proc~~byte_size_chr~~CalledByGraph proc~byte_size_chr byte_size_chr interface~byte_size byte_size interface~byte_size->proc~byte_size_chr proc~b64_encode_string_a~2 b64_encode_string_a proc~b64_encode_string_a~2->interface~byte_size proc~b64_decode_string~2 b64_decode_string proc~b64_decode_string~2->interface~byte_size proc~b64_decode_string_a~2 b64_decode_string_a proc~b64_decode_string_a~2->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string~2 b64_encode_string proc~b64_encode_string~2->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_string_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_string_a~2 interface~b64_encode~2->proc~b64_encode_string~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 interface~b64_decode~2 b64_decode proc~autotest~2->interface~b64_decode~2 proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string_a~2 proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_string_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_string~2 proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up var panprocbyte_size_chrCalledByGraph = svgPanZoom('#procbyte_size_chrCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr","tags":"","loc":"proc/byte_size_chr.html","title":"byte_size_chr – StringiFor"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. Calls interface~~bit_size~~CallsGraph interface~bit_size bit_size proc~bit_size_r8p bit_size_R8P interface~bit_size->proc~bit_size_r8p proc~bit_size_chr bit_size_chr interface~bit_size->proc~bit_size_chr proc~bit_size_r4p bit_size_R4P interface~bit_size->proc~bit_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable.","tags":"","loc":"interface/bit_size.html","title":"bit_size – StringiFor"},{"text":"public interface byte_size Compute the number of bytes of a variable. Calls interface~~byte_size~~CallsGraph interface~byte_size byte_size proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~byte_size~~CalledByGraph interface~byte_size byte_size proc~b64_encode_string_a~2 b64_encode_string_a proc~b64_encode_string_a~2->interface~byte_size proc~b64_decode_string~2 b64_decode_string proc~b64_decode_string~2->interface~byte_size proc~b64_decode_string_a~2 b64_decode_string_a proc~b64_decode_string_a~2->interface~byte_size proc~b64_encode_string b64_encode_string proc~b64_encode_string->interface~byte_size proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->interface~byte_size proc~b64_decode_string b64_decode_string proc~b64_decode_string->interface~byte_size proc~b64_encode_string~2 b64_encode_string proc~b64_encode_string~2->interface~byte_size proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->interface~byte_size proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_string_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_string_a~2 interface~b64_encode~2->proc~b64_encode_string~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 interface~b64_decode~2 b64_decode proc~autotest~2->interface~b64_decode~2 proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string_a~2 proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_string_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_string proc~decode decode proc~decode->interface~b64_decode proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_string~2 proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable.","tags":"","loc":"interface/byte_size.html","title":"byte_size – StringiFor"},{"text":"private elemental function strf_R16P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. Source Code elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P","tags":"","loc":"proc/strf_r16p.html","title":"strf_R16P – StringiFor"},{"text":"private elemental function strf_R8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. Called By proc~~strf_r8p~~CalledByGraph proc~strf_r8p strf_R8P interface~str str interface~str->proc~strf_r8p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P","tags":"","loc":"proc/strf_r8p.html","title":"strf_R8P – StringiFor"},{"text":"private elemental function strf_R4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. Called By proc~~strf_r4p~~CalledByGraph proc~strf_r4p strf_R4P interface~str str interface~str->proc~strf_r4p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P","tags":"","loc":"proc/strf_r4p.html","title":"strf_R4P – StringiFor"},{"text":"private elemental function strf_I8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i8p~~CalledByGraph proc~strf_i8p strf_I8P interface~str str interface~str->proc~strf_i8p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P","tags":"","loc":"proc/strf_i8p.html","title":"strf_I8P – StringiFor"},{"text":"private elemental function strf_I4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i4p~~CalledByGraph proc~strf_i4p strf_I4P interface~str str interface~str->proc~strf_i4p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P","tags":"","loc":"proc/strf_i4p.html","title":"strf_I4P – StringiFor"},{"text":"private elemental function strf_I2P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i2p~~CalledByGraph proc~strf_i2p strf_I2P interface~str str interface~str->proc~strf_i2p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P","tags":"","loc":"proc/strf_i2p.html","title":"strf_I2P – StringiFor"},{"text":"private elemental function strf_I1P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i1p~~CalledByGraph proc~strf_i1p strf_I1P interface~str str interface~str->proc~strf_i1p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P","tags":"","loc":"proc/strf_i1p.html","title":"strf_I1P – StringiFor"},{"text":"private elemental function str_R16P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r16p~~CalledByGraph proc~str_r16p str_R16P proc~str_a_r16p str_a_R16P proc~str_a_r16p->proc~str_r16p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R16P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P","tags":"","loc":"proc/str_r16p.html","title":"str_R16P – StringiFor"},{"text":"private elemental function str_R8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r8p~~CalledByGraph proc~str_r8p str_R8P proc~str_a_r8p str_a_R8P proc~str_a_r8p->proc~str_r8p interface~str str interface~str->proc~str_r8p interface~str->proc~str_a_r8p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P","tags":"","loc":"proc/str_r8p.html","title":"str_R8P – StringiFor"},{"text":"private elemental function str_R4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r4p~~CalledByGraph proc~str_r4p str_R4P proc~str_a_r4p str_a_R4P proc~str_a_r4p->proc~str_r4p interface~str str interface~str->proc~str_r4p interface~str->proc~str_a_r4p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P","tags":"","loc":"proc/str_r4p.html","title":"str_R4P – StringiFor"},{"text":"private elemental function str_I8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i8p~~CalledByGraph proc~str_i8p str_I8P proc~str_a_i8p str_a_I8P proc~str_a_i8p->proc~str_i8p interface~str str interface~str->proc~str_i8p interface~str->proc~str_a_i8p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P","tags":"","loc":"proc/str_i8p.html","title":"str_I8P – StringiFor"},{"text":"private elemental function str_I4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. Called By proc~~str_i4p~~CalledByGraph proc~str_i4p str_I4P proc~str_a_i4p str_a_I4P proc~str_a_i4p->proc~str_i4p interface~str str interface~str->proc~str_i4p interface~str->proc~str_a_i4p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P","tags":"","loc":"proc/str_i4p.html","title":"str_I4P – StringiFor"},{"text":"private elemental function str_I2P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i2p~~CalledByGraph proc~str_i2p str_I2P proc~str_a_i2p str_a_I2P proc~str_a_i2p->proc~str_i2p interface~str str interface~str->proc~str_i2p interface~str->proc~str_a_i2p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P","tags":"","loc":"proc/str_i2p.html","title":"str_I2P – StringiFor"},{"text":"private elemental function str_I1P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i1p~~CalledByGraph proc~str_i1p str_I1P proc~str_a_i1p str_a_I1P proc~str_a_i1p->proc~str_i1p interface~str str interface~str->proc~str_i1p interface~str->proc~str_a_i1p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P","tags":"","loc":"proc/str_i1p.html","title":"str_I1P – StringiFor"},{"text":"private elemental function str_bol(n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. Called By proc~~str_bol~~CalledByGraph proc~str_bol str_bol interface~str str interface~str->proc~str_bol proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol","tags":"","loc":"proc/str_bol.html","title":"str_bol – StringiFor"},{"text":"private pure function str_a_R16P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Converting real array to string. Calls proc~~str_a_r16p~~CallsGraph proc~str_a_r16p str_a_R16P proc~str_r16p str_R16P proc~str_a_r16p->proc~str_r16p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR16P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R16P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P","tags":"","loc":"proc/str_a_r16p.html","title":"str_a_R16P – StringiFor"},{"text":"private pure function str_a_R8P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. Calls proc~~str_a_r8p~~CallsGraph proc~str_a_r8p str_a_R8P proc~str_r8p str_R8P proc~str_a_r8p->proc~str_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_r8p~~CalledByGraph proc~str_a_r8p str_a_R8P interface~str str interface~str->proc~str_a_r8p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P","tags":"","loc":"proc/str_a_r8p.html","title":"str_a_R8P – StringiFor"},{"text":"private pure function str_a_R4P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. Calls proc~~str_a_r4p~~CallsGraph proc~str_a_r4p str_a_R4P proc~str_r4p str_R4P proc~str_a_r4p->proc~str_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_r4p~~CalledByGraph proc~str_a_r4p str_a_R4P interface~str str interface~str->proc~str_a_r4p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P","tags":"","loc":"proc/str_a_r4p.html","title":"str_a_R4P – StringiFor"},{"text":"private pure function str_a_I8P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i8p~~CallsGraph proc~str_a_i8p str_a_I8P proc~str_i8p str_I8P proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i8p~~CalledByGraph proc~str_a_i8p str_a_I8P interface~str str interface~str->proc~str_a_i8p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P","tags":"","loc":"proc/str_a_i8p.html","title":"str_a_I8P – StringiFor"},{"text":"private pure function str_a_I4P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i4p~~CallsGraph proc~str_a_i4p str_a_I4P proc~str_i4p str_I4P proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i4p~~CalledByGraph proc~str_a_i4p str_a_I4P interface~str str interface~str->proc~str_a_i4p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P","tags":"","loc":"proc/str_a_i4p.html","title":"str_a_I4P – StringiFor"},{"text":"private pure function str_a_I2P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i2p~~CallsGraph proc~str_a_i2p str_a_I2P proc~str_i2p str_I2P proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i2p~~CalledByGraph proc~str_a_i2p str_a_I2P interface~str str interface~str->proc~str_a_i2p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I2P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P","tags":"","loc":"proc/str_a_i2p.html","title":"str_a_I2P – StringiFor"},{"text":"private pure function str_a_I1P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i1p~~CallsGraph proc~str_a_i1p str_a_I1P proc~str_i1p str_I1P proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i1p~~CalledByGraph proc~str_a_i1p str_a_I1P interface~str str interface~str->proc~str_a_i1p proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I1P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P","tags":"","loc":"proc/str_a_i1p.html","title":"str_a_I1P – StringiFor"},{"text":"private elemental function strz_I8P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. Called By proc~~strz_i8p~~CalledByGraph proc~strz_i8p strz_I8P interface~strz strz interface~strz->proc~strz_i8p program~test_all test_all program~test_all->interface~strz program~test_all~2 test_all program~test_all~2->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P","tags":"","loc":"proc/strz_i8p.html","title":"strz_I8P – StringiFor"},{"text":"private elemental function strz_I4P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i4p~~CalledByGraph proc~strz_i4p strz_I4P interface~strz strz interface~strz->proc~strz_i4p program~test_all test_all program~test_all->interface~strz program~test_all~2 test_all program~test_all~2->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P","tags":"","loc":"proc/strz_i4p.html","title":"strz_I4P – StringiFor"},{"text":"private elemental function strz_I2P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i2p~~CalledByGraph proc~strz_i2p strz_I2P interface~strz strz interface~strz->proc~strz_i2p program~test_all test_all program~test_all->interface~strz program~test_all~2 test_all program~test_all~2->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P","tags":"","loc":"proc/strz_i2p.html","title":"strz_I2P – StringiFor"},{"text":"private elemental function strz_I1P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i1p~~CalledByGraph proc~strz_i1p strz_I1P interface~strz strz interface~strz->proc~strz_i1p program~test_all test_all program~test_all->interface~strz program~test_all~2 test_all program~test_all~2->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P","tags":"","loc":"proc/strz_i1p.html","title":"strz_I1P – StringiFor"},{"text":"private function ctor_R16P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Description Convert string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P","tags":"","loc":"proc/ctor_r16p.html","title":"ctor_R16P – StringiFor"},{"text":"private function ctor_R8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. Called By proc~~ctor_r8p~~CalledByGraph proc~ctor_r8p ctor_R8P interface~cton cton interface~cton->proc~ctor_r8p program~test_all test_all program~test_all->interface~cton program~test_all~2 test_all program~test_all~2->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P","tags":"","loc":"proc/ctor_r8p.html","title":"ctor_R8P – StringiFor"},{"text":"private function ctor_R4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. Called By proc~~ctor_r4p~~CalledByGraph proc~ctor_r4p ctor_R4P interface~cton cton interface~cton->proc~ctor_r4p program~test_all test_all program~test_all->interface~cton program~test_all~2 test_all program~test_all~2->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P","tags":"","loc":"proc/ctor_r4p.html","title":"ctor_R4P – StringiFor"},{"text":"private function ctoi_I8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i8p~~CalledByGraph proc~ctoi_i8p ctoi_I8P interface~cton cton interface~cton->proc~ctoi_i8p program~test_all test_all program~test_all->interface~cton program~test_all~2 test_all program~test_all~2->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P","tags":"","loc":"proc/ctoi_i8p.html","title":"ctoi_I8P – StringiFor"},{"text":"private function ctoi_I4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i4p~~CalledByGraph proc~ctoi_i4p ctoi_I4P interface~cton cton interface~cton->proc~ctoi_i4p program~test_all test_all program~test_all->interface~cton program~test_all~2 test_all program~test_all~2->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P","tags":"","loc":"proc/ctoi_i4p.html","title":"ctoi_I4P – StringiFor"},{"text":"private function ctoi_I2P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i2p~~CalledByGraph proc~ctoi_i2p ctoi_I2P interface~cton cton interface~cton->proc~ctoi_i2p program~test_all test_all program~test_all->interface~cton program~test_all~2 test_all program~test_all~2->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P","tags":"","loc":"proc/ctoi_i2p.html","title":"ctoi_I2P – StringiFor"},{"text":"private function ctoi_I1P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i1p~~CalledByGraph proc~ctoi_i1p ctoi_I1P interface~cton cton interface~cton->proc~ctoi_i1p program~test_all test_all program~test_all->interface~cton program~test_all~2 test_all program~test_all~2->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P","tags":"","loc":"proc/ctoi_i1p.html","title":"ctoi_I1P – StringiFor"},{"text":"private elemental function bstr_R16P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. Source Code elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P","tags":"","loc":"proc/bstr_r16p.html","title":"bstr_R16P – StringiFor"},{"text":"private elemental function bstr_R8P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. Called By proc~~bstr_r8p~~CalledByGraph proc~bstr_r8p bstr_R8P interface~bstr bstr interface~bstr->proc~bstr_r8p program~test_all test_all program~test_all->interface~bstr program~test_all~2 test_all program~test_all~2->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P","tags":"","loc":"proc/bstr_r8p.html","title":"bstr_R8P – StringiFor"},{"text":"private elemental function bstr_R4P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. Called By proc~~bstr_r4p~~CalledByGraph proc~bstr_r4p bstr_R4P interface~bstr bstr interface~bstr->proc~bstr_r4p program~test_all test_all program~test_all->interface~bstr program~test_all~2 test_all program~test_all~2->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P","tags":"","loc":"proc/bstr_r4p.html","title":"bstr_R4P – StringiFor"},{"text":"private elemental function bstr_I8P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. Called By proc~~bstr_i8p~~CalledByGraph proc~bstr_i8p bstr_I8P interface~bstr bstr interface~bstr->proc~bstr_i8p program~test_all test_all program~test_all->interface~bstr program~test_all~2 test_all program~test_all~2->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P","tags":"","loc":"proc/bstr_i8p.html","title":"bstr_I8P – StringiFor"},{"text":"private elemental function bstr_I4P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. Called By proc~~bstr_i4p~~CalledByGraph proc~bstr_i4p bstr_I4P interface~bstr bstr interface~bstr->proc~bstr_i4p program~test_all test_all program~test_all->interface~bstr program~test_all~2 test_all program~test_all~2->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P","tags":"","loc":"proc/bstr_i4p.html","title":"bstr_I4P – StringiFor"},{"text":"private elemental function bstr_I2P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. Called By proc~~bstr_i2p~~CalledByGraph proc~bstr_i2p bstr_I2P interface~bstr bstr interface~bstr->proc~bstr_i2p program~test_all test_all program~test_all->interface~bstr program~test_all~2 test_all program~test_all~2->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P","tags":"","loc":"proc/bstr_i2p.html","title":"bstr_I2P – StringiFor"},{"text":"private elemental function bstr_I1P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. Called By proc~~bstr_i1p~~CalledByGraph proc~bstr_i1p bstr_I1P interface~bstr bstr interface~bstr->proc~bstr_i1p program~test_all test_all program~test_all->interface~bstr program~test_all~2 test_all program~test_all~2->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P","tags":"","loc":"proc/bstr_i1p.html","title":"bstr_I1P – StringiFor"},{"text":"private elemental function bctor_R16P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r16p~~CallsGraph proc~bctor_r16p bctor_R16P interface~str str proc~bctor_r16p->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P","tags":"","loc":"proc/bctor_r16p.html","title":"bctor_R16P – StringiFor"},{"text":"private elemental function bctor_R8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r8p~~CallsGraph proc~bctor_r8p bctor_R8P interface~str str proc~bctor_r8p->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctor_r8p~~CalledByGraph proc~bctor_r8p bctor_R8P interface~bcton bcton interface~bcton->proc~bctor_r8p program~test_all test_all program~test_all->interface~bcton program~test_all~2 test_all program~test_all~2->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P","tags":"","loc":"proc/bctor_r8p.html","title":"bctor_R8P – StringiFor"},{"text":"private elemental function bctor_R4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r4p~~CallsGraph proc~bctor_r4p bctor_R4P interface~str str proc~bctor_r4p->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctor_r4p~~CalledByGraph proc~bctor_r4p bctor_R4P interface~bcton bcton interface~bcton->proc~bctor_r4p program~test_all test_all program~test_all->interface~bcton program~test_all~2 test_all program~test_all~2->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P","tags":"","loc":"proc/bctor_r4p.html","title":"bctor_R4P – StringiFor"},{"text":"private elemental function bctoi_I8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i8p~~CallsGraph proc~bctoi_i8p bctoi_I8P interface~str str proc~bctoi_i8p->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i8p~~CalledByGraph proc~bctoi_i8p bctoi_I8P interface~bcton bcton interface~bcton->proc~bctoi_i8p program~test_all test_all program~test_all->interface~bcton program~test_all~2 test_all program~test_all~2->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P","tags":"","loc":"proc/bctoi_i8p.html","title":"bctoi_I8P – StringiFor"},{"text":"private elemental function bctoi_I4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i4p~~CallsGraph proc~bctoi_i4p bctoi_I4P interface~str str proc~bctoi_i4p->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i4p~~CalledByGraph proc~bctoi_i4p bctoi_I4P interface~bcton bcton interface~bcton->proc~bctoi_i4p program~test_all test_all program~test_all->interface~bcton program~test_all~2 test_all program~test_all~2->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P","tags":"","loc":"proc/bctoi_i4p.html","title":"bctoi_I4P – StringiFor"},{"text":"private elemental function bctoi_I2P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i2p~~CallsGraph proc~bctoi_i2p bctoi_I2P interface~str str proc~bctoi_i2p->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i2p~~CalledByGraph proc~bctoi_i2p bctoi_I2P interface~bcton bcton interface~bcton->proc~bctoi_i2p program~test_all test_all program~test_all->interface~bcton program~test_all~2 test_all program~test_all~2->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P","tags":"","loc":"proc/bctoi_i2p.html","title":"bctoi_I2P – StringiFor"},{"text":"private elemental function bctoi_I1P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i1p~~CallsGraph proc~bctoi_i1p bctoi_I1P interface~str str proc~bctoi_i1p->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i1p~~CalledByGraph proc~bctoi_i1p bctoi_I1P interface~bcton bcton interface~bcton->proc~bctoi_i1p program~test_all test_all program~test_all->interface~bcton program~test_all~2 test_all program~test_all~2->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P","tags":"","loc":"proc/bctoi_i1p.html","title":"bctoi_I1P – StringiFor"},{"text":"public interface str Convert number (real and integer) to string (number to string type casting). Calls interface~~str~~CallsGraph interface~str str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~str~~CalledByGraph interface~str str proc~string_assign_integer_i2p string_assign_integer_I2P proc~string_assign_integer_i2p->interface~str proc~autotest~2 autotest proc~autotest~2->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str proc~string_assign_real_r16p string_assign_real_R16P proc~string_assign_real_r16p->interface~str proc~string_assign_integer_i8p string_assign_integer_I8P proc~string_assign_integer_i8p->interface~str proc~string_assign_integer_i4p string_assign_integer_I4P proc~string_assign_integer_i4p->interface~str program~test_all~2 test_all program~test_all~2->interface~str interface~bcton bcton program~test_all~2->interface~bcton proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~autotest autotest proc~autotest->interface~str proc~string_assign_integer_i1p string_assign_integer_I1P proc~string_assign_integer_i1p->interface~str program~test_all test_all program~test_all->interface~str program~test_all->interface~bcton proc~string_assign_real_r4p string_assign_real_R4P proc~string_assign_real_r4p->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~string_assign_real_r8p string_assign_real_R8P proc~string_assign_real_r8p->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str interface~bcton->proc~bctor_r4p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string.","tags":"","loc":"interface/str.html","title":"str – StringiFor"},{"text":"public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). Calls interface~~strz~~CallsGraph interface~strz strz proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~strz~~CalledByGraph interface~strz strz program~test_all test_all program~test_all->interface~strz program~test_all~2 test_all program~test_all~2->interface~strz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros.","tags":"","loc":"interface/strz.html","title":"strz – StringiFor"},{"text":"public interface cton Convert string to number (real and integer, string to number type casting). Calls interface~~cton~~CallsGraph interface~cton cton proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~cton~~CalledByGraph interface~cton cton program~test_all test_all program~test_all->interface~cton program~test_all~2 test_all program~test_all~2->interface~cton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer.","tags":"","loc":"interface/cton.html","title":"cton – StringiFor"},{"text":"public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). Calls interface~~bstr~~CallsGraph interface~bstr bstr proc~bstr_i8p bstr_I8P interface~bstr->proc~bstr_i8p proc~bstr_r8p bstr_R8P interface~bstr->proc~bstr_r8p proc~bstr_i1p bstr_I1P interface~bstr->proc~bstr_i1p proc~bstr_i4p bstr_I4P interface~bstr->proc~bstr_i4p proc~bstr_r4p bstr_R4P interface~bstr->proc~bstr_r4p proc~bstr_i2p bstr_I2P interface~bstr->proc~bstr_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~bstr~~CalledByGraph interface~bstr bstr program~test_all test_all program~test_all->interface~bstr program~test_all~2 test_all program~test_all~2->interface~bstr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits.","tags":"","loc":"interface/bstr.html","title":"bstr – StringiFor"},{"text":"public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). Calls interface~~bcton~~CallsGraph interface~bcton bcton proc~bctoi_i8p bctoi_I8P interface~bcton->proc~bctoi_i8p proc~bctoi_i4p bctoi_I4P interface~bcton->proc~bctoi_i4p proc~bctoi_i1p bctoi_I1P interface~bcton->proc~bctoi_i1p proc~bctoi_i2p bctoi_I2P interface~bcton->proc~bctoi_i2p proc~bctor_r8p bctor_R8P interface~bcton->proc~bctor_r8p proc~bctor_r4p bctor_R4P interface~bcton->proc~bctor_r4p interface~str str proc~bctoi_i8p->interface~str proc~bctoi_i4p->interface~str proc~bctoi_i1p->interface~str proc~bctoi_i2p->interface~str proc~bctor_r8p->interface~str proc~bctor_r4p->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~bcton~~CalledByGraph interface~bcton bcton program~test_all test_all program~test_all->interface~bcton program~test_all~2 test_all program~test_all~2->interface~bcton Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer.","tags":"","loc":"interface/bcton.html","title":"bcton – StringiFor"},{"text":"private elemental function digit_I8(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i8~~CalledByGraph proc~digit_i8 digit_I8 interface~digit digit interface~digit->proc~digit_i8 program~test_all test_all program~test_all->interface~digit program~test_all~2 test_all program~test_all~2->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8","tags":"","loc":"proc/digit_i8.html","title":"digit_I8 – StringiFor"},{"text":"private elemental function digit_I4(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i4~~CalledByGraph proc~digit_i4 digit_I4 interface~digit digit interface~digit->proc~digit_i4 program~test_all test_all program~test_all->interface~digit program~test_all~2 test_all program~test_all~2->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4","tags":"","loc":"proc/digit_i4.html","title":"digit_I4 – StringiFor"},{"text":"private elemental function digit_I2(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i2~~CalledByGraph proc~digit_i2 digit_I2 interface~digit digit interface~digit->proc~digit_i2 program~test_all test_all program~test_all->interface~digit program~test_all~2 test_all program~test_all~2->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2","tags":"","loc":"proc/digit_i2.html","title":"digit_I2 – StringiFor"},{"text":"private elemental function digit_I1(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i1~~CalledByGraph proc~digit_i1 digit_I1 interface~digit digit interface~digit->proc~digit_i1 program~test_all test_all program~test_all->interface~digit program~test_all~2 test_all program~test_all~2->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1","tags":"","loc":"proc/digit_i1.html","title":"digit_I1 – StringiFor"},{"text":"public subroutine check_endian() Arguments None Description Check the type of bit ordering (big or little endian) of the running architecture. Note The result is stored into the endian global variable. Calls proc~~check_endian~~CallsGraph proc~check_endian check_endian none~is_little_endian is_little_endian proc~check_endian->none~is_little_endian Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~check_endian~~CalledByGraph proc~check_endian check_endian proc~penf_init penf_init proc~penf_init->proc~check_endian program~test_all test_all program~test_all->proc~penf_init program~test_all~2 test_all program~test_all~2->proc~penf_init Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions pure function is_little_endian() result(is_little) Arguments None Return Value logical Logical output: true is the running architecture uses little endian ordering, false otherwise. Description Check if the type of the bit ordering of the running architecture is little endian. Source Code subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian","tags":"","loc":"proc/check_endian.html","title":"check_endian – StringiFor"},{"text":"public subroutine penf_init() Arguments None Description Initialize PENF's variables that are not initialized into the definition specification. Calls proc~~penf_init~~CallsGraph proc~penf_init penf_init proc~check_endian check_endian proc~penf_init->proc~check_endian none~is_little_endian is_little_endian proc~check_endian->none~is_little_endian Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~penf_init~~CalledByGraph proc~penf_init penf_init program~test_all test_all program~test_all->proc~penf_init program~test_all~2 test_all program~test_all~2->proc~penf_init Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init","tags":"","loc":"proc/penf_init.html","title":"penf_init – StringiFor"},{"text":"public subroutine penf_print(unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print to the specified unit the PENF's environment data. Called By proc~~penf_print~~CalledByGraph proc~penf_print penf_print program~test_all test_all program~test_all->proc~penf_print program~test_all~2 test_all program~test_all~2->proc~penf_print Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. Source Code subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print","tags":"","loc":"proc/penf_print.html","title":"penf_print – StringiFor"},{"text":"public interface digit Compute the number of digits in decimal base of the input integer. Calls interface~~digit~~CallsGraph interface~digit digit proc~digit_i4 digit_I4 interface~digit->proc~digit_i4 proc~digit_i1 digit_I1 interface~digit->proc~digit_i1 proc~digit_i8 digit_I8 interface~digit->proc~digit_i8 proc~digit_i2 digit_I2 interface~digit->proc~digit_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~digit~~CalledByGraph interface~digit digit program~test_all test_all program~test_all->interface~digit program~test_all~2 test_all program~test_all~2->interface~digit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer.","tags":"","loc":"interface/digit.html","title":"digit – StringiFor"},{"text":"private pure subroutine pack_data_R8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_r4~~CalledByGraph proc~pack_data_r8_r4 pack_data_R8_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_R4","tags":"","loc":"proc/pack_data_r8_r4.html","title":"pack_data_R8_R4 – StringiFor"},{"text":"private pure subroutine pack_data_R8_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i8~~CalledByGraph proc~pack_data_r8_i8 pack_data_R8_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I8","tags":"","loc":"proc/pack_data_r8_i8.html","title":"pack_data_R8_I8 – StringiFor"},{"text":"private pure subroutine pack_data_R8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i4~~CalledByGraph proc~pack_data_r8_i4 pack_data_R8_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I4","tags":"","loc":"proc/pack_data_r8_i4.html","title":"pack_data_R8_I4 – StringiFor"},{"text":"private pure subroutine pack_data_R8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i2~~CalledByGraph proc~pack_data_r8_i2 pack_data_R8_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I2","tags":"","loc":"proc/pack_data_r8_i2.html","title":"pack_data_R8_I2 – StringiFor"},{"text":"private pure subroutine pack_data_R8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i1~~CalledByGraph proc~pack_data_r8_i1 pack_data_R8_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I1","tags":"","loc":"proc/pack_data_r8_i1.html","title":"pack_data_R8_I1 – StringiFor"},{"text":"private pure subroutine pack_data_R4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_r8~~CalledByGraph proc~pack_data_r4_r8 pack_data_R4_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_R8","tags":"","loc":"proc/pack_data_r4_r8.html","title":"pack_data_R4_R8 – StringiFor"},{"text":"private pure subroutine pack_data_R4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i8~~CalledByGraph proc~pack_data_r4_i8 pack_data_R4_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I8","tags":"","loc":"proc/pack_data_r4_i8.html","title":"pack_data_R4_I8 – StringiFor"},{"text":"private pure subroutine pack_data_R4_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i4~~CalledByGraph proc~pack_data_r4_i4 pack_data_R4_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I4","tags":"","loc":"proc/pack_data_r4_i4.html","title":"pack_data_R4_I4 – StringiFor"},{"text":"private pure subroutine pack_data_R4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i2~~CalledByGraph proc~pack_data_r4_i2 pack_data_R4_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I2","tags":"","loc":"proc/pack_data_r4_i2.html","title":"pack_data_R4_I2 – StringiFor"},{"text":"private pure subroutine pack_data_R4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i1~~CalledByGraph proc~pack_data_r4_i1 pack_data_R4_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I1","tags":"","loc":"proc/pack_data_r4_i1.html","title":"pack_data_R4_I1 – StringiFor"},{"text":"private pure subroutine pack_data_I8_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_r8~~CalledByGraph proc~pack_data_i8_r8 pack_data_I8_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R8","tags":"","loc":"proc/pack_data_i8_r8.html","title":"pack_data_I8_R8 – StringiFor"},{"text":"private pure subroutine pack_data_I8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_r4~~CalledByGraph proc~pack_data_i8_r4 pack_data_I8_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R4","tags":"","loc":"proc/pack_data_i8_r4.html","title":"pack_data_I8_R4 – StringiFor"},{"text":"private pure subroutine pack_data_I8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_i4~~CalledByGraph proc~pack_data_i8_i4 pack_data_I8_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I4","tags":"","loc":"proc/pack_data_i8_i4.html","title":"pack_data_I8_I4 – StringiFor"},{"text":"private pure subroutine pack_data_I8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_i2~~CalledByGraph proc~pack_data_i8_i2 pack_data_I8_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I2","tags":"","loc":"proc/pack_data_i8_i2.html","title":"pack_data_I8_I2 – StringiFor"},{"text":"private pure subroutine pack_data_I8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_i1~~CalledByGraph proc~pack_data_i8_i1 pack_data_I8_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I1","tags":"","loc":"proc/pack_data_i8_i1.html","title":"pack_data_I8_I1 – StringiFor"},{"text":"private pure subroutine pack_data_I4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_r8~~CalledByGraph proc~pack_data_i4_r8 pack_data_I4_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R8","tags":"","loc":"proc/pack_data_i4_r8.html","title":"pack_data_I4_R8 – StringiFor"},{"text":"private pure subroutine pack_data_I4_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_r4~~CalledByGraph proc~pack_data_i4_r4 pack_data_I4_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R4","tags":"","loc":"proc/pack_data_i4_r4.html","title":"pack_data_I4_R4 – StringiFor"},{"text":"private pure subroutine pack_data_I4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_i8~~CalledByGraph proc~pack_data_i4_i8 pack_data_I4_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I8","tags":"","loc":"proc/pack_data_i4_i8.html","title":"pack_data_I4_I8 – StringiFor"},{"text":"private pure subroutine pack_data_I4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_i2~~CalledByGraph proc~pack_data_i4_i2 pack_data_I4_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I2","tags":"","loc":"proc/pack_data_i4_i2.html","title":"pack_data_I4_I2 – StringiFor"},{"text":"private pure subroutine pack_data_I4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_i1~~CalledByGraph proc~pack_data_i4_i1 pack_data_I4_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I1","tags":"","loc":"proc/pack_data_i4_i1.html","title":"pack_data_I4_I1 – StringiFor"},{"text":"private pure subroutine pack_data_I2_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_r8~~CalledByGraph proc~pack_data_i2_r8 pack_data_I2_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R8","tags":"","loc":"proc/pack_data_i2_r8.html","title":"pack_data_I2_R8 – StringiFor"},{"text":"private pure subroutine pack_data_I2_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_r4~~CalledByGraph proc~pack_data_i2_r4 pack_data_I2_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R4","tags":"","loc":"proc/pack_data_i2_r4.html","title":"pack_data_I2_R4 – StringiFor"},{"text":"private pure subroutine pack_data_I2_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_i8~~CalledByGraph proc~pack_data_i2_i8 pack_data_I2_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I8","tags":"","loc":"proc/pack_data_i2_i8.html","title":"pack_data_I2_I8 – StringiFor"},{"text":"private pure subroutine pack_data_I2_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_i4~~CalledByGraph proc~pack_data_i2_i4 pack_data_I2_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I4","tags":"","loc":"proc/pack_data_i2_i4.html","title":"pack_data_I2_I4 – StringiFor"},{"text":"private pure subroutine pack_data_I2_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_i1~~CalledByGraph proc~pack_data_i2_i1 pack_data_I2_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I1","tags":"","loc":"proc/pack_data_i2_i1.html","title":"pack_data_I2_I1 – StringiFor"},{"text":"private pure subroutine pack_data_I1_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_r8~~CalledByGraph proc~pack_data_i1_r8 pack_data_I1_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R8","tags":"","loc":"proc/pack_data_i1_r8.html","title":"pack_data_I1_R8 – StringiFor"},{"text":"private pure subroutine pack_data_I1_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_r4~~CalledByGraph proc~pack_data_i1_r4 pack_data_I1_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R4","tags":"","loc":"proc/pack_data_i1_r4.html","title":"pack_data_I1_R4 – StringiFor"},{"text":"private pure subroutine pack_data_I1_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_i8~~CalledByGraph proc~pack_data_i1_i8 pack_data_I1_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I8","tags":"","loc":"proc/pack_data_i1_i8.html","title":"pack_data_I1_I8 – StringiFor"},{"text":"private pure subroutine pack_data_I1_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_i4~~CalledByGraph proc~pack_data_i1_i4 pack_data_I1_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I4","tags":"","loc":"proc/pack_data_i1_i4.html","title":"pack_data_I1_I4 – StringiFor"},{"text":"private pure subroutine pack_data_I1_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_i2~~CalledByGraph proc~pack_data_i1_i2 pack_data_I1_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I2","tags":"","loc":"proc/pack_data_i1_i2.html","title":"pack_data_I1_I2 – StringiFor"},{"text":"public interface pack_data Pack different kinds of data into single I1P array. This is useful for encoding different (heterogeneous) kinds variables into a single (homogeneous) stream of bits. Note This procedure exploits the transfer builtin function, that from the standard (2003+) is defined as TRANSFER(SOURCE, MOLD [, SIZE]) . Data object having a physical representation identical to that of SOURCE but with the type\n and type parameters of MOLD . The result is of the same type and type parameters as MOLD .\n If MOLD is an array and SIZE is absent, the result is an array and of rank one. Its size is as small as possible such\n that its physical representation is not shorter than that of SOURCE . Presently, the following combinations are available: Arrays-Arrays: real(any)-real(any); real(any)-integer(any); integer(any)-integer(any); integer(any)-real(any); real(any)-character; character-real(any); integer(any)-character; character-integer(any); Scalars-Scalars: real(any)-real(any); real(any)-integer(any); integer(any)-integer(any); integer(any)-real(any); real(any)-character; character-real(any); integer(any)-character; character-integer(any); Examples of usage Packing two real arrays, one with kind R8P and one with R4P real ( R8P ) :: array_r8 ( 1 : 12 ) real ( R4P ) :: array_r4 ( - 1 : 5 ) integer ( I1P ), allocatable :: rpack ... call pack_data ( a1 = array_r8 , a2 = array_r4 , packed = rpack ) Packing two arrays, one real with kind R4P and one integer with I4P real ( R4P ) :: array_r4 ( 2 ) integer ( I4P ) :: array_i4 ( 0 : 2 ) integer ( I1P ), allocatable :: rpack ... call pack_data ( a1 = array_r4 , a2 = array_i4 , packed = rpack ) Calls interface~~pack_data~~CallsGraph interface~pack_data pack_data proc~pack_data_i4_r4 pack_data_I4_R4 interface~pack_data->proc~pack_data_i4_r4 proc~pack_data_i2_i1 pack_data_I2_I1 interface~pack_data->proc~pack_data_i2_i1 proc~pack_data_i8_r8 pack_data_I8_R8 interface~pack_data->proc~pack_data_i8_r8 proc~pack_data_i1_r8 pack_data_I1_R8 interface~pack_data->proc~pack_data_i1_r8 proc~pack_data_i1_r4 pack_data_I1_R4 interface~pack_data->proc~pack_data_i1_r4 proc~pack_data_i2_i4 pack_data_I2_I4 interface~pack_data->proc~pack_data_i2_i4 proc~pack_data_i2_r4 pack_data_I2_R4 interface~pack_data->proc~pack_data_i2_r4 proc~pack_data_i1_i8 pack_data_I1_I8 interface~pack_data->proc~pack_data_i1_i8 proc~pack_data_i1_i2 pack_data_I1_I2 interface~pack_data->proc~pack_data_i1_i2 proc~pack_data_i1_i4 pack_data_I1_I4 interface~pack_data->proc~pack_data_i1_i4 proc~pack_data_i4_r8 pack_data_I4_R8 interface~pack_data->proc~pack_data_i4_r8 proc~pack_data_i8_i1 pack_data_I8_I1 interface~pack_data->proc~pack_data_i8_i1 proc~pack_data_i4_i1 pack_data_I4_I1 interface~pack_data->proc~pack_data_i4_i1 proc~pack_data_i8_r4 pack_data_I8_R4 interface~pack_data->proc~pack_data_i8_r4 proc~pack_data_i4_i2 pack_data_I4_I2 interface~pack_data->proc~pack_data_i4_i2 proc~pack_data_i8_i2 pack_data_I8_I2 interface~pack_data->proc~pack_data_i8_i2 proc~pack_data_r4_i2 pack_data_R4_I2 interface~pack_data->proc~pack_data_r4_i2 proc~pack_data_r8_r4 pack_data_R8_R4 interface~pack_data->proc~pack_data_r8_r4 proc~pack_data_i4_i8 pack_data_I4_I8 interface~pack_data->proc~pack_data_i4_i8 proc~pack_data_r4_r8 pack_data_R4_R8 interface~pack_data->proc~pack_data_r4_r8 proc~pack_data_i2_r8 pack_data_I2_R8 interface~pack_data->proc~pack_data_i2_r8 proc~pack_data_i2_i8 pack_data_I2_I8 interface~pack_data->proc~pack_data_i2_i8 proc~pack_data_r8_i1 pack_data_R8_I1 interface~pack_data->proc~pack_data_r8_i1 proc~pack_data_r8_i8 pack_data_R8_I8 interface~pack_data->proc~pack_data_r8_i8 proc~pack_data_r4_i1 pack_data_R4_I1 interface~pack_data->proc~pack_data_r4_i1 proc~pack_data_r8_i2 pack_data_R8_I2 interface~pack_data->proc~pack_data_r8_i2 proc~pack_data_r4_i4 pack_data_R4_I4 interface~pack_data->proc~pack_data_r4_i4 proc~pack_data_r8_i4 pack_data_R8_I4 interface~pack_data->proc~pack_data_r8_i4 proc~pack_data_i8_i4 pack_data_I8_I4 interface~pack_data->proc~pack_data_i8_i4 proc~pack_data_r4_i8 pack_data_R4_I8 interface~pack_data->proc~pack_data_r4_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array.","tags":"","loc":"interface/pack_data.html","title":"pack_data – StringiFor"},{"text":"public subroutine b64_init() Arguments None Description Initialize the BeFoR64 library. Note This procedure must be called before encoding/decoding anything! Called By proc~~b64_init~~CalledByGraph proc~b64_init b64_init proc~autotest autotest proc~autotest->proc~b64_init program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the BeFoR64 library. !< !< @note This procedure **must** be called before encoding/decoding anything! !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init is_b64_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_init","tags":"","loc":"proc/b64_init.html","title":"b64_init – StringiFor"},{"text":"private pure subroutine encode_bits(bits, padd, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: bits (1:) Bits to be encoded. integer(kind=I4P), intent(in) :: padd Number of padding characters ('='). character(len=*), intent(out) :: code Characters code. Description Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) +--first octet--+-second octet--+--third octet--+\n |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|\n +-----------+---+-------+-------+---+-----------+\n |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|\n +--1.index--+--2.index--+--3.index--+--4.index--+ Note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. Note The number of paddings must be computed outside this procedure, into the calling scope. Warning This procedure is the backend of encoding, thus it must be never called outside the module. Called By proc~~encode_bits~~CalledByGraph proc~encode_bits encode_bits proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_i2 b64_encode_I2 proc~b64_encode_i2->proc~encode_bits proc~b64_encode_r16_a b64_encode_R16_a proc~b64_encode_r16_a->proc~encode_bits proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_i1 b64_encode_I1 proc~b64_encode_i1->proc~encode_bits proc~b64_encode_r4 b64_encode_R4 proc~b64_encode_r4->proc~encode_bits proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_r16 b64_encode_R16 proc~b64_encode_r16->proc~encode_bits proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->proc~encode_bits proc~b64_encode_i8 b64_encode_I8 proc~b64_encode_i8->proc~encode_bits proc~b64_encode_string b64_encode_string proc~b64_encode_string->proc~encode_bits proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i4 b64_encode_I4 proc~b64_encode_i4->proc~encode_bits proc~b64_encode_r8 b64_encode_R8 proc~b64_encode_r8->proc~encode_bits proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i4_a proc~b64_encode_up_a->proc~b64_encode_r4_a proc~b64_encode_up_a->proc~b64_encode_i1_a proc~b64_encode_up_a->proc~b64_encode_i8_a proc~b64_encode_up_a->proc~b64_encode_string_a proc~b64_encode_up_a->proc~b64_encode_r8_a proc~b64_encode_up_a->proc~b64_encode_i2_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i4_a interface~b64_encode->proc~b64_encode_i2 interface~b64_encode->proc~b64_encode_r4_a interface~b64_encode->proc~b64_encode_i1_a interface~b64_encode->proc~b64_encode_i1 interface~b64_encode->proc~b64_encode_r4 interface~b64_encode->proc~b64_encode_i8_a interface~b64_encode->proc~b64_encode_string_a interface~b64_encode->proc~b64_encode_i8 interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_r8_a interface~b64_encode->proc~b64_encode_i2_a interface~b64_encode->proc~b64_encode_i4 interface~b64_encode->proc~b64_encode_r8 proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i2 proc~b64_encode_up->proc~b64_encode_i1 proc~b64_encode_up->proc~b64_encode_r4 proc~b64_encode_up->proc~b64_encode_i8 proc~b64_encode_up->proc~b64_encode_string proc~b64_encode_up->proc~b64_encode_i4 proc~b64_encode_up->proc~b64_encode_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: sixb (1:4) 6 bits slices (stored into 8 bits integer) of 24 bits input. integer(kind=I8P), public :: c Counter. integer(kind=I8P), public :: e Counter. integer(kind=I8P), public :: Nb Length of bits array. Source Code pure subroutine encode_bits ( bits , padd , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). !< !< The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) !<``` !< +--first octet--+-second octet--+--third octet--+ !< |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0| !< +-----------+---+-------+-------+---+-----------+ !< |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0| !< +--1.index--+--2.index--+--3.index--+--4.index--+ !<``` !< @note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. !< !< @note The number of paddings must be computed outside this procedure, into the calling scope. !< !< @warning This procedure is the backend of encoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: bits ( 1 :) !< Bits to be encoded. integer ( I4P ), intent ( in ) :: padd !< Number of padding characters ('='). character ( * ), intent ( out ) :: code !< Characters code. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) c = 1_I8P do e = 1_I8P , Nb , 3_I8P ! loop over array elements: 3 bytes (24 bits) scanning sixb = 0_I1P call mvbits ( bits ( e ), 2 , 6 , sixb ( 1 ), 0 ) call mvbits ( bits ( e ), 0 , 2 , sixb ( 2 ), 4 ) if ( e + 1 <= Nb ) then call mvbits ( bits ( e + 1 ), 4 , 4 , sixb ( 2 ), 0 ) call mvbits ( bits ( e + 1 ), 0 , 4 , sixb ( 3 ), 2 ) endif if ( e + 2 <= Nb ) then call mvbits ( bits ( e + 2 ), 6 , 2 , sixb ( 3 ), 0 ) call mvbits ( bits ( e + 2 ), 0 , 6 , sixb ( 4 ), 0 ) endif sixb = sixb + 1_I1P code ( c : c ) = base64 ( sixb ( 1 ): sixb ( 1 )) code ( c + 1 : c + 1 ) = base64 ( sixb ( 2 ): sixb ( 2 )) code ( c + 2 : c + 2 ) = base64 ( sixb ( 3 ): sixb ( 3 )) code ( c + 3 : c + 3 ) = base64 ( sixb ( 4 ): sixb ( 4 )) c = c + 4_I8P enddo if ( padd > 0 ) code ( len ( code ) - padd + 1 :) = repeat ( '=' , padd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine encode_bits","tags":"","loc":"proc/encode_bits.html","title":"encode_bits – StringiFor"},{"text":"private pure subroutine decode_bits(code, bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Characters code. integer(kind=I1P), intent(out) :: bits (1:) Bits decoded. Description Decode a base64 string into a sequence of bits stream. The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code QUJD the decoding process must do +-b64 char--+-b64 char--+-b64 char--+-b64 char--+\n |      Q    |      U    |      J    |      D    |\n +-b64 index-+-b64 index-+-b64 index-+-b64 index-+\n !      16   |      20   |      9    |      3    |\n +-6 bits----+-6 bits----+-6 bits----+-6 bits----+\n |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1|\n +-----------+---+-------+-------+---+-----------+\n |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1|\n +-----8 bits----+-----8 bits----+-----8 bits----+ Note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. Warning This procedure is the backend of decoding, thus it must be never called outside the module. Called By proc~~decode_bits~~CalledByGraph proc~decode_bits decode_bits proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_r8 b64_decode_R8 proc~b64_decode_r8->proc~decode_bits proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_i2 b64_decode_I2 proc~b64_decode_i2->proc~decode_bits proc~b64_decode_r4 b64_decode_R4 proc~b64_decode_r4->proc~decode_bits proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_r16 b64_decode_R16 proc~b64_decode_r16->proc~decode_bits proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_i1 b64_decode_I1 proc~b64_decode_i1->proc~decode_bits proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->proc~decode_bits proc~b64_decode_i8 b64_decode_I8 proc~b64_decode_i8->proc~decode_bits proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_string b64_decode_string proc~b64_decode_string->proc~decode_bits proc~b64_decode_i4 b64_decode_I4 proc~b64_decode_i4->proc~decode_bits proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_r16_a b64_decode_R16_a proc~b64_decode_r16_a->proc~decode_bits proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i4_a proc~b64_decode_up_a->proc~b64_decode_r4_a proc~b64_decode_up_a->proc~b64_decode_i1_a proc~b64_decode_up_a->proc~b64_decode_i8_a proc~b64_decode_up_a->proc~b64_decode_string_a proc~b64_decode_up_a->proc~b64_decode_r8_a proc~b64_decode_up_a->proc~b64_decode_i2_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i4_a interface~b64_decode->proc~b64_decode_r8 interface~b64_decode->proc~b64_decode_r4_a interface~b64_decode->proc~b64_decode_i2 interface~b64_decode->proc~b64_decode_r4 interface~b64_decode->proc~b64_decode_i1_a interface~b64_decode->proc~b64_decode_i8_a interface~b64_decode->proc~b64_decode_i1 interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_i8 interface~b64_decode->proc~b64_decode_r8_a interface~b64_decode->proc~b64_decode_string interface~b64_decode->proc~b64_decode_i4 interface~b64_decode->proc~b64_decode_i2_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_r8 proc~b64_decode_up->proc~b64_decode_i2 proc~b64_decode_up->proc~b64_decode_r4 proc~b64_decode_up->proc~b64_decode_i1 proc~b64_decode_up->proc~b64_decode_i8 proc~b64_decode_up->proc~b64_decode_string proc~b64_decode_up->proc~b64_decode_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: sixb (1:4) 6 bits slices (stored into 8 bits integer) of 24 bits input. integer(kind=I8P), public :: c Counter. integer(kind=I8P), public :: e Counter. integer(kind=I8P), public :: Nb Length of bits array. Source Code pure subroutine decode_bits ( code , bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 string into a sequence of bits stream. !< !< The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code !< `QUJD` the decoding process must do !<``` !< +-b64 char--+-b64 char--+-b64 char--+-b64 char--+ !< |      Q    |      U    |      J    |      D    | !< +-b64 index-+-b64 index-+-b64 index-+-b64 index-+ !< !      16   |      20   |      9    |      3    | !< +-6 bits----+-6 bits----+-6 bits----+-6 bits----+ !< |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1| !< +-----------+---+-------+-------+---+-----------+ !< |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1| !< +-----8 bits----+-----8 bits----+-----8 bits----+ !<``` !< @note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. !< !< @warning This procedure is the backend of decoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Characters code. integer ( I1P ), intent ( out ) :: bits ( 1 :) !< Bits decoded. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) e = 1_I8P do c = 1_I8P , len ( code ), 4_I8P ! loop over code characters: 3 bytes (24 bits) scanning sixb = 0_I1P sixb ( 1 ) = index ( base64 , code ( c : c )) - 1 sixb ( 2 ) = index ( base64 , code ( c + 1 : c + 1 )) - 1 sixb ( 3 ) = index ( base64 , code ( c + 2 : c + 2 )) - 1 sixb ( 4 ) = index ( base64 , code ( c + 3 : c + 3 )) - 1 call mvbits ( sixb ( 1 ), 0 , 6 , bits ( e ), 2 ) ; call mvbits ( sixb ( 2 ), 4 , 2 , bits ( e ), 0 ) if ( e + 1 <= Nb ) then call mvbits ( sixb ( 2 ), 0 , 4 , bits ( e + 1 ), 4 ) ; call mvbits ( sixb ( 3 ), 2 , 4 , bits ( e + 1 ), 0 ) endif if ( e + 2 <= Nb ) then call mvbits ( sixb ( 3 ), 0 , 2 , bits ( e + 2 ), 6 ) ; call mvbits ( sixb ( 4 ), 0 , 6 , bits ( e + 2 ), 0 ) endif e = e + 3_I8P enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine decode_bits","tags":"","loc":"proc/decode_bits.html","title":"decode_bits – StringiFor"},{"text":"public subroutine b64_encode_up(up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode an unlimited polymorphic scalar to base64. Calls proc~~b64_encode_up~~CallsGraph proc~b64_encode_up b64_encode_up proc~b64_encode_i2 b64_encode_I2 proc~b64_encode_up->proc~b64_encode_i2 proc~b64_encode_i1 b64_encode_I1 proc~b64_encode_up->proc~b64_encode_i1 proc~b64_encode_r4 b64_encode_R4 proc~b64_encode_up->proc~b64_encode_r4 proc~b64_encode_i8 b64_encode_I8 proc~b64_encode_up->proc~b64_encode_i8 proc~b64_encode_string b64_encode_string proc~b64_encode_up->proc~b64_encode_string proc~b64_encode_i4 b64_encode_I4 proc~b64_encode_up->proc~b64_encode_i4 proc~b64_encode_r8 b64_encode_R8 proc~b64_encode_up->proc~b64_encode_r8 proc~encode_bits encode_bits proc~b64_encode_i2->proc~encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_i8->proc~encode_bits proc~b64_encode_string->proc~encode_bits interface~byte_size byte_size proc~b64_encode_string->interface~byte_size proc~b64_encode_i4->proc~encode_bits proc~b64_encode_r8->proc~encode_bits proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_encode_up ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic scalar to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8 ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4 ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8 ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4 ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2 ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1 ( n = up , code = code ) type is ( character ( * )) call b64_encode_string ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up","tags":"","loc":"proc/b64_encode_up.html","title":"b64_encode_up – StringiFor"},{"text":"private pure subroutine b64_encode_up_a(up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64. Calls proc~~b64_encode_up_a~~CallsGraph proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_up_a->proc~b64_encode_i2_a proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_up_a->proc~b64_encode_i1_a proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_up_a->proc~b64_encode_r4_a proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_up_a->proc~b64_encode_i8_a proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_up_a->proc~b64_encode_string_a proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_up_a->proc~b64_encode_i4_a proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_up_a->proc~b64_encode_r8_a proc~encode_bits encode_bits proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_string_a->proc~encode_bits interface~byte_size byte_size proc~b64_encode_string_a->interface~byte_size proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_up_a~~CalledByGraph proc~b64_encode_up_a b64_encode_up_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine b64_encode_up_a ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic array to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up ( 1 :) !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8_a ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4_a ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8_a ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4_a ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2_a ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1_a ( n = up , code = code ) type is ( character ( * )) call b64_encode_string_a ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up_a","tags":"","loc":"proc/b64_encode_up_a.html","title":"b64_encode_up_a – StringiFor"},{"text":"public subroutine b64_decode_up(code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. class(*), intent(out) :: up Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic scalar from base64. Calls proc~~b64_decode_up~~CallsGraph proc~b64_decode_up b64_decode_up proc~b64_decode_r8 b64_decode_R8 proc~b64_decode_up->proc~b64_decode_r8 proc~b64_decode_i2 b64_decode_I2 proc~b64_decode_up->proc~b64_decode_i2 proc~b64_decode_r4 b64_decode_R4 proc~b64_decode_up->proc~b64_decode_r4 proc~b64_decode_i1 b64_decode_I1 proc~b64_decode_up->proc~b64_decode_i1 proc~b64_decode_i8 b64_decode_I8 proc~b64_decode_up->proc~b64_decode_i8 proc~b64_decode_string b64_decode_string proc~b64_decode_up->proc~b64_decode_string proc~b64_decode_i4 b64_decode_I4 proc~b64_decode_up->proc~b64_decode_i4 proc~decode_bits decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~b64_decode_i1->proc~decode_bits proc~b64_decode_i8->proc~decode_bits proc~b64_decode_string->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string->interface~byte_size proc~b64_decode_i4->proc~decode_bits proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_decode_up ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic scalar from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. class ( * ), intent ( out ) :: up !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8 ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4 ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8 ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4 ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2 ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1 ( code = code , n = up ) type is ( character ( * )) call b64_decode_string ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up","tags":"","loc":"proc/b64_decode_up.html","title":"b64_decode_up – StringiFor"},{"text":"private subroutine b64_decode_up_a(code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64. Calls proc~~b64_decode_up_a~~CallsGraph proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_up_a->proc~b64_decode_i4_a proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_up_a->proc~b64_decode_r4_a proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_up_a->proc~b64_decode_i2_a proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_up_a->proc~b64_decode_i1_a proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_up_a->proc~b64_decode_r8_a proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_up_a->proc~b64_decode_i8_a proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_up_a->proc~b64_decode_string_a proc~decode_bits decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string_a->interface~byte_size proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_up_a~~CalledByGraph proc~b64_decode_up_a b64_decode_up_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_decode_up_a ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic array from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. class ( * ), intent ( out ) :: up ( 1 :) !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8_a ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4_a ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8_a ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4_a ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2_a ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1_a ( code = code , n = up ) type is ( character ( * )) call b64_decode_string_a ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up_a","tags":"","loc":"proc/b64_decode_up_a.html","title":"b64_decode_up_a – StringiFor"},{"text":"private pure subroutine b64_encode_R16(n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R16P). Calls proc~~b64_encode_r16~~CallsGraph proc~b64_encode_r16 b64_encode_R16 proc~encode_bits encode_bits proc~b64_encode_r16->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_R16 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR16P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16","tags":"","loc":"proc/b64_encode_r16.html","title":"b64_encode_R16 – StringiFor"},{"text":"private pure subroutine b64_encode_R8(n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). Calls proc~~b64_encode_r8~~CallsGraph proc~b64_encode_r8 b64_encode_R8 proc~encode_bits encode_bits proc~b64_encode_r8->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r8~~CalledByGraph proc~b64_encode_r8 b64_encode_R8 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_r8 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r8 proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_R8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR8P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8","tags":"","loc":"proc/b64_encode_r8.html","title":"b64_encode_R8 – StringiFor"},{"text":"private pure subroutine b64_encode_R4(n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). Calls proc~~b64_encode_r4~~CallsGraph proc~b64_encode_r4 b64_encode_R4 proc~encode_bits encode_bits proc~b64_encode_r4->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r4~~CalledByGraph proc~b64_encode_r4 b64_encode_R4 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_r4 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r4 proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_R4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR4P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4","tags":"","loc":"proc/b64_encode_r4.html","title":"b64_encode_R4 – StringiFor"},{"text":"private pure subroutine b64_encode_I8(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). Calls proc~~b64_encode_i8~~CallsGraph proc~b64_encode_i8 b64_encode_I8 proc~encode_bits encode_bits proc~b64_encode_i8->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i8~~CalledByGraph proc~b64_encode_i8 b64_encode_I8 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i8 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i8 proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8","tags":"","loc":"proc/b64_encode_i8.html","title":"b64_encode_I8 – StringiFor"},{"text":"private pure subroutine b64_encode_I4(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). Calls proc~~b64_encode_i4~~CallsGraph proc~b64_encode_i4 b64_encode_I4 proc~encode_bits encode_bits proc~b64_encode_i4->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i4~~CalledByGraph proc~b64_encode_i4 b64_encode_I4 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i4 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i4 proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI4P ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4","tags":"","loc":"proc/b64_encode_i4.html","title":"b64_encode_I4 – StringiFor"},{"text":"private pure subroutine b64_encode_I2(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). Calls proc~~b64_encode_i2~~CallsGraph proc~b64_encode_i2 b64_encode_I2 proc~encode_bits encode_bits proc~b64_encode_i2->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i2~~CalledByGraph proc~b64_encode_i2 b64_encode_I2 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i2 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i2 proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I2 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI2P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2","tags":"","loc":"proc/b64_encode_i2.html","title":"b64_encode_I2 – StringiFor"},{"text":"private pure subroutine b64_encode_I1(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). Calls proc~~b64_encode_i1~~CallsGraph proc~b64_encode_i1 b64_encode_I1 proc~encode_bits encode_bits proc~b64_encode_i1->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i1~~CalledByGraph proc~b64_encode_i1 b64_encode_I1 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i1 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i1 proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I1 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI1P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1","tags":"","loc":"proc/b64_encode_i1.html","title":"b64_encode_I1 – StringiFor"},{"text":"private pure subroutine b64_encode_string(s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. Calls proc~~b64_encode_string~~CallsGraph proc~b64_encode_string b64_encode_string interface~byte_size byte_size proc~b64_encode_string->interface~byte_size proc~encode_bits encode_bits proc~b64_encode_string->proc~encode_bits proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_string~~CalledByGraph proc~b64_encode_string b64_encode_string proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I4P), public :: BYCHS Bytes of character string. Source Code pure subroutine b64_encode_string ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string","tags":"","loc":"proc/b64_encode_string.html","title":"b64_encode_string – StringiFor"},{"text":"private pure subroutine b64_encode_R16_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R16P). Calls proc~~b64_encode_r16_a~~CallsGraph proc~b64_encode_r16_a b64_encode_R16_a proc~encode_bits encode_bits proc~b64_encode_r16_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_R16_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR16P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16_a","tags":"","loc":"proc/b64_encode_r16_a.html","title":"b64_encode_R16_a – StringiFor"},{"text":"private pure subroutine b64_encode_R8_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). Calls proc~~b64_encode_r8_a~~CallsGraph proc~b64_encode_r8_a b64_encode_R8_a proc~encode_bits encode_bits proc~b64_encode_r8_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r8_a~~CalledByGraph proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_r8_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r8_a proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_R8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8_a","tags":"","loc":"proc/b64_encode_r8_a.html","title":"b64_encode_R8_a – StringiFor"},{"text":"private pure subroutine b64_encode_R4_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). Calls proc~~b64_encode_r4_a~~CallsGraph proc~b64_encode_r4_a b64_encode_R4_a proc~encode_bits encode_bits proc~b64_encode_r4_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r4_a~~CalledByGraph proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_r4_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r4_a proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_R4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4_a","tags":"","loc":"proc/b64_encode_r4_a.html","title":"b64_encode_R4_a – StringiFor"},{"text":"private pure subroutine b64_encode_I8_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). Calls proc~~b64_encode_i8_a~~CallsGraph proc~b64_encode_i8_a b64_encode_I8_a proc~encode_bits encode_bits proc~b64_encode_i8_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i8_a~~CalledByGraph proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i8_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i8_a proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8_a","tags":"","loc":"proc/b64_encode_i8_a.html","title":"b64_encode_I8_a – StringiFor"},{"text":"private pure subroutine b64_encode_I4_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). Calls proc~~b64_encode_i4_a~~CallsGraph proc~b64_encode_i4_a b64_encode_I4_a proc~encode_bits encode_bits proc~b64_encode_i4_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i4_a~~CalledByGraph proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i4_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i4_a proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4_a","tags":"","loc":"proc/b64_encode_i4_a.html","title":"b64_encode_I4_a – StringiFor"},{"text":"private pure subroutine b64_encode_I2_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). Calls proc~~b64_encode_i2_a~~CallsGraph proc~b64_encode_i2_a b64_encode_I2_a proc~encode_bits encode_bits proc~b64_encode_i2_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i2_a~~CalledByGraph proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i2_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i2_a proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I2_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI2P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2_a","tags":"","loc":"proc/b64_encode_i2_a.html","title":"b64_encode_I2_a – StringiFor"},{"text":"private pure subroutine b64_encode_I1_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). Calls proc~~b64_encode_i1_a~~CallsGraph proc~b64_encode_i1_a b64_encode_I1_a proc~encode_bits encode_bits proc~b64_encode_i1_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i1_a~~CalledByGraph proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i1_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i1_a proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I1_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI1P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1_a","tags":"","loc":"proc/b64_encode_i1_a.html","title":"b64_encode_I1_a – StringiFor"},{"text":"private pure subroutine b64_encode_string_a(s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64. Calls proc~~b64_encode_string_a~~CallsGraph proc~b64_encode_string_a b64_encode_string_a interface~byte_size byte_size proc~b64_encode_string_a->interface~byte_size proc~encode_bits encode_bits proc~b64_encode_string_a->proc~encode_bits proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_string_a~~CalledByGraph proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string_a proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I4P), public :: BYCHS Bytes of character string. Source Code pure subroutine b64_encode_string_a ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s ( 1 :) !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ( 1 )) * size ( s , dim = 1 ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string_a","tags":"","loc":"proc/b64_encode_string_a.html","title":"b64_encode_string_a – StringiFor"},{"text":"private elemental subroutine b64_decode_R16(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R16P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R16P). Calls proc~~b64_decode_r16~~CallsGraph proc~b64_decode_r16 b64_decode_R16 proc~decode_bits decode_bits proc~b64_decode_r16->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_R16 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R16P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16","tags":"","loc":"proc/b64_decode_r16.html","title":"b64_decode_R16 – StringiFor"},{"text":"private elemental subroutine b64_decode_R8(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). Calls proc~~b64_decode_r8~~CallsGraph proc~b64_decode_r8 b64_decode_R8 proc~decode_bits decode_bits proc~b64_decode_r8->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r8~~CalledByGraph proc~b64_decode_r8 b64_decode_R8 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_r8 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r8 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_R8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8","tags":"","loc":"proc/b64_decode_r8.html","title":"b64_decode_R8 – StringiFor"},{"text":"private elemental subroutine b64_decode_R4(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). Calls proc~~b64_decode_r4~~CallsGraph proc~b64_decode_r4 b64_decode_R4 proc~decode_bits decode_bits proc~b64_decode_r4->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r4~~CalledByGraph proc~b64_decode_r4 b64_decode_R4 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_r4 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r4 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_R4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4","tags":"","loc":"proc/b64_decode_r4.html","title":"b64_decode_R4 – StringiFor"},{"text":"private elemental subroutine b64_decode_I8(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). Calls proc~~b64_decode_i8~~CallsGraph proc~b64_decode_i8 b64_decode_I8 proc~decode_bits decode_bits proc~b64_decode_i8->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i8~~CalledByGraph proc~b64_decode_i8 b64_decode_I8 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i8 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i8 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8","tags":"","loc":"proc/b64_decode_i8.html","title":"b64_decode_I8 – StringiFor"},{"text":"private elemental subroutine b64_decode_I4(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). Calls proc~~b64_decode_i4~~CallsGraph proc~b64_decode_i4 b64_decode_I4 proc~decode_bits decode_bits proc~b64_decode_i4->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i4~~CalledByGraph proc~b64_decode_i4 b64_decode_I4 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i4 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i4 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4","tags":"","loc":"proc/b64_decode_i4.html","title":"b64_decode_I4 – StringiFor"},{"text":"private elemental subroutine b64_decode_I2(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). Calls proc~~b64_decode_i2~~CallsGraph proc~b64_decode_i2 b64_decode_I2 proc~decode_bits decode_bits proc~b64_decode_i2->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i2~~CalledByGraph proc~b64_decode_i2 b64_decode_I2 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i2 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i2 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I2 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I2P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2","tags":"","loc":"proc/b64_decode_i2.html","title":"b64_decode_I2 – StringiFor"},{"text":"private elemental subroutine b64_decode_I1(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). Calls proc~~b64_decode_i1~~CallsGraph proc~b64_decode_i1 b64_decode_I1 proc~decode_bits decode_bits proc~b64_decode_i1->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i1~~CalledByGraph proc~b64_decode_i1 b64_decode_I1 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i1 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i1 proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I1 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I1P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1","tags":"","loc":"proc/b64_decode_i1.html","title":"b64_decode_I1 – StringiFor"},{"text":"private elemental subroutine b64_decode_string(code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. Calls proc~~b64_decode_string~~CallsGraph proc~b64_decode_string b64_decode_string interface~byte_size byte_size proc~b64_decode_string->interface~byte_size proc~decode_bits decode_bits proc~b64_decode_string->proc~decode_bits proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_string~~CalledByGraph proc~b64_decode_string b64_decode_string proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_string ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string","tags":"","loc":"proc/b64_decode_string.html","title":"b64_decode_string – StringiFor"},{"text":"private pure subroutine b64_decode_R16_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R16P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R16P). Calls proc~~b64_decode_r16_a~~CallsGraph proc~b64_decode_r16_a b64_decode_R16_a proc~decode_bits decode_bits proc~b64_decode_r16_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_R16_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R16P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16_a","tags":"","loc":"proc/b64_decode_r16_a.html","title":"b64_decode_R16_a – StringiFor"},{"text":"private pure subroutine b64_decode_R8_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). Calls proc~~b64_decode_r8_a~~CallsGraph proc~b64_decode_r8_a b64_decode_R8_a proc~decode_bits decode_bits proc~b64_decode_r8_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r8_a~~CalledByGraph proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_r8_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r8_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_R8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8_a","tags":"","loc":"proc/b64_decode_r8_a.html","title":"b64_decode_R8_a – StringiFor"},{"text":"private pure subroutine b64_decode_R4_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). Calls proc~~b64_decode_r4_a~~CallsGraph proc~b64_decode_r4_a b64_decode_R4_a proc~decode_bits decode_bits proc~b64_decode_r4_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r4_a~~CalledByGraph proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_r4_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r4_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_R4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4_a","tags":"","loc":"proc/b64_decode_r4_a.html","title":"b64_decode_R4_a – StringiFor"},{"text":"private pure subroutine b64_decode_I8_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). Calls proc~~b64_decode_i8_a~~CallsGraph proc~b64_decode_i8_a b64_decode_I8_a proc~decode_bits decode_bits proc~b64_decode_i8_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i8_a~~CalledByGraph proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i8_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i8_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8_a","tags":"","loc":"proc/b64_decode_i8_a.html","title":"b64_decode_I8_a – StringiFor"},{"text":"private pure subroutine b64_decode_I4_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). Calls proc~~b64_decode_i4_a~~CallsGraph proc~b64_decode_i4_a b64_decode_I4_a proc~decode_bits decode_bits proc~b64_decode_i4_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i4_a~~CalledByGraph proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i4_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i4_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4_a","tags":"","loc":"proc/b64_decode_i4_a.html","title":"b64_decode_I4_a – StringiFor"},{"text":"private pure subroutine b64_decode_I2_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). Calls proc~~b64_decode_i2_a~~CallsGraph proc~b64_decode_i2_a b64_decode_I2_a proc~decode_bits decode_bits proc~b64_decode_i2_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i2_a~~CalledByGraph proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i2_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i2_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I2_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I2P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2_a","tags":"","loc":"proc/b64_decode_i2_a.html","title":"b64_decode_I2_a – StringiFor"},{"text":"private pure subroutine b64_decode_I1_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). Calls proc~~b64_decode_i1_a~~CallsGraph proc~b64_decode_i1_a b64_decode_I1_a proc~decode_bits decode_bits proc~b64_decode_i1_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i1_a~~CalledByGraph proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i1_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i1_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I1_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I1P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1_a","tags":"","loc":"proc/b64_decode_i1_a.html","title":"b64_decode_I1_a – StringiFor"},{"text":"private pure subroutine b64_decode_string_a(code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings. Calls proc~~b64_decode_string_a~~CallsGraph proc~b64_decode_string_a b64_decode_string_a interface~byte_size byte_size proc~b64_decode_string_a->interface~byte_size proc~decode_bits decode_bits proc~b64_decode_string_a->proc~decode_bits proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_string_a~~CalledByGraph proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string_a proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_string_a ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array of strings. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s ( 1 :) !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ( 1 )) * size ( s , dim = 1 ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string_a","tags":"","loc":"proc/b64_decode_string_a.html","title":"b64_decode_string_a – StringiFor"},{"text":"public subroutine autotest() Arguments None Description Procedure for autotesting the library functionalities. Note Into the src directory there is a small python script ( validation.py ) that can be used to validate the library\n correctness by a comparison with other widely used tools such as the python builtin module struct . Calls proc~~autotest~~CallsGraph proc~autotest autotest interface~b64_decode b64_decode proc~autotest->interface~b64_decode proc~b64_init b64_init proc~autotest->proc~b64_init interface~str str proc~autotest->interface~str interface~b64_encode b64_encode proc~autotest->interface~b64_encode proc~b64_decode_i4_a b64_decode_I4_a interface~b64_decode->proc~b64_decode_i4_a proc~b64_decode_r8 b64_decode_R8 interface~b64_decode->proc~b64_decode_r8 proc~b64_decode_i1 b64_decode_I1 interface~b64_decode->proc~b64_decode_i1 proc~b64_decode_r8_a b64_decode_R8_a interface~b64_decode->proc~b64_decode_r8_a proc~b64_decode_r4 b64_decode_R4 interface~b64_decode->proc~b64_decode_r4 proc~b64_decode_i1_a b64_decode_I1_a interface~b64_decode->proc~b64_decode_i1_a proc~b64_decode_string_a b64_decode_string_a interface~b64_decode->proc~b64_decode_string_a proc~b64_decode_r4_a b64_decode_R4_a interface~b64_decode->proc~b64_decode_r4_a proc~b64_decode_i8 b64_decode_I8 interface~b64_decode->proc~b64_decode_i8 proc~b64_decode_i2 b64_decode_I2 interface~b64_decode->proc~b64_decode_i2 proc~b64_decode_i8_a b64_decode_I8_a interface~b64_decode->proc~b64_decode_i8_a proc~b64_decode_string b64_decode_string interface~b64_decode->proc~b64_decode_string proc~b64_decode_i4 b64_decode_I4 interface~b64_decode->proc~b64_decode_i4 proc~b64_decode_i2_a b64_decode_I2_a interface~b64_decode->proc~b64_decode_i2_a proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~b64_encode_r8 b64_encode_R8 interface~b64_encode->proc~b64_encode_r8 proc~b64_encode_i1 b64_encode_I1 interface~b64_encode->proc~b64_encode_i1 proc~b64_encode_i4_a b64_encode_I4_a interface~b64_encode->proc~b64_encode_i4_a proc~b64_encode_i1_a b64_encode_I1_a interface~b64_encode->proc~b64_encode_i1_a proc~b64_encode_string b64_encode_string interface~b64_encode->proc~b64_encode_string proc~b64_encode_r4_a b64_encode_R4_a interface~b64_encode->proc~b64_encode_r4_a proc~b64_encode_r4 b64_encode_R4 interface~b64_encode->proc~b64_encode_r4 proc~b64_encode_string_a b64_encode_string_a interface~b64_encode->proc~b64_encode_string_a proc~b64_encode_i8 b64_encode_I8 interface~b64_encode->proc~b64_encode_i8 proc~b64_encode_i2 b64_encode_I2 interface~b64_encode->proc~b64_encode_i2 proc~b64_encode_r8_a b64_encode_R8_a interface~b64_encode->proc~b64_encode_r8_a proc~b64_encode_i2_a b64_encode_I2_a interface~b64_encode->proc~b64_encode_i2_a proc~b64_encode_i4 b64_encode_I4 interface~b64_encode->proc~b64_encode_i4 proc~b64_encode_i8_a b64_encode_I8_a interface~b64_encode->proc~b64_encode_i8_a proc~decode_bits decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_i1->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string_a->interface~byte_size proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_i8->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_string->proc~decode_bits proc~b64_decode_string->interface~byte_size proc~b64_decode_i4->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~encode_bits encode_bits proc~b64_encode_r8->proc~encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_string->interface~byte_size proc~b64_encode_string->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_string_a->interface~byte_size proc~b64_encode_string_a->proc~encode_bits proc~b64_encode_i8->proc~encode_bits proc~b64_encode_i2->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i4->proc~encode_bits proc~b64_encode_i8_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~autotest~~CalledByGraph proc~autotest autotest program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: code64 Base64 code. logical, public :: ok Flag for checking the result of encoding/decoding. real(kind=R8P), public :: scalar_R8 Decoded scalar. real(kind=R4P), public :: scalar_R4 Decoded scalar. integer(kind=I8P), public :: scalar_I8 Decoded scalar. integer(kind=I4P), public :: scalar_I4 Decoded scalar. integer(kind=I2P), public :: scalar_I2 Decoded scalar. integer(kind=I1P), public :: scalar_I1 Decoded scalar. real(kind=R8P), public :: array_R8 (1:2) Decoded array. real(kind=R4P), public :: array_R4 (1:2) Decoded array. integer(kind=I8P), public :: array_I8 (1:4) Decoded array. integer(kind=I4P), public :: array_I4 (1:2) Decoded array. integer(kind=I2P), public :: array_I2 (1:2) Decoded array. integer(kind=I1P), public :: array_I1 (1:2) Decoded array. character(len=5), public :: array_s (1:2) Decoded array. Source Code subroutine autotest () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for autotesting the library functionalities. !< !< @note Into the *src* directory there is a small python script (*validation.py*) that can be used to validate the library !< correctness by a comparison with other widely used tools such as the python builtin module *struct*. !--------------------------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable :: code64 !< Base64 code. logical :: ok !< Flag for checking the result of encoding/decoding. #ifdef r16p real ( R16P ) :: scalar_R16 !< Decoded scalar. #endif real ( R8P ) :: scalar_R8 !< Decoded scalar. real ( R4P ) :: scalar_R4 !< Decoded scalar. integer ( I8P ) :: scalar_I8 !< Decoded scalar. integer ( I4P ) :: scalar_I4 !< Decoded scalar. integer ( I2P ) :: scalar_I2 !< Decoded scalar. integer ( I1P ) :: scalar_I1 !< Decoded scalar. real ( R8P ) :: array_R8 ( 1 : 2 ) !< Decoded array. real ( R4P ) :: array_R4 ( 1 : 2 ) !< Decoded array. integer ( I8P ) :: array_I8 ( 1 : 4 ) !< Decoded array. integer ( I4P ) :: array_I4 ( 1 : 2 ) !< Decoded array. integer ( I2P ) :: array_I2 ( 1 : 2 ) !< Decoded array. integer ( I1P ) :: array_I1 ( 1 : 2 ) !< Decoded array. character ( 5 ) :: array_s ( 1 : 2 ) !< Decoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call b64_Init print \"(A)\" , 'Encoders' print \"(A)\" , 'Scalars' #ifdef r16p call b64_encode ( n = 13 4.231_R16P , code = code64 ) ok = code64 == 'CKwcWmTHYEA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 13 4.231_R16P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'CKwcWmTHYEA=' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = 1._R8P , code = code64 ) ok = code64 == 'AAAAAAAA8D8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 1._R8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 0._R4P , code = code64 ) ok = code64 == 'AAAAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 0._R4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 23_I8P , code = code64 ) ok = code64 == 'FwAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 23_I8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 2023_I4P , code = code64 ) ok = code64 == '5wcAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 2023_I4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n =- 203_I2P , code = code64 ) ok = code64 == 'Nf8=' print \"(A)\" , '+ Code of ' // trim ( str ( n =- 203_I2P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 120_I1P , code = code64 ) ok = code64 == 'eA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 120_I1P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = 'hello' , code = code64 ) ok = code64 == 'aGVsbG8=' print \"(A)\" , '+ Code of hello: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG8=' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' #ifdef r16p call b64_encode ( n = [ 12 1._R16P , 2.32_R16P ], code = code64 ) ok = code64 == 'AAAAAABAXkCPwvUoXI8CQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 12 1._R16P , 2.32_R16P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAABAXkCPwvUoXI8CQA==' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = [ 1._R8P , 2._R8P ], code = code64 ) ok = code64 == 'AAAAAAAA8D8AAAAAAAAAQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8AAAAAAAAAQA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 0._R4P , - 3 2.12_R4P ], code = code64 ) ok = code64 == 'AAAAAOF6AMI=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAOF6AMI=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], code = code64 ) ok = code64 == 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 2023_I4P , - 24_I4P ], code = code64 ) ok = code64 == '5wcAAOj///8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAOj///8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ - 203_I2P , - 10_I2P ], code = code64 ) ok = code64 == 'Nf/2/w==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf/2/w==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 120_I1P , - 1_I1P ], code = code64 ) ok = code64 == 'eP8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eP8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = [ 'hello' , 'world' ], code = code64 ) ok = code64 == 'aGVsbG93b3JsZA==' print \"(A)\" , '+ Code of [hello,world]: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG93b3JsZA==' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Decoders' print \"(A)\" , 'Scalars' call b64_decode ( code = 'AAAAAAAA8D8=' , n = scalar_R8 ) ok = str ( n = scalar_R8 ) == str ( n = 1._R8P ) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8=' // ': \"' // trim ( str ( n = scalar_R8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 1._R8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAA==' , n = scalar_R4 ) ok = str ( n = scalar_R4 ) == str ( n = 0._R4P ) print \"(A)\" , '+ Decode of ' // 'AAAAAA==' // ': \"' // trim ( str ( n = scalar_R4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 0._R4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'FwAAAAAAAAA=' , n = scalar_I8 ) ok = str ( n = scalar_I8 ) == str ( n = 23_I8P ) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAAA=' // ': \"' // trim ( str ( n = scalar_I8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 23_I8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAA==' , n = scalar_I4 ) ok = str ( n = scalar_I4 ) == str ( n = 2023_I4P ) print \"(A)\" , '+ Decode of ' // '5wcAAA==' // ': \"' // trim ( str ( n = scalar_I4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 2023_I4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf8=' , n = scalar_I2 ) ok = str ( n = scalar_I2 ) == str ( n =- 203_I2P ) print \"(A)\" , '+ Decode of ' // 'Nf8=' // ': \"' // trim ( str ( n = scalar_I2 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n =- 203_I2P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eA==' , n = scalar_I1 ) ok = str ( n = scalar_I1 ) == str ( n = 120_I1P ) print \"(A)\" , '+ Decode of ' // 'eA==' // ': \"' // trim ( str ( n = scalar_I1 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 120_I1P )) // '\", Is it correct?' , ok if (. not . ok ) stop code64 = repeat ( ' ' , 5 ) call b64_decode ( code = 'aGVsbG8=' , s = code64 ) ok = 'hello' == code64 print \"(A)\" , '+ Decode of ' // 'aGVsbG8=' // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected value: \"hello\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' call b64_decode ( code = 'AAAAAAAA8D8AAAAAAAAAQA==' , n = array_R8 ) ok = str ( n = array_R8 ) == str ( n = [ 1._R8P , 2._R8P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8AAAAAAAAAQA==' // ': \"' // trim ( str ( n = array_R8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAOF6AMI=' , n = array_R4 ) ok = str ( n = array_R4 ) == str ( n = [ 0._R4P , - 3 2.12_R4P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAOF6AMI=' // ': \"' // trim ( str ( n = array_R4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop ! ok = test_decode_array(code=, input=) ; if (.not.ok) stop call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = array_I8 ) ok = str ( n = array_I8 ) == str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ]) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // ': \"' // & trim ( str ( n = array_I8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // & '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAOj///8=' , n = array_I4 ) ok = str ( n = array_I4 ) == str ( n = [ 2023_I4P , - 24_I4P ]) print \"(A)\" , '+ Decode of ' // '5wcAAOj///8=' // ': \"' // trim ( str ( n = array_I4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf/2/w==' , n = array_I2 ) ok = str ( n = array_I2 ) == str ( n = [ - 203_I2P , - 10_I2P ]) print \"(A)\" , '+ Decode of ' // 'Nf/2/w==' // ': \"' // trim ( str ( n = array_I2 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eP8=' , n = array_I1 ) ok = str ( n = array_I1 ) == str ( n = [ 120_I1P , - 1_I1P ]) print \"(A)\" , '+ Decode of ' // 'eP8=' // ': \"' // trim ( str ( n = array_I1 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'aGVsbG93b3JsZA==' , s = array_s ) ok = array_s ( 1 ) // array_s ( 2 ) == 'helloworld' print \"(A)\" , '+ Decode of ' // 'aGVsbG93b3JsZA==' // ': \"' // array_s ( 1 ) // array_s ( 2 ) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"helloworld\", Is it correct?' , ok if (. not . ok ) stop return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine autotest","tags":"","loc":"proc/autotest.html","title":"autotest – StringiFor"},{"text":"public interface b64_encode Encode numbers (integer and real) to base64. This is an interface for encoding integer and real numbers of any kinds into a base64 string. This interface can encode both\n scalar and array. Warning The encoded string is returned as varying length character string, character(len=:), allocatable:: string , thus the\n compiler must support such a Fortran (2003) feature. Note Before start to encode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = 1 2._R8P , code = code64 ) Array encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = [ 12_I4P , 1_I4P ], code = code64 ) Note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The encoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_encode~~CallsGraph interface~b64_encode b64_encode proc~b64_encode_r8 b64_encode_R8 interface~b64_encode->proc~b64_encode_r8 proc~b64_encode_i1 b64_encode_I1 interface~b64_encode->proc~b64_encode_i1 proc~b64_encode_i4_a b64_encode_I4_a interface~b64_encode->proc~b64_encode_i4_a proc~b64_encode_i1_a b64_encode_I1_a interface~b64_encode->proc~b64_encode_i1_a proc~b64_encode_string b64_encode_string interface~b64_encode->proc~b64_encode_string proc~b64_encode_r4_a b64_encode_R4_a interface~b64_encode->proc~b64_encode_r4_a proc~b64_encode_r4 b64_encode_R4 interface~b64_encode->proc~b64_encode_r4 proc~b64_encode_string_a b64_encode_string_a interface~b64_encode->proc~b64_encode_string_a proc~b64_encode_i8 b64_encode_I8 interface~b64_encode->proc~b64_encode_i8 proc~b64_encode_i2 b64_encode_I2 interface~b64_encode->proc~b64_encode_i2 proc~b64_encode_r8_a b64_encode_R8_a interface~b64_encode->proc~b64_encode_r8_a proc~b64_encode_i2_a b64_encode_I2_a interface~b64_encode->proc~b64_encode_i2_a proc~b64_encode_i4 b64_encode_I4 interface~b64_encode->proc~b64_encode_i4 proc~b64_encode_i8_a b64_encode_I8_a interface~b64_encode->proc~b64_encode_i8_a proc~encode_bits encode_bits proc~b64_encode_r8->proc~encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_string->proc~encode_bits interface~byte_size byte_size proc~b64_encode_string->interface~byte_size proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_string_a->proc~encode_bits proc~b64_encode_string_a->interface~byte_size proc~b64_encode_i8->proc~encode_bits proc~b64_encode_i2->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i4->proc~encode_bits proc~b64_encode_i8_a->proc~encode_bits proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~b64_encode~~CalledByGraph interface~b64_encode b64_encode proc~encode encode proc~encode->interface~b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine b64_encode_R8 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). private pure subroutine b64_encode_R8_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). private pure subroutine b64_encode_R4 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). private pure subroutine b64_encode_R4_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). private pure subroutine b64_encode_I8 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). private pure subroutine b64_encode_I8_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). private pure subroutine b64_encode_I4 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). private pure subroutine b64_encode_I4_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). private pure subroutine b64_encode_I2 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). private pure subroutine b64_encode_I2_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). private pure subroutine b64_encode_I1 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). private pure subroutine b64_encode_I1_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). private pure subroutine b64_encode_string (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. private pure subroutine b64_encode_string_a (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64.","tags":"","loc":"interface/b64_encode.html","title":"b64_encode – StringiFor"},{"text":"public interface b64_encode_up Encode unlimited polymorphic variable to base64. This is an interface for encoding both scalar and array. Warning The encoded string is returned as varying length character string, character(len=:), allocatable:: string , thus the\n compiler must support such a Fortran (2003) feature. Note Before start to encode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode_up ( up = 1 2._R8P , code = code64 ) Array encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode_up ( up = [ 12_I4P , 1_I4P ], code = code64 ) Note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The encoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_encode_up~~CallsGraph interface~b64_encode_up b64_encode_up interface~b64_encode_up->interface~b64_encode_up proc~b64_encode_up_a b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_up_a->proc~b64_encode_i2_a proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_up_a->proc~b64_encode_i1_a proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_up_a->proc~b64_encode_r4_a proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_up_a->proc~b64_encode_i8_a proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_up_a->proc~b64_encode_string_a proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_up_a->proc~b64_encode_i4_a proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_up_a->proc~b64_encode_r8_a proc~encode_bits encode_bits proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_string_a->proc~encode_bits interface~byte_size byte_size proc~b64_encode_string_a->interface~byte_size proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public interface b64_encode_up () Arguments None Description Encode unlimited polymorphic variable to base64. private pure subroutine b64_encode_up_a (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64.","tags":"","loc":"interface/b64_encode_up.html","title":"b64_encode_up – StringiFor"},{"text":"public interface b64_decode Decode numbers (integer and real) from base64. This is an interface for decoding integer and real numbers of any kinds from a base64 string. This interface can decode both\n scalar and array. Note Before start to decode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar decoding real ( R8P ) :: decoded ! scalar to be decoded ... call b64_decode ( code = 'AAAAAAAA8D8=' , n = decoded ) Array decoding integer ( I8P ) :: decoded ( 1 : 4 ) ! array to be decoded ... call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = decoded ) Note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The decoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_decode~~CallsGraph interface~b64_decode b64_decode proc~b64_decode_i4_a b64_decode_I4_a interface~b64_decode->proc~b64_decode_i4_a proc~b64_decode_r8 b64_decode_R8 interface~b64_decode->proc~b64_decode_r8 proc~b64_decode_i1 b64_decode_I1 interface~b64_decode->proc~b64_decode_i1 proc~b64_decode_r8_a b64_decode_R8_a interface~b64_decode->proc~b64_decode_r8_a proc~b64_decode_r4 b64_decode_R4 interface~b64_decode->proc~b64_decode_r4 proc~b64_decode_i1_a b64_decode_I1_a interface~b64_decode->proc~b64_decode_i1_a proc~b64_decode_string_a b64_decode_string_a interface~b64_decode->proc~b64_decode_string_a proc~b64_decode_r4_a b64_decode_R4_a interface~b64_decode->proc~b64_decode_r4_a proc~b64_decode_i8 b64_decode_I8 interface~b64_decode->proc~b64_decode_i8 proc~b64_decode_i2 b64_decode_I2 interface~b64_decode->proc~b64_decode_i2 proc~b64_decode_i8_a b64_decode_I8_a interface~b64_decode->proc~b64_decode_i8_a proc~b64_decode_string b64_decode_string interface~b64_decode->proc~b64_decode_string proc~b64_decode_i4 b64_decode_I4 interface~b64_decode->proc~b64_decode_i4 proc~b64_decode_i2_a b64_decode_I2_a interface~b64_decode->proc~b64_decode_i2_a proc~decode_bits decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_i1->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string_a->interface~byte_size proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_i8->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_string->proc~decode_bits proc~b64_decode_string->interface~byte_size proc~b64_decode_i4->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~b64_decode~~CalledByGraph interface~b64_decode b64_decode proc~autotest autotest proc~autotest->interface~b64_decode proc~decode decode proc~decode->interface~b64_decode program~test_driver Test_Driver program~test_driver->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental subroutine b64_decode_R8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). private pure subroutine b64_decode_R8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). private elemental subroutine b64_decode_R4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). private pure subroutine b64_decode_R4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). private elemental subroutine b64_decode_I8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). private pure subroutine b64_decode_I8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). private elemental subroutine b64_decode_I4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). private pure subroutine b64_decode_I4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). private elemental subroutine b64_decode_I2 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). private pure subroutine b64_decode_I2_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). private elemental subroutine b64_decode_I1 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). private pure subroutine b64_decode_I1_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). private elemental subroutine b64_decode_string (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. private pure subroutine b64_decode_string_a (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings.","tags":"","loc":"interface/b64_decode.html","title":"b64_decode – StringiFor"},{"text":"public interface b64_decode_up Decode unlimited polymorphic variable from base64. This is an interface for decoding both scalar and array. Note Before start to decode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar decoding real ( R8P ) :: decoded ! scalar to be decoded ... call b64_decode_up ( code = 'AAAAAAAA8D8=' , up = decoded ) Array decoding integer ( I8P ) :: decoded ( 1 : 4 ) ! array to be decoded ... call b64_decode_up ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , up = decoded ) Note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The decoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_decode_up~~CallsGraph interface~b64_decode_up b64_decode_up interface~b64_decode_up->interface~b64_decode_up proc~b64_decode_up_a b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_up_a->proc~b64_decode_i4_a proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_up_a->proc~b64_decode_r4_a proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_up_a->proc~b64_decode_i2_a proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_up_a->proc~b64_decode_i1_a proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_up_a->proc~b64_decode_r8_a proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_up_a->proc~b64_decode_i8_a proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_up_a->proc~b64_decode_string_a proc~decode_bits decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string_a->interface~byte_size proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public interface b64_decode_up () Arguments None Description Decode unlimited polymorphic variable from base64. private subroutine b64_decode_up_a (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64.","tags":"","loc":"interface/b64_decode_up.html","title":"b64_decode_up – StringiFor"},{"text":"private elemental function bit_size_R16P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Compute the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P","tags":"","loc":"proc/bit_size_r16p~2.html","title":"bit_size_R16P – StringiFor"},{"text":"private elemental function bit_size_R8P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. Called By proc~~bit_size_r8p~2~~CalledByGraph proc~bit_size_r8p~2 bit_size_R8P interface~bit_size~2 bit_size interface~bit_size~2->proc~bit_size_r8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P","tags":"","loc":"proc/bit_size_r8p~2.html","title":"bit_size_R8P – StringiFor"},{"text":"private elemental function bit_size_R4P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. Called By proc~~bit_size_r4p~2~~CalledByGraph proc~bit_size_r4p~2 bit_size_R4P interface~bit_size~2 bit_size interface~bit_size~2->proc~bit_size_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P","tags":"","loc":"proc/bit_size_r4p~2.html","title":"bit_size_R4P – StringiFor"},{"text":"private elemental function bit_size_chr(i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. Called By proc~~bit_size_chr~2~~CalledByGraph proc~bit_size_chr~2 bit_size_chr interface~bit_size~2 bit_size interface~bit_size~2->proc~bit_size_chr~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr","tags":"","loc":"proc/bit_size_chr~2.html","title":"bit_size_chr – StringiFor"},{"text":"private elemental function byte_size_I8P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i8p~2~~CalledByGraph proc~byte_size_i8p~2 byte_size_I8P interface~byte_size~2 byte_size interface~byte_size~2->proc~byte_size_i8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P","tags":"","loc":"proc/byte_size_i8p~2.html","title":"byte_size_I8P – StringiFor"},{"text":"private elemental function byte_size_I4P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i4p~2~~CalledByGraph proc~byte_size_i4p~2 byte_size_I4P interface~byte_size~2 byte_size interface~byte_size~2->proc~byte_size_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P","tags":"","loc":"proc/byte_size_i4p~2.html","title":"byte_size_I4P – StringiFor"},{"text":"private elemental function byte_size_I2P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i2p~2~~CalledByGraph proc~byte_size_i2p~2 byte_size_I2P interface~byte_size~2 byte_size interface~byte_size~2->proc~byte_size_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P","tags":"","loc":"proc/byte_size_i2p~2.html","title":"byte_size_I2P – StringiFor"},{"text":"private elemental function byte_size_I1P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i1p~2~~CalledByGraph proc~byte_size_i1p~2 byte_size_I1P interface~byte_size~2 byte_size interface~byte_size~2->proc~byte_size_i1p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P","tags":"","loc":"proc/byte_size_i1p~2.html","title":"byte_size_I1P – StringiFor"},{"text":"private elemental function byte_size_R16P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Source Code elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P","tags":"","loc":"proc/byte_size_r16p~2.html","title":"byte_size_R16P – StringiFor"},{"text":"private elemental function byte_size_R8P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Called By proc~~byte_size_r8p~2~~CalledByGraph proc~byte_size_r8p~2 byte_size_R8P interface~byte_size~2 byte_size interface~byte_size~2->proc~byte_size_r8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P","tags":"","loc":"proc/byte_size_r8p~2.html","title":"byte_size_R8P – StringiFor"},{"text":"private elemental function byte_size_R4P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Called By proc~~byte_size_r4p~2~~CalledByGraph proc~byte_size_r4p~2 byte_size_R4P interface~byte_size~2 byte_size interface~byte_size~2->proc~byte_size_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P","tags":"","loc":"proc/byte_size_r4p~2.html","title":"byte_size_R4P – StringiFor"},{"text":"private elemental function byte_size_chr(i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable. Called By proc~~byte_size_chr~2~~CalledByGraph proc~byte_size_chr~2 byte_size_chr interface~byte_size~2 byte_size interface~byte_size~2->proc~byte_size_chr~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr","tags":"","loc":"proc/byte_size_chr~2.html","title":"byte_size_chr – StringiFor"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. Calls interface~~bit_size~2~~CallsGraph interface~bit_size~2 bit_size proc~bit_size_r4p~2 bit_size_R4P interface~bit_size~2->proc~bit_size_r4p~2 proc~bit_size_r8p~2 bit_size_R8P interface~bit_size~2->proc~bit_size_r8p~2 proc~bit_size_chr~2 bit_size_chr interface~bit_size~2->proc~bit_size_chr~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable.","tags":"","loc":"interface/bit_size~2.html","title":"bit_size – StringiFor"},{"text":"public interface byte_size Compute the number of bytes of a variable. Calls interface~~byte_size~2~~CallsGraph interface~byte_size~2 byte_size proc~byte_size_i1p~2 byte_size_I1P interface~byte_size~2->proc~byte_size_i1p~2 proc~byte_size_chr~2 byte_size_chr interface~byte_size~2->proc~byte_size_chr~2 proc~byte_size_i4p~2 byte_size_I4P interface~byte_size~2->proc~byte_size_i4p~2 proc~byte_size_i8p~2 byte_size_I8P interface~byte_size~2->proc~byte_size_i8p~2 proc~byte_size_r8p~2 byte_size_R8P interface~byte_size~2->proc~byte_size_r8p~2 proc~byte_size_r4p~2 byte_size_R4P interface~byte_size~2->proc~byte_size_r4p~2 proc~byte_size_i2p~2 byte_size_I2P interface~byte_size~2->proc~byte_size_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable.","tags":"","loc":"interface/byte_size~2.html","title":"byte_size – StringiFor"},{"text":"private elemental function strf_R16P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. Source Code elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P","tags":"","loc":"proc/strf_r16p~2.html","title":"strf_R16P – StringiFor"},{"text":"private elemental function strf_R8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. Called By proc~~strf_r8p~2~~CalledByGraph proc~strf_r8p~2 strf_R8P interface~str~2 str interface~str~2->proc~strf_r8p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P","tags":"","loc":"proc/strf_r8p~2.html","title":"strf_R8P – StringiFor"},{"text":"private elemental function strf_R4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. Called By proc~~strf_r4p~2~~CalledByGraph proc~strf_r4p~2 strf_R4P interface~str~2 str interface~str~2->proc~strf_r4p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P","tags":"","loc":"proc/strf_r4p~2.html","title":"strf_R4P – StringiFor"},{"text":"private elemental function strf_I8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i8p~2~~CalledByGraph proc~strf_i8p~2 strf_I8P interface~str~2 str interface~str~2->proc~strf_i8p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P","tags":"","loc":"proc/strf_i8p~2.html","title":"strf_I8P – StringiFor"},{"text":"private elemental function strf_I4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i4p~2~~CalledByGraph proc~strf_i4p~2 strf_I4P interface~str~2 str interface~str~2->proc~strf_i4p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P","tags":"","loc":"proc/strf_i4p~2.html","title":"strf_I4P – StringiFor"},{"text":"private elemental function strf_I2P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i2p~2~~CalledByGraph proc~strf_i2p~2 strf_I2P interface~str~2 str interface~str~2->proc~strf_i2p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P","tags":"","loc":"proc/strf_i2p~2.html","title":"strf_I2P – StringiFor"},{"text":"private elemental function strf_I1P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i1p~2~~CalledByGraph proc~strf_i1p~2 strf_I1P interface~str~2 str interface~str~2->proc~strf_i1p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P","tags":"","loc":"proc/strf_i1p~2.html","title":"strf_I1P – StringiFor"},{"text":"private elemental function str_R16P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r16p~2~~CalledByGraph proc~str_r16p~2 str_R16P proc~str_a_r16p~2 str_a_R16P proc~str_a_r16p~2->proc~str_r16p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R16P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P","tags":"","loc":"proc/str_r16p~2.html","title":"str_R16P – StringiFor"},{"text":"private elemental function str_R8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r8p~2~~CalledByGraph proc~str_r8p~2 str_R8P proc~str_a_r8p~2 str_a_R8P proc~str_a_r8p~2->proc~str_r8p~2 interface~str~2 str interface~str~2->proc~str_r8p~2 interface~str~2->proc~str_a_r8p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P","tags":"","loc":"proc/str_r8p~2.html","title":"str_R8P – StringiFor"},{"text":"private elemental function str_R4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r4p~2~~CalledByGraph proc~str_r4p~2 str_R4P proc~str_a_r4p~2 str_a_R4P proc~str_a_r4p~2->proc~str_r4p~2 interface~str~2 str interface~str~2->proc~str_r4p~2 interface~str~2->proc~str_a_r4p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P","tags":"","loc":"proc/str_r4p~2.html","title":"str_R4P – StringiFor"},{"text":"private elemental function str_I8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i8p~2~~CalledByGraph proc~str_i8p~2 str_I8P proc~str_a_i8p~2 str_a_I8P proc~str_a_i8p~2->proc~str_i8p~2 interface~str~2 str interface~str~2->proc~str_i8p~2 interface~str~2->proc~str_a_i8p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P","tags":"","loc":"proc/str_i8p~2.html","title":"str_I8P – StringiFor"},{"text":"private elemental function str_I4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. Called By proc~~str_i4p~2~~CalledByGraph proc~str_i4p~2 str_I4P proc~str_a_i4p~2 str_a_I4P proc~str_a_i4p~2->proc~str_i4p~2 interface~str~2 str interface~str~2->proc~str_i4p~2 interface~str~2->proc~str_a_i4p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P","tags":"","loc":"proc/str_i4p~2.html","title":"str_I4P – StringiFor"},{"text":"private elemental function str_I2P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i2p~2~~CalledByGraph proc~str_i2p~2 str_I2P proc~str_a_i2p~2 str_a_I2P proc~str_a_i2p~2->proc~str_i2p~2 interface~str~2 str interface~str~2->proc~str_i2p~2 interface~str~2->proc~str_a_i2p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P","tags":"","loc":"proc/str_i2p~2.html","title":"str_I2P – StringiFor"},{"text":"private elemental function str_I1P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i1p~2~~CalledByGraph proc~str_i1p~2 str_I1P proc~str_a_i1p~2 str_a_I1P proc~str_a_i1p~2->proc~str_i1p~2 interface~str~2 str interface~str~2->proc~str_i1p~2 interface~str~2->proc~str_a_i1p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P","tags":"","loc":"proc/str_i1p~2.html","title":"str_I1P – StringiFor"},{"text":"private elemental function str_bol(n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. Called By proc~~str_bol~2~~CalledByGraph proc~str_bol~2 str_bol interface~str~2 str interface~str~2->proc~str_bol~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol","tags":"","loc":"proc/str_bol~2.html","title":"str_bol – StringiFor"},{"text":"private pure function str_a_R16P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Converting real array to string. Calls proc~~str_a_r16p~2~~CallsGraph proc~str_a_r16p~2 str_a_R16P proc~str_r16p~2 str_R16P proc~str_a_r16p~2->proc~str_r16p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR16P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R16P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P","tags":"","loc":"proc/str_a_r16p~2.html","title":"str_a_R16P – StringiFor"},{"text":"private pure function str_a_R8P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. Calls proc~~str_a_r8p~2~~CallsGraph proc~str_a_r8p~2 str_a_R8P proc~str_r8p~2 str_R8P proc~str_a_r8p~2->proc~str_r8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_r8p~2~~CalledByGraph proc~str_a_r8p~2 str_a_R8P interface~str~2 str interface~str~2->proc~str_a_r8p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P","tags":"","loc":"proc/str_a_r8p~2.html","title":"str_a_R8P – StringiFor"},{"text":"private pure function str_a_R4P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. Calls proc~~str_a_r4p~2~~CallsGraph proc~str_a_r4p~2 str_a_R4P proc~str_r4p~2 str_R4P proc~str_a_r4p~2->proc~str_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_r4p~2~~CalledByGraph proc~str_a_r4p~2 str_a_R4P interface~str~2 str interface~str~2->proc~str_a_r4p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P","tags":"","loc":"proc/str_a_r4p~2.html","title":"str_a_R4P – StringiFor"},{"text":"private pure function str_a_I8P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i8p~2~~CallsGraph proc~str_a_i8p~2 str_a_I8P proc~str_i8p~2 str_I8P proc~str_a_i8p~2->proc~str_i8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i8p~2~~CalledByGraph proc~str_a_i8p~2 str_a_I8P interface~str~2 str interface~str~2->proc~str_a_i8p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P","tags":"","loc":"proc/str_a_i8p~2.html","title":"str_a_I8P – StringiFor"},{"text":"private pure function str_a_I4P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i4p~2~~CallsGraph proc~str_a_i4p~2 str_a_I4P proc~str_i4p~2 str_I4P proc~str_a_i4p~2->proc~str_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i4p~2~~CalledByGraph proc~str_a_i4p~2 str_a_I4P interface~str~2 str interface~str~2->proc~str_a_i4p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P","tags":"","loc":"proc/str_a_i4p~2.html","title":"str_a_I4P – StringiFor"},{"text":"private pure function str_a_I2P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i2p~2~~CallsGraph proc~str_a_i2p~2 str_a_I2P proc~str_i2p~2 str_I2P proc~str_a_i2p~2->proc~str_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i2p~2~~CalledByGraph proc~str_a_i2p~2 str_a_I2P interface~str~2 str interface~str~2->proc~str_a_i2p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I2P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P","tags":"","loc":"proc/str_a_i2p~2.html","title":"str_a_I2P – StringiFor"},{"text":"private pure function str_a_I1P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i1p~2~~CallsGraph proc~str_a_i1p~2 str_a_I1P proc~str_i1p~2 str_I1P proc~str_a_i1p~2->proc~str_i1p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i1p~2~~CalledByGraph proc~str_a_i1p~2 str_a_I1P interface~str~2 str interface~str~2->proc~str_a_i1p~2 proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I1P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P","tags":"","loc":"proc/str_a_i1p~2.html","title":"str_a_I1P – StringiFor"},{"text":"private elemental function strz_I8P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. Called By proc~~strz_i8p~2~~CalledByGraph proc~strz_i8p~2 strz_I8P interface~strz~2 strz interface~strz~2->proc~strz_i8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P","tags":"","loc":"proc/strz_i8p~2.html","title":"strz_I8P – StringiFor"},{"text":"private elemental function strz_I4P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i4p~2~~CalledByGraph proc~strz_i4p~2 strz_I4P interface~strz~2 strz interface~strz~2->proc~strz_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P","tags":"","loc":"proc/strz_i4p~2.html","title":"strz_I4P – StringiFor"},{"text":"private elemental function strz_I2P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i2p~2~~CalledByGraph proc~strz_i2p~2 strz_I2P interface~strz~2 strz interface~strz~2->proc~strz_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P","tags":"","loc":"proc/strz_i2p~2.html","title":"strz_I2P – StringiFor"},{"text":"private elemental function strz_I1P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i1p~2~~CalledByGraph proc~strz_i1p~2 strz_I1P interface~strz~2 strz interface~strz~2->proc~strz_i1p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P","tags":"","loc":"proc/strz_i1p~2.html","title":"strz_I1P – StringiFor"},{"text":"private function ctor_R16P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Description Convert string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P","tags":"","loc":"proc/ctor_r16p~2.html","title":"ctor_R16P – StringiFor"},{"text":"private function ctor_R8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. Called By proc~~ctor_r8p~2~~CalledByGraph proc~ctor_r8p~2 ctor_R8P interface~cton~2 cton interface~cton~2->proc~ctor_r8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P","tags":"","loc":"proc/ctor_r8p~2.html","title":"ctor_R8P – StringiFor"},{"text":"private function ctor_R4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. Called By proc~~ctor_r4p~2~~CalledByGraph proc~ctor_r4p~2 ctor_R4P interface~cton~2 cton interface~cton~2->proc~ctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P","tags":"","loc":"proc/ctor_r4p~2.html","title":"ctor_R4P – StringiFor"},{"text":"private function ctoi_I8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i8p~2~~CalledByGraph proc~ctoi_i8p~2 ctoi_I8P interface~cton~2 cton interface~cton~2->proc~ctoi_i8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P","tags":"","loc":"proc/ctoi_i8p~2.html","title":"ctoi_I8P – StringiFor"},{"text":"private function ctoi_I4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i4p~2~~CalledByGraph proc~ctoi_i4p~2 ctoi_I4P interface~cton~2 cton interface~cton~2->proc~ctoi_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P","tags":"","loc":"proc/ctoi_i4p~2.html","title":"ctoi_I4P – StringiFor"},{"text":"private function ctoi_I2P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i2p~2~~CalledByGraph proc~ctoi_i2p~2 ctoi_I2P interface~cton~2 cton interface~cton~2->proc~ctoi_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P","tags":"","loc":"proc/ctoi_i2p~2.html","title":"ctoi_I2P – StringiFor"},{"text":"private function ctoi_I1P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i1p~2~~CalledByGraph proc~ctoi_i1p~2 ctoi_I1P interface~cton~2 cton interface~cton~2->proc~ctoi_i1p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P","tags":"","loc":"proc/ctoi_i1p~2.html","title":"ctoi_I1P – StringiFor"},{"text":"private elemental function bstr_R16P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. Source Code elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P","tags":"","loc":"proc/bstr_r16p~2.html","title":"bstr_R16P – StringiFor"},{"text":"private elemental function bstr_R8P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. Called By proc~~bstr_r8p~2~~CalledByGraph proc~bstr_r8p~2 bstr_R8P interface~bstr~2 bstr interface~bstr~2->proc~bstr_r8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P","tags":"","loc":"proc/bstr_r8p~2.html","title":"bstr_R8P – StringiFor"},{"text":"private elemental function bstr_R4P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. Called By proc~~bstr_r4p~2~~CalledByGraph proc~bstr_r4p~2 bstr_R4P interface~bstr~2 bstr interface~bstr~2->proc~bstr_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P","tags":"","loc":"proc/bstr_r4p~2.html","title":"bstr_R4P – StringiFor"},{"text":"private elemental function bstr_I8P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. Called By proc~~bstr_i8p~2~~CalledByGraph proc~bstr_i8p~2 bstr_I8P interface~bstr~2 bstr interface~bstr~2->proc~bstr_i8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P","tags":"","loc":"proc/bstr_i8p~2.html","title":"bstr_I8P – StringiFor"},{"text":"private elemental function bstr_I4P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. Called By proc~~bstr_i4p~2~~CalledByGraph proc~bstr_i4p~2 bstr_I4P interface~bstr~2 bstr interface~bstr~2->proc~bstr_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P","tags":"","loc":"proc/bstr_i4p~2.html","title":"bstr_I4P – StringiFor"},{"text":"private elemental function bstr_I2P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. Called By proc~~bstr_i2p~2~~CalledByGraph proc~bstr_i2p~2 bstr_I2P interface~bstr~2 bstr interface~bstr~2->proc~bstr_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P","tags":"","loc":"proc/bstr_i2p~2.html","title":"bstr_I2P – StringiFor"},{"text":"private elemental function bstr_I1P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. Called By proc~~bstr_i1p~2~~CalledByGraph proc~bstr_i1p~2 bstr_I1P interface~bstr~2 bstr interface~bstr~2->proc~bstr_i1p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P","tags":"","loc":"proc/bstr_i1p~2.html","title":"bstr_I1P – StringiFor"},{"text":"private elemental function bctor_R16P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r16p~2~~CallsGraph proc~bctor_r16p~2 bctor_R16P interface~str~2 str proc~bctor_r16p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P","tags":"","loc":"proc/bctor_r16p~2.html","title":"bctor_R16P – StringiFor"},{"text":"private elemental function bctor_R8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r8p~2~~CallsGraph proc~bctor_r8p~2 bctor_R8P interface~str~2 str proc~bctor_r8p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctor_r8p~2~~CalledByGraph proc~bctor_r8p~2 bctor_R8P interface~bcton~2 bcton interface~bcton~2->proc~bctor_r8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P","tags":"","loc":"proc/bctor_r8p~2.html","title":"bctor_R8P – StringiFor"},{"text":"private elemental function bctor_R4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r4p~2~~CallsGraph proc~bctor_r4p~2 bctor_R4P interface~str~2 str proc~bctor_r4p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctor_r4p~2~~CalledByGraph proc~bctor_r4p~2 bctor_R4P interface~bcton~2 bcton interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P","tags":"","loc":"proc/bctor_r4p~2.html","title":"bctor_R4P – StringiFor"},{"text":"private elemental function bctoi_I8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i8p~2~~CallsGraph proc~bctoi_i8p~2 bctoi_I8P interface~str~2 str proc~bctoi_i8p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i8p~2~~CalledByGraph proc~bctoi_i8p~2 bctoi_I8P interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P","tags":"","loc":"proc/bctoi_i8p~2.html","title":"bctoi_I8P – StringiFor"},{"text":"private elemental function bctoi_I4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i4p~2~~CallsGraph proc~bctoi_i4p~2 bctoi_I4P interface~str~2 str proc~bctoi_i4p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i4p~2~~CalledByGraph proc~bctoi_i4p~2 bctoi_I4P interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P","tags":"","loc":"proc/bctoi_i4p~2.html","title":"bctoi_I4P – StringiFor"},{"text":"private elemental function bctoi_I2P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i2p~2~~CallsGraph proc~bctoi_i2p~2 bctoi_I2P interface~str~2 str proc~bctoi_i2p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i2p~2~~CalledByGraph proc~bctoi_i2p~2 bctoi_I2P interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i2p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P","tags":"","loc":"proc/bctoi_i2p~2.html","title":"bctoi_I2P – StringiFor"},{"text":"private elemental function bctoi_I1P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i1p~2~~CallsGraph proc~bctoi_i1p~2 bctoi_I1P interface~str~2 str proc~bctoi_i1p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i1p~2~~CalledByGraph proc~bctoi_i1p~2 bctoi_I1P interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i1p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P","tags":"","loc":"proc/bctoi_i1p~2.html","title":"bctoi_I1P – StringiFor"},{"text":"public interface str Convert number (real and integer) to string (number to string type casting). Calls interface~~str~2~~CallsGraph interface~str~2 str proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~str~2~~CalledByGraph interface~str~2 str proc~bctoi_i8p~2 bctoi_I8P proc~bctoi_i8p~2->interface~str~2 proc~bctor_r16p~2 bctor_R16P proc~bctor_r16p~2->interface~str~2 proc~bctoi_i1p~2 bctoi_I1P proc~bctoi_i1p~2->interface~str~2 proc~bctoi_i4p~2 bctoi_I4P proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i2p~2 bctoi_I2P proc~bctoi_i2p~2->interface~str~2 proc~bctor_r8p~2 bctor_R8P proc~bctor_r8p~2->interface~str~2 proc~bctor_r4p~2 bctor_R4P proc~bctor_r4p~2->interface~str~2 interface~bcton~2 bcton interface~bcton~2->proc~bctoi_i8p~2 interface~bcton~2->proc~bctoi_i1p~2 interface~bcton~2->proc~bctoi_i4p~2 interface~bcton~2->proc~bctoi_i2p~2 interface~bcton~2->proc~bctor_r8p~2 interface~bcton~2->proc~bctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string.","tags":"","loc":"interface/str~2.html","title":"str – StringiFor"},{"text":"public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). Calls interface~~strz~2~~CallsGraph interface~strz~2 strz proc~strz_i2p~2 strz_I2P interface~strz~2->proc~strz_i2p~2 proc~strz_i1p~2 strz_I1P interface~strz~2->proc~strz_i1p~2 proc~strz_i8p~2 strz_I8P interface~strz~2->proc~strz_i8p~2 proc~strz_i4p~2 strz_I4P interface~strz~2->proc~strz_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros.","tags":"","loc":"interface/strz~2.html","title":"strz – StringiFor"},{"text":"public interface cton Convert string to number (real and integer, string to number type casting). Calls interface~~cton~2~~CallsGraph interface~cton~2 cton proc~ctoi_i1p~2 ctoi_I1P interface~cton~2->proc~ctoi_i1p~2 proc~ctoi_i8p~2 ctoi_I8P interface~cton~2->proc~ctoi_i8p~2 proc~ctoi_i4p~2 ctoi_I4P interface~cton~2->proc~ctoi_i4p~2 proc~ctor_r8p~2 ctor_R8P interface~cton~2->proc~ctor_r8p~2 proc~ctoi_i2p~2 ctoi_I2P interface~cton~2->proc~ctoi_i2p~2 proc~ctor_r4p~2 ctor_R4P interface~cton~2->proc~ctor_r4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer.","tags":"","loc":"interface/cton~2.html","title":"cton – StringiFor"},{"text":"public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). Calls interface~~bstr~2~~CallsGraph interface~bstr~2 bstr proc~bstr_i8p~2 bstr_I8P interface~bstr~2->proc~bstr_i8p~2 proc~bstr_i2p~2 bstr_I2P interface~bstr~2->proc~bstr_i2p~2 proc~bstr_i4p~2 bstr_I4P interface~bstr~2->proc~bstr_i4p~2 proc~bstr_r8p~2 bstr_R8P interface~bstr~2->proc~bstr_r8p~2 proc~bstr_r4p~2 bstr_R4P interface~bstr~2->proc~bstr_r4p~2 proc~bstr_i1p~2 bstr_I1P interface~bstr~2->proc~bstr_i1p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits.","tags":"","loc":"interface/bstr~2.html","title":"bstr – StringiFor"},{"text":"public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). Calls interface~~bcton~2~~CallsGraph interface~bcton~2 bcton proc~bctoi_i8p~2 bctoi_I8P interface~bcton~2->proc~bctoi_i8p~2 proc~bctor_r4p~2 bctor_R4P interface~bcton~2->proc~bctor_r4p~2 proc~bctor_r8p~2 bctor_R8P interface~bcton~2->proc~bctor_r8p~2 proc~bctoi_i2p~2 bctoi_I2P interface~bcton~2->proc~bctoi_i2p~2 proc~bctoi_i4p~2 bctoi_I4P interface~bcton~2->proc~bctoi_i4p~2 proc~bctoi_i1p~2 bctoi_I1P interface~bcton~2->proc~bctoi_i1p~2 interface~str~2 str proc~bctoi_i8p~2->interface~str~2 proc~bctor_r4p~2->interface~str~2 proc~bctor_r8p~2->interface~str~2 proc~bctoi_i2p~2->interface~str~2 proc~bctoi_i4p~2->interface~str~2 proc~bctoi_i1p~2->interface~str~2 proc~str_bol~2 str_bol interface~str~2->proc~str_bol~2 proc~str_a_i8p~2 str_a_I8P interface~str~2->proc~str_a_i8p~2 proc~str_a_i2p~2 str_a_I2P interface~str~2->proc~str_a_i2p~2 proc~strf_r8p~2 strf_R8P interface~str~2->proc~strf_r8p~2 proc~str_i2p~2 str_I2P interface~str~2->proc~str_i2p~2 proc~str_a_r8p~2 str_a_R8P interface~str~2->proc~str_a_r8p~2 proc~str_i8p~2 str_I8P interface~str~2->proc~str_i8p~2 proc~strf_i2p~2 strf_I2P interface~str~2->proc~strf_i2p~2 proc~strf_r4p~2 strf_R4P interface~str~2->proc~strf_r4p~2 proc~str_i1p~2 str_I1P interface~str~2->proc~str_i1p~2 proc~str_a_r4p~2 str_a_R4P interface~str~2->proc~str_a_r4p~2 proc~str_a_i1p~2 str_a_I1P interface~str~2->proc~str_a_i1p~2 proc~str_a_i4p~2 str_a_I4P interface~str~2->proc~str_a_i4p~2 proc~strf_i8p~2 strf_I8P interface~str~2->proc~strf_i8p~2 proc~str_i4p~2 str_I4P interface~str~2->proc~str_i4p~2 proc~strf_i4p~2 strf_I4P interface~str~2->proc~strf_i4p~2 proc~str_r8p~2 str_R8P interface~str~2->proc~str_r8p~2 proc~strf_i1p~2 strf_I1P interface~str~2->proc~strf_i1p~2 proc~str_r4p~2 str_R4P interface~str~2->proc~str_r4p~2 proc~str_a_i8p~2->proc~str_i8p~2 proc~str_a_i2p~2->proc~str_i2p~2 proc~str_a_r8p~2->proc~str_r8p~2 proc~str_a_r4p~2->proc~str_r4p~2 proc~str_a_i1p~2->proc~str_i1p~2 proc~str_a_i4p~2->proc~str_i4p~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer.","tags":"","loc":"interface/bcton~2.html","title":"bcton – StringiFor"},{"text":"private elemental function digit_I8(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i8~2~~CalledByGraph proc~digit_i8~2 digit_I8 interface~digit~2 digit interface~digit~2->proc~digit_i8~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8","tags":"","loc":"proc/digit_i8~2.html","title":"digit_I8 – StringiFor"},{"text":"private elemental function digit_I4(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i4~2~~CalledByGraph proc~digit_i4~2 digit_I4 interface~digit~2 digit interface~digit~2->proc~digit_i4~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4","tags":"","loc":"proc/digit_i4~2.html","title":"digit_I4 – StringiFor"},{"text":"private elemental function digit_I2(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i2~2~~CalledByGraph proc~digit_i2~2 digit_I2 interface~digit~2 digit interface~digit~2->proc~digit_i2~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2","tags":"","loc":"proc/digit_i2~2.html","title":"digit_I2 – StringiFor"},{"text":"private elemental function digit_I1(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i1~2~~CalledByGraph proc~digit_i1~2 digit_I1 interface~digit~2 digit interface~digit~2->proc~digit_i1~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1","tags":"","loc":"proc/digit_i1~2.html","title":"digit_I1 – StringiFor"},{"text":"public subroutine check_endian() Arguments None Description Check the type of bit ordering (big or little endian) of the running architecture. Note The result is stored into the endian global variable. Calls proc~~check_endian~2~~CallsGraph proc~check_endian~2 check_endian none~is_little_endian~2 is_little_endian proc~check_endian~2->none~is_little_endian~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~check_endian~2~~CalledByGraph proc~check_endian~2 check_endian proc~penf_init~2 penf_init proc~penf_init~2->proc~check_endian~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions pure function is_little_endian() result(is_little) Arguments None Return Value logical Logical output: true is the running architecture uses little endian ordering, false otherwise. Description Check if the type of the bit ordering of the running architecture is little endian. Source Code subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian","tags":"","loc":"proc/check_endian~2.html","title":"check_endian – StringiFor"},{"text":"public subroutine penf_init() Arguments None Description Initialize PENF's variables that are not initialized into the definition specification. Calls proc~~penf_init~2~~CallsGraph proc~penf_init~2 penf_init proc~check_endian~2 check_endian proc~penf_init~2->proc~check_endian~2 none~is_little_endian~2 is_little_endian proc~check_endian~2->none~is_little_endian~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init","tags":"","loc":"proc/penf_init~2.html","title":"penf_init – StringiFor"},{"text":"public subroutine penf_print(unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print to the specified unit the PENF's environment data. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. Source Code subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print","tags":"","loc":"proc/penf_print~2.html","title":"penf_print – StringiFor"},{"text":"public interface digit Compute the number of digits in decimal base of the input integer. Calls interface~~digit~2~~CallsGraph interface~digit~2 digit proc~digit_i1~2 digit_I1 interface~digit~2->proc~digit_i1~2 proc~digit_i8~2 digit_I8 interface~digit~2->proc~digit_i8~2 proc~digit_i2~2 digit_I2 interface~digit~2->proc~digit_i2~2 proc~digit_i4~2 digit_I4 interface~digit~2->proc~digit_i4~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer.","tags":"","loc":"interface/digit~2.html","title":"digit – StringiFor"},{"text":"private elemental function bit_size_R16P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Compute the number of bits of a real variable. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P","tags":"","loc":"proc/bit_size_r16p~3.html","title":"bit_size_R16P – StringiFor"},{"text":"private elemental function bit_size_R8P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. Called By proc~~bit_size_r8p~3~~CalledByGraph proc~bit_size_r8p~3 bit_size_R8P interface~bit_size~3 bit_size interface~bit_size~3->proc~bit_size_r8p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P","tags":"","loc":"proc/bit_size_r8p~3.html","title":"bit_size_R8P – StringiFor"},{"text":"private elemental function bit_size_R4P(i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. Called By proc~~bit_size_r4p~3~~CalledByGraph proc~bit_size_r4p~3 bit_size_R4P interface~bit_size~3 bit_size interface~bit_size~3->proc~bit_size_r4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P","tags":"","loc":"proc/bit_size_r4p~3.html","title":"bit_size_R4P – StringiFor"},{"text":"private elemental function bit_size_chr(i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. Called By proc~~bit_size_chr~3~~CalledByGraph proc~bit_size_chr~3 bit_size_chr interface~bit_size~3 bit_size interface~bit_size~3->proc~bit_size_chr~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: mold (1) \"Molding\" dummy variable for bits counting. Source Code elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr","tags":"","loc":"proc/bit_size_chr~3.html","title":"bit_size_chr – StringiFor"},{"text":"private elemental function byte_size_I8P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i8p~3~~CalledByGraph proc~byte_size_i8p~3 byte_size_I8P interface~byte_size~3 byte_size interface~byte_size~3->proc~byte_size_i8p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P","tags":"","loc":"proc/byte_size_i8p~3.html","title":"byte_size_I8P – StringiFor"},{"text":"private elemental function byte_size_I4P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i4p~3~~CalledByGraph proc~byte_size_i4p~3 byte_size_I4P interface~byte_size~3 byte_size interface~byte_size~3->proc~byte_size_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P","tags":"","loc":"proc/byte_size_i4p~3.html","title":"byte_size_I4P – StringiFor"},{"text":"private elemental function byte_size_I2P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i2p~3~~CalledByGraph proc~byte_size_i2p~3 byte_size_I2P interface~byte_size~3 byte_size interface~byte_size~3->proc~byte_size_i2p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P","tags":"","loc":"proc/byte_size_i2p~3.html","title":"byte_size_I2P – StringiFor"},{"text":"private elemental function byte_size_I1P(i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. Called By proc~~byte_size_i1p~3~~CalledByGraph proc~byte_size_i1p~3 byte_size_I1P interface~byte_size~3 byte_size interface~byte_size~3->proc~byte_size_i1p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P","tags":"","loc":"proc/byte_size_i1p~3.html","title":"byte_size_I1P – StringiFor"},{"text":"private elemental function byte_size_R16P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Source Code elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P","tags":"","loc":"proc/byte_size_r16p~3.html","title":"byte_size_R16P – StringiFor"},{"text":"private elemental function byte_size_R8P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Called By proc~~byte_size_r8p~3~~CalledByGraph proc~byte_size_r8p~3 byte_size_R8P interface~byte_size~3 byte_size interface~byte_size~3->proc~byte_size_r8p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P","tags":"","loc":"proc/byte_size_r8p~3.html","title":"byte_size_R8P – StringiFor"},{"text":"private elemental function byte_size_R4P(i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. Called By proc~~byte_size_r4p~3~~CalledByGraph proc~byte_size_r4p~3 byte_size_R4P interface~byte_size~3 byte_size interface~byte_size~3->proc~byte_size_r4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P","tags":"","loc":"proc/byte_size_r4p~3.html","title":"byte_size_R4P – StringiFor"},{"text":"private elemental function byte_size_chr(i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable. Called By proc~~byte_size_chr~3~~CalledByGraph proc~byte_size_chr~3 byte_size_chr interface~byte_size~3 byte_size interface~byte_size~3->proc~byte_size_chr~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr","tags":"","loc":"proc/byte_size_chr~3.html","title":"byte_size_chr – StringiFor"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. Calls interface~~bit_size~3~~CallsGraph interface~bit_size~3 bit_size proc~bit_size_r8p~3 bit_size_R8P interface~bit_size~3->proc~bit_size_r8p~3 proc~bit_size_r4p~3 bit_size_R4P interface~bit_size~3->proc~bit_size_r4p~3 proc~bit_size_chr~3 bit_size_chr interface~bit_size~3->proc~bit_size_chr~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable.","tags":"","loc":"interface/bit_size~3.html","title":"bit_size – StringiFor"},{"text":"public interface byte_size Compute the number of bytes of a variable. Calls interface~~byte_size~3~~CallsGraph interface~byte_size~3 byte_size proc~byte_size_r8p~3 byte_size_R8P interface~byte_size~3->proc~byte_size_r8p~3 proc~byte_size_r4p~3 byte_size_R4P interface~byte_size~3->proc~byte_size_r4p~3 proc~byte_size_i2p~3 byte_size_I2P interface~byte_size~3->proc~byte_size_i2p~3 proc~byte_size_i1p~3 byte_size_I1P interface~byte_size~3->proc~byte_size_i1p~3 proc~byte_size_i8p~3 byte_size_I8P interface~byte_size~3->proc~byte_size_i8p~3 proc~byte_size_chr~3 byte_size_chr interface~byte_size~3->proc~byte_size_chr~3 proc~byte_size_i4p~3 byte_size_I4P interface~byte_size~3->proc~byte_size_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable.","tags":"","loc":"interface/byte_size~3.html","title":"byte_size – StringiFor"},{"text":"private elemental function strf_R16P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. Source Code elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P","tags":"","loc":"proc/strf_r16p~3.html","title":"strf_R16P – StringiFor"},{"text":"private elemental function strf_R8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. Called By proc~~strf_r8p~3~~CalledByGraph proc~strf_r8p~3 strf_R8P interface~str~3 str interface~str~3->proc~strf_r8p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P","tags":"","loc":"proc/strf_r8p~3.html","title":"strf_R8P – StringiFor"},{"text":"private elemental function strf_R4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. Called By proc~~strf_r4p~3~~CalledByGraph proc~strf_r4p~3 strf_R4P interface~str~3 str interface~str~3->proc~strf_r4p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P","tags":"","loc":"proc/strf_r4p~3.html","title":"strf_R4P – StringiFor"},{"text":"private elemental function strf_I8P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i8p~3~~CalledByGraph proc~strf_i8p~3 strf_I8P interface~str~3 str interface~str~3->proc~strf_i8p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P","tags":"","loc":"proc/strf_i8p~3.html","title":"strf_I8P – StringiFor"},{"text":"private elemental function strf_I4P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i4p~3~~CalledByGraph proc~strf_i4p~3 strf_I4P interface~str~3 str interface~str~3->proc~strf_i4p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P","tags":"","loc":"proc/strf_i4p~3.html","title":"strf_I4P – StringiFor"},{"text":"private elemental function strf_I2P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i2p~3~~CalledByGraph proc~strf_i2p~3 strf_I2P interface~str~3 str interface~str~3->proc~strf_i2p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P","tags":"","loc":"proc/strf_i2p~3.html","title":"strf_I2P – StringiFor"},{"text":"private elemental function strf_I1P(fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. Called By proc~~strf_i1p~3~~CalledByGraph proc~strf_i1p~3 strf_I1P interface~str~3 str interface~str~3->proc~strf_i1p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P","tags":"","loc":"proc/strf_i1p~3.html","title":"strf_I1P – StringiFor"},{"text":"private elemental function str_R16P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r16p~3~~CalledByGraph proc~str_r16p~3 str_R16P proc~str_a_r16p~3 str_a_R16P proc~str_a_r16p~3->proc~str_r16p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R16P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P","tags":"","loc":"proc/str_r16p~3.html","title":"str_R16P – StringiFor"},{"text":"private elemental function str_R8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r8p~3~~CalledByGraph proc~str_r8p~3 str_R8P proc~str_a_r8p~3 str_a_R8P proc~str_a_r8p~3->proc~str_r8p~3 interface~str~3 str interface~str~3->proc~str_r8p~3 interface~str~3->proc~str_a_r8p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P","tags":"","loc":"proc/str_r8p~3.html","title":"str_R8P – StringiFor"},{"text":"private elemental function str_R4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. Called By proc~~str_r4p~3~~CalledByGraph proc~str_r4p~3 str_R4P proc~str_a_r4p~3 str_a_R4P proc~str_a_r4p~3->proc~str_r4p~3 interface~str~3 str interface~str~3->proc~str_r4p~3 interface~str~3->proc~str_a_r4p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_R4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P","tags":"","loc":"proc/str_r4p~3.html","title":"str_R4P – StringiFor"},{"text":"private elemental function str_I8P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i8p~3~~CalledByGraph proc~str_i8p~3 str_I8P proc~str_a_i8p~3 str_a_I8P proc~str_a_i8p~3->proc~str_i8p~3 interface~str~3 str interface~str~3->proc~str_i8p~3 interface~str~3->proc~str_a_i8p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P","tags":"","loc":"proc/str_i8p~3.html","title":"str_I8P – StringiFor"},{"text":"private elemental function str_I4P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. Called By proc~~str_i4p~3~~CalledByGraph proc~str_i4p~3 str_I4P proc~str_a_i4p~3 str_a_I4P proc~str_a_i4p~3->proc~str_i4p~3 interface~str~3 str interface~str~3->proc~str_i4p~3 interface~str~3->proc~str_a_i4p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P","tags":"","loc":"proc/str_i4p~3.html","title":"str_I4P – StringiFor"},{"text":"private elemental function str_I2P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i2p~3~~CalledByGraph proc~str_i2p~3 str_I2P proc~str_a_i2p~3 str_a_I2P proc~str_a_i2p~3->proc~str_i2p~3 interface~str~3 str interface~str~3->proc~str_i2p~3 interface~str~3->proc~str_a_i2p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P","tags":"","loc":"proc/str_i2p~3.html","title":"str_I2P – StringiFor"},{"text":"private elemental function str_I1P(n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. Called By proc~~str_i1p~3~~CalledByGraph proc~str_i1p~3 str_I1P proc~str_a_i1p~3 str_a_I1P proc~str_a_i1p~3->proc~str_i1p~3 interface~str~3 str interface~str~3->proc~str_i1p~3 interface~str~3->proc~str_a_i1p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P","tags":"","loc":"proc/str_i1p~3.html","title":"str_I1P – StringiFor"},{"text":"private elemental function str_bol(n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. Called By proc~~str_bol~3~~CalledByGraph proc~str_bol~3 str_bol interface~str~3 str interface~str~3->proc~str_bol~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol","tags":"","loc":"proc/str_bol~3.html","title":"str_bol – StringiFor"},{"text":"private pure function str_a_R16P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Converting real array to string. Calls proc~~str_a_r16p~3~~CallsGraph proc~str_a_r16p~3 str_a_R16P proc~str_r16p~3 str_R16P proc~str_a_r16p~3->proc~str_r16p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR16P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R16P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R16P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P","tags":"","loc":"proc/str_a_r16p~3.html","title":"str_a_R16P – StringiFor"},{"text":"private pure function str_a_R8P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. Calls proc~~str_a_r8p~3~~CallsGraph proc~str_a_r8p~3 str_a_R8P proc~str_r8p~3 str_R8P proc~str_a_r8p~3->proc~str_r8p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_r8p~3~~CalledByGraph proc~str_a_r8p~3 str_a_R8P interface~str~3 str interface~str~3->proc~str_a_r8p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P","tags":"","loc":"proc/str_a_r8p~3.html","title":"str_a_R8P – StringiFor"},{"text":"private pure function str_a_R4P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. Calls proc~~str_a_r4p~3~~CallsGraph proc~str_a_r4p~3 str_a_R4P proc~str_r4p~3 str_R4P proc~str_a_r4p~3->proc~str_r4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_r4p~3~~CalledByGraph proc~str_a_r4p~3 str_a_R4P interface~str~3 str interface~str~3->proc~str_a_r4p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DR4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_R4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_R4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P","tags":"","loc":"proc/str_a_r4p~3.html","title":"str_a_R4P – StringiFor"},{"text":"private pure function str_a_I8P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i8p~3~~CallsGraph proc~str_a_i8p~3 str_a_I8P proc~str_i8p~3 str_I8P proc~str_a_i8p~3->proc~str_i8p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i8p~3~~CalledByGraph proc~str_a_i8p~3 str_a_I8P interface~str~3 str interface~str~3->proc~str_a_i8p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I8P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P","tags":"","loc":"proc/str_a_i8p~3.html","title":"str_a_I8P – StringiFor"},{"text":"private pure function str_a_I4P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i4p~3~~CallsGraph proc~str_a_i4p~3 str_a_I4P proc~str_i4p~3 str_I4P proc~str_a_i4p~3->proc~str_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i4p~3~~CalledByGraph proc~str_a_i4p~3 str_a_I4P interface~str~3 str interface~str~3->proc~str_a_i4p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I4P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P","tags":"","loc":"proc/str_a_i4p~3.html","title":"str_a_I4P – StringiFor"},{"text":"private pure function str_a_I2P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i2p~3~~CallsGraph proc~str_a_i2p~3 str_a_I2P proc~str_i2p~3 str_I2P proc~str_a_i2p~3->proc~str_i2p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i2p~3~~CalledByGraph proc~str_a_i2p~3 str_a_I2P interface~str~3 str interface~str~3->proc~str_a_i2p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I2P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P","tags":"","loc":"proc/str_a_i2p~3.html","title":"str_a_I2P – StringiFor"},{"text":"private pure function str_a_I1P(n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. Calls proc~~str_a_i1p~3~~CallsGraph proc~str_a_i1p~3 str_a_I1P proc~str_i1p~3 str_I1P proc~str_a_i1p~3->proc~str_i1p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~str_a_i1p~3~~CalledByGraph proc~str_a_i1p~3 str_a_I1P interface~str~3 str interface~str~3->proc~str_a_i1p~3 proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: strn String containing of element of input array number. integer, public :: i Counter. Source Code pure function str_a_I1P ( n , no_sign , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( no_sign )) then str = '' do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // ',' // trim ( strn ) enddo else str = '' do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // ',' // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P","tags":"","loc":"proc/str_a_i1p~3.html","title":"str_a_I1P – StringiFor"},{"text":"private elemental function strz_I8P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. Called By proc~~strz_i8p~3~~CalledByGraph proc~strz_i8p~3 strz_I8P interface~strz~3 strz interface~strz~3->proc~strz_i8p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P","tags":"","loc":"proc/strz_i8p~3.html","title":"strz_I8P – StringiFor"},{"text":"private elemental function strz_I4P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i4p~3~~CalledByGraph proc~strz_i4p~3 strz_I4P interface~strz~3 strz interface~strz~3->proc~strz_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P","tags":"","loc":"proc/strz_i4p~3.html","title":"strz_I4P – StringiFor"},{"text":"private elemental function strz_I2P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i2p~3~~CalledByGraph proc~strz_i2p~3 strz_I2P interface~strz~3 strz interface~strz~3->proc~strz_i2p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P","tags":"","loc":"proc/strz_i2p~3.html","title":"strz_I2P – StringiFor"},{"text":"private elemental function strz_I1P(n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. Called By proc~~strz_i1p~3~~CalledByGraph proc~strz_i1p~3 strz_I1P interface~strz~3 strz interface~strz~3->proc~strz_i1p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P","tags":"","loc":"proc/strz_i1p~3.html","title":"strz_I1P – StringiFor"},{"text":"private function ctor_R16P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Description Convert string to real. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P","tags":"","loc":"proc/ctor_r16p~3.html","title":"ctor_R16P – StringiFor"},{"text":"private function ctor_R8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. Called By proc~~ctor_r8p~3~~CalledByGraph proc~ctor_r8p~3 ctor_R8P interface~cton~3 cton interface~cton~3->proc~ctor_r8p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P","tags":"","loc":"proc/ctor_r8p~3.html","title":"ctor_R8P – StringiFor"},{"text":"private function ctor_R4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. Called By proc~~ctor_r4p~3~~CalledByGraph proc~ctor_r4p~3 ctor_R4P interface~cton~3 cton interface~cton~3->proc~ctor_r4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P","tags":"","loc":"proc/ctor_r4p~3.html","title":"ctor_R4P – StringiFor"},{"text":"private function ctoi_I8P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i8p~3~~CalledByGraph proc~ctoi_i8p~3 ctoi_I8P interface~cton~3 cton interface~cton~3->proc~ctoi_i8p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P","tags":"","loc":"proc/ctoi_i8p~3.html","title":"ctoi_I8P – StringiFor"},{"text":"private function ctoi_I4P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i4p~3~~CalledByGraph proc~ctoi_i4p~3 ctoi_I4P interface~cton~3 cton interface~cton~3->proc~ctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P","tags":"","loc":"proc/ctoi_i4p~3.html","title":"ctoi_I4P – StringiFor"},{"text":"private function ctoi_I2P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i2p~3~~CalledByGraph proc~ctoi_i2p~3 ctoi_I2P interface~cton~3 cton interface~cton~3->proc~ctoi_i2p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P","tags":"","loc":"proc/ctoi_i2p~3.html","title":"ctoi_I2P – StringiFor"},{"text":"private function ctoi_I1P(str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. Called By proc~~ctoi_i1p~3~~CalledByGraph proc~ctoi_i1p~3 ctoi_I1P interface~cton~3 cton interface~cton~3->proc~ctoi_i1p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: err Error trapping flag: 0 no errors, >0 error occurs. character(len=:), public, allocatable :: prefd Prefixing string. Source Code function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P","tags":"","loc":"proc/ctoi_i1p~3.html","title":"ctoi_I1P – StringiFor"},{"text":"private elemental function bstr_R16P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. Source Code elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P","tags":"","loc":"proc/bstr_r16p~3.html","title":"bstr_R16P – StringiFor"},{"text":"private elemental function bstr_R8P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. Called By proc~~bstr_r8p~3~~CalledByGraph proc~bstr_r8p~3 bstr_R8P interface~bstr~3 bstr interface~bstr~3->proc~bstr_r8p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P","tags":"","loc":"proc/bstr_r8p~3.html","title":"bstr_R8P – StringiFor"},{"text":"private elemental function bstr_R4P(n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. Note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. Called By proc~~bstr_r4p~3~~CalledByGraph proc~bstr_r4p~3 bstr_R4P interface~bstr~3 bstr interface~bstr~3->proc~bstr_r4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P","tags":"","loc":"proc/bstr_r4p~3.html","title":"bstr_R4P – StringiFor"},{"text":"private elemental function bstr_I8P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. Called By proc~~bstr_i8p~3~~CalledByGraph proc~bstr_i8p~3 bstr_I8P interface~bstr~3 bstr interface~bstr~3->proc~bstr_i8p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P","tags":"","loc":"proc/bstr_i8p~3.html","title":"bstr_I8P – StringiFor"},{"text":"private elemental function bstr_I4P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. Called By proc~~bstr_i4p~3~~CalledByGraph proc~bstr_i4p~3 bstr_I4P interface~bstr~3 bstr interface~bstr~3->proc~bstr_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P","tags":"","loc":"proc/bstr_i4p~3.html","title":"bstr_I4P – StringiFor"},{"text":"private elemental function bstr_I2P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. Called By proc~~bstr_i2p~3~~CalledByGraph proc~bstr_i2p~3 bstr_I2P interface~bstr~3 bstr interface~bstr~3->proc~bstr_i2p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P","tags":"","loc":"proc/bstr_i2p~3.html","title":"bstr_I2P – StringiFor"},{"text":"private elemental function bstr_I1P(n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. Note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. Called By proc~~bstr_i1p~3~~CalledByGraph proc~bstr_i1p~3 bstr_I1P interface~bstr~3 bstr interface~bstr~3->proc~bstr_i1p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P","tags":"","loc":"proc/bstr_i1p~3.html","title":"bstr_I1P – StringiFor"},{"text":"private elemental function bctor_R16P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r16p~3~~CallsGraph proc~bctor_r16p~3 bctor_R16P interface~str~3 str proc~bctor_r16p~3->interface~str~3 proc~strf_i2p~3 strf_I2P interface~str~3->proc~strf_i2p~3 proc~str_i4p~3 str_I4P interface~str~3->proc~str_i4p~3 proc~str_a_r4p~3 str_a_R4P interface~str~3->proc~str_a_r4p~3 proc~strf_i1p~3 strf_I1P interface~str~3->proc~strf_i1p~3 proc~strf_i8p~3 strf_I8P interface~str~3->proc~strf_i8p~3 proc~str_a_i4p~3 str_a_I4P interface~str~3->proc~str_a_i4p~3 proc~str_a_i8p~3 str_a_I8P interface~str~3->proc~str_a_i8p~3 proc~str_r8p~3 str_R8P interface~str~3->proc~str_r8p~3 proc~str_bol~3 str_bol interface~str~3->proc~str_bol~3 proc~strf_r4p~3 strf_R4P interface~str~3->proc~strf_r4p~3 proc~strf_i4p~3 strf_I4P interface~str~3->proc~strf_i4p~3 proc~str_a_i2p~3 str_a_I2P interface~str~3->proc~str_a_i2p~3 proc~str_i2p~3 str_I2P interface~str~3->proc~str_i2p~3 proc~str_a_r8p~3 str_a_R8P interface~str~3->proc~str_a_r8p~3 proc~str_r4p~3 str_R4P interface~str~3->proc~str_r4p~3 proc~str_a_i1p~3 str_a_I1P interface~str~3->proc~str_a_i1p~3 proc~str_i8p~3 str_I8P interface~str~3->proc~str_i8p~3 proc~str_i1p~3 str_I1P interface~str~3->proc~str_i1p~3 proc~strf_r8p~3 strf_R8P interface~str~3->proc~strf_r8p~3 proc~str_a_r4p~3->proc~str_r4p~3 proc~str_a_i4p~3->proc~str_i4p~3 proc~str_a_i8p~3->proc~str_i8p~3 proc~str_a_i2p~3->proc~str_i2p~3 proc~str_a_r8p~3->proc~str_r8p~3 proc~str_a_i1p~3->proc~str_i1p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P","tags":"","loc":"proc/bctor_r16p~3.html","title":"bctor_R16P – StringiFor"},{"text":"private elemental function bctor_R8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r8p~3~~CallsGraph proc~bctor_r8p~3 bctor_R8P interface~str~3 str proc~bctor_r8p~3->interface~str~3 proc~strf_i2p~3 strf_I2P interface~str~3->proc~strf_i2p~3 proc~str_i4p~3 str_I4P interface~str~3->proc~str_i4p~3 proc~str_a_r4p~3 str_a_R4P interface~str~3->proc~str_a_r4p~3 proc~strf_i1p~3 strf_I1P interface~str~3->proc~strf_i1p~3 proc~strf_i8p~3 strf_I8P interface~str~3->proc~strf_i8p~3 proc~str_a_i4p~3 str_a_I4P interface~str~3->proc~str_a_i4p~3 proc~str_a_i8p~3 str_a_I8P interface~str~3->proc~str_a_i8p~3 proc~str_r8p~3 str_R8P interface~str~3->proc~str_r8p~3 proc~str_bol~3 str_bol interface~str~3->proc~str_bol~3 proc~strf_r4p~3 strf_R4P interface~str~3->proc~strf_r4p~3 proc~strf_i4p~3 strf_I4P interface~str~3->proc~strf_i4p~3 proc~str_a_i2p~3 str_a_I2P interface~str~3->proc~str_a_i2p~3 proc~str_i2p~3 str_I2P interface~str~3->proc~str_i2p~3 proc~str_a_r8p~3 str_a_R8P interface~str~3->proc~str_a_r8p~3 proc~str_r4p~3 str_R4P interface~str~3->proc~str_r4p~3 proc~str_a_i1p~3 str_a_I1P interface~str~3->proc~str_a_i1p~3 proc~str_i8p~3 str_I8P interface~str~3->proc~str_i8p~3 proc~str_i1p~3 str_I1P interface~str~3->proc~str_i1p~3 proc~strf_r8p~3 strf_R8P interface~str~3->proc~strf_r8p~3 proc~str_a_r4p~3->proc~str_r4p~3 proc~str_a_i4p~3->proc~str_i4p~3 proc~str_a_i8p~3->proc~str_i8p~3 proc~str_a_i2p~3->proc~str_i2p~3 proc~str_a_r8p~3->proc~str_r8p~3 proc~str_a_i1p~3->proc~str_i1p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctor_r8p~3~~CalledByGraph proc~bctor_r8p~3 bctor_R8P interface~bcton~3 bcton interface~bcton~3->proc~bctor_r8p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P","tags":"","loc":"proc/bctor_r8p~3.html","title":"bctor_R8P – StringiFor"},{"text":"private elemental function bctor_R4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. Calls proc~~bctor_r4p~3~~CallsGraph proc~bctor_r4p~3 bctor_R4P interface~str~3 str proc~bctor_r4p~3->interface~str~3 proc~strf_i2p~3 strf_I2P interface~str~3->proc~strf_i2p~3 proc~str_i4p~3 str_I4P interface~str~3->proc~str_i4p~3 proc~str_a_r4p~3 str_a_R4P interface~str~3->proc~str_a_r4p~3 proc~strf_i1p~3 strf_I1P interface~str~3->proc~strf_i1p~3 proc~strf_i8p~3 strf_I8P interface~str~3->proc~strf_i8p~3 proc~str_a_i4p~3 str_a_I4P interface~str~3->proc~str_a_i4p~3 proc~str_a_i8p~3 str_a_I8P interface~str~3->proc~str_a_i8p~3 proc~str_r8p~3 str_R8P interface~str~3->proc~str_r8p~3 proc~str_bol~3 str_bol interface~str~3->proc~str_bol~3 proc~strf_r4p~3 strf_R4P interface~str~3->proc~strf_r4p~3 proc~strf_i4p~3 strf_I4P interface~str~3->proc~strf_i4p~3 proc~str_a_i2p~3 str_a_I2P interface~str~3->proc~str_a_i2p~3 proc~str_i2p~3 str_I2P interface~str~3->proc~str_i2p~3 proc~str_a_r8p~3 str_a_R8P interface~str~3->proc~str_a_r8p~3 proc~str_r4p~3 str_R4P interface~str~3->proc~str_r4p~3 proc~str_a_i1p~3 str_a_I1P interface~str~3->proc~str_a_i1p~3 proc~str_i8p~3 str_I8P interface~str~3->proc~str_i8p~3 proc~str_i1p~3 str_I1P interface~str~3->proc~str_i1p~3 proc~strf_r8p~3 strf_R8P interface~str~3->proc~strf_r8p~3 proc~str_a_r4p~3->proc~str_r4p~3 proc~str_a_i4p~3->proc~str_i4p~3 proc~str_a_i8p~3->proc~str_i8p~3 proc~str_a_i2p~3->proc~str_i2p~3 proc~str_a_r8p~3->proc~str_r8p~3 proc~str_a_i1p~3->proc~str_i1p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctor_r4p~3~~CalledByGraph proc~bctor_r4p~3 bctor_R4P interface~bcton~3 bcton interface~bcton~3->proc~bctor_r4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P","tags":"","loc":"proc/bctor_r4p~3.html","title":"bctor_R4P – StringiFor"},{"text":"private elemental function bctoi_I8P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i8p~3~~CallsGraph proc~bctoi_i8p~3 bctoi_I8P interface~str~3 str proc~bctoi_i8p~3->interface~str~3 proc~strf_i2p~3 strf_I2P interface~str~3->proc~strf_i2p~3 proc~str_i4p~3 str_I4P interface~str~3->proc~str_i4p~3 proc~str_a_r4p~3 str_a_R4P interface~str~3->proc~str_a_r4p~3 proc~strf_i1p~3 strf_I1P interface~str~3->proc~strf_i1p~3 proc~strf_i8p~3 strf_I8P interface~str~3->proc~strf_i8p~3 proc~str_a_i4p~3 str_a_I4P interface~str~3->proc~str_a_i4p~3 proc~str_a_i8p~3 str_a_I8P interface~str~3->proc~str_a_i8p~3 proc~str_r8p~3 str_R8P interface~str~3->proc~str_r8p~3 proc~str_bol~3 str_bol interface~str~3->proc~str_bol~3 proc~strf_r4p~3 strf_R4P interface~str~3->proc~strf_r4p~3 proc~strf_i4p~3 strf_I4P interface~str~3->proc~strf_i4p~3 proc~str_a_i2p~3 str_a_I2P interface~str~3->proc~str_a_i2p~3 proc~str_i2p~3 str_I2P interface~str~3->proc~str_i2p~3 proc~str_a_r8p~3 str_a_R8P interface~str~3->proc~str_a_r8p~3 proc~str_r4p~3 str_R4P interface~str~3->proc~str_r4p~3 proc~str_a_i1p~3 str_a_I1P interface~str~3->proc~str_a_i1p~3 proc~str_i8p~3 str_I8P interface~str~3->proc~str_i8p~3 proc~str_i1p~3 str_I1P interface~str~3->proc~str_i1p~3 proc~strf_r8p~3 strf_R8P interface~str~3->proc~strf_r8p~3 proc~str_a_r4p~3->proc~str_r4p~3 proc~str_a_i4p~3->proc~str_i4p~3 proc~str_a_i8p~3->proc~str_i8p~3 proc~str_a_i2p~3->proc~str_i2p~3 proc~str_a_r8p~3->proc~str_r8p~3 proc~str_a_i1p~3->proc~str_i1p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i8p~3~~CalledByGraph proc~bctoi_i8p~3 bctoi_I8P interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i8p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P","tags":"","loc":"proc/bctoi_i8p~3.html","title":"bctoi_I8P – StringiFor"},{"text":"private elemental function bctoi_I4P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i4p~3~~CallsGraph proc~bctoi_i4p~3 bctoi_I4P interface~str~3 str proc~bctoi_i4p~3->interface~str~3 proc~strf_i2p~3 strf_I2P interface~str~3->proc~strf_i2p~3 proc~str_i4p~3 str_I4P interface~str~3->proc~str_i4p~3 proc~str_a_r4p~3 str_a_R4P interface~str~3->proc~str_a_r4p~3 proc~strf_i1p~3 strf_I1P interface~str~3->proc~strf_i1p~3 proc~strf_i8p~3 strf_I8P interface~str~3->proc~strf_i8p~3 proc~str_a_i4p~3 str_a_I4P interface~str~3->proc~str_a_i4p~3 proc~str_a_i8p~3 str_a_I8P interface~str~3->proc~str_a_i8p~3 proc~str_r8p~3 str_R8P interface~str~3->proc~str_r8p~3 proc~str_bol~3 str_bol interface~str~3->proc~str_bol~3 proc~strf_r4p~3 strf_R4P interface~str~3->proc~strf_r4p~3 proc~strf_i4p~3 strf_I4P interface~str~3->proc~strf_i4p~3 proc~str_a_i2p~3 str_a_I2P interface~str~3->proc~str_a_i2p~3 proc~str_i2p~3 str_I2P interface~str~3->proc~str_i2p~3 proc~str_a_r8p~3 str_a_R8P interface~str~3->proc~str_a_r8p~3 proc~str_r4p~3 str_R4P interface~str~3->proc~str_r4p~3 proc~str_a_i1p~3 str_a_I1P interface~str~3->proc~str_a_i1p~3 proc~str_i8p~3 str_I8P interface~str~3->proc~str_i8p~3 proc~str_i1p~3 str_I1P interface~str~3->proc~str_i1p~3 proc~strf_r8p~3 strf_R8P interface~str~3->proc~strf_r8p~3 proc~str_a_r4p~3->proc~str_r4p~3 proc~str_a_i4p~3->proc~str_i4p~3 proc~str_a_i8p~3->proc~str_i8p~3 proc~str_a_i2p~3->proc~str_i2p~3 proc~str_a_r8p~3->proc~str_r8p~3 proc~str_a_i1p~3->proc~str_i1p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i4p~3~~CalledByGraph proc~bctoi_i4p~3 bctoi_I4P interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P","tags":"","loc":"proc/bctoi_i4p~3.html","title":"bctoi_I4P – StringiFor"},{"text":"private elemental function bctoi_I2P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i2p~3~~CallsGraph proc~bctoi_i2p~3 bctoi_I2P interface~str~3 str proc~bctoi_i2p~3->interface~str~3 proc~strf_i2p~3 strf_I2P interface~str~3->proc~strf_i2p~3 proc~str_i4p~3 str_I4P interface~str~3->proc~str_i4p~3 proc~str_a_r4p~3 str_a_R4P interface~str~3->proc~str_a_r4p~3 proc~strf_i1p~3 strf_I1P interface~str~3->proc~strf_i1p~3 proc~strf_i8p~3 strf_I8P interface~str~3->proc~strf_i8p~3 proc~str_a_i4p~3 str_a_I4P interface~str~3->proc~str_a_i4p~3 proc~str_a_i8p~3 str_a_I8P interface~str~3->proc~str_a_i8p~3 proc~str_r8p~3 str_R8P interface~str~3->proc~str_r8p~3 proc~str_bol~3 str_bol interface~str~3->proc~str_bol~3 proc~strf_r4p~3 strf_R4P interface~str~3->proc~strf_r4p~3 proc~strf_i4p~3 strf_I4P interface~str~3->proc~strf_i4p~3 proc~str_a_i2p~3 str_a_I2P interface~str~3->proc~str_a_i2p~3 proc~str_i2p~3 str_I2P interface~str~3->proc~str_i2p~3 proc~str_a_r8p~3 str_a_R8P interface~str~3->proc~str_a_r8p~3 proc~str_r4p~3 str_R4P interface~str~3->proc~str_r4p~3 proc~str_a_i1p~3 str_a_I1P interface~str~3->proc~str_a_i1p~3 proc~str_i8p~3 str_I8P interface~str~3->proc~str_i8p~3 proc~str_i1p~3 str_I1P interface~str~3->proc~str_i1p~3 proc~strf_r8p~3 strf_R8P interface~str~3->proc~strf_r8p~3 proc~str_a_r4p~3->proc~str_r4p~3 proc~str_a_i4p~3->proc~str_i4p~3 proc~str_a_i8p~3->proc~str_i8p~3 proc~str_a_i2p~3->proc~str_i2p~3 proc~str_a_r8p~3->proc~str_r8p~3 proc~str_a_i1p~3->proc~str_i1p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i2p~3~~CalledByGraph proc~bctoi_i2p~3 bctoi_I2P interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P","tags":"","loc":"proc/bctoi_i2p~3.html","title":"bctoi_I2P – StringiFor"},{"text":"private elemental function bctoi_I1P(bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer. Calls proc~~bctoi_i1p~3~~CallsGraph proc~bctoi_i1p~3 bctoi_I1P interface~str~3 str proc~bctoi_i1p~3->interface~str~3 proc~strf_i2p~3 strf_I2P interface~str~3->proc~strf_i2p~3 proc~str_i4p~3 str_I4P interface~str~3->proc~str_i4p~3 proc~str_a_r4p~3 str_a_R4P interface~str~3->proc~str_a_r4p~3 proc~strf_i1p~3 strf_I1P interface~str~3->proc~strf_i1p~3 proc~strf_i8p~3 strf_I8P interface~str~3->proc~strf_i8p~3 proc~str_a_i4p~3 str_a_I4P interface~str~3->proc~str_a_i4p~3 proc~str_a_i8p~3 str_a_I8P interface~str~3->proc~str_a_i8p~3 proc~str_r8p~3 str_R8P interface~str~3->proc~str_r8p~3 proc~str_bol~3 str_bol interface~str~3->proc~str_bol~3 proc~strf_r4p~3 strf_R4P interface~str~3->proc~strf_r4p~3 proc~strf_i4p~3 strf_I4P interface~str~3->proc~strf_i4p~3 proc~str_a_i2p~3 str_a_I2P interface~str~3->proc~str_a_i2p~3 proc~str_i2p~3 str_I2P interface~str~3->proc~str_i2p~3 proc~str_a_r8p~3 str_a_R8P interface~str~3->proc~str_a_r8p~3 proc~str_r4p~3 str_R4P interface~str~3->proc~str_r4p~3 proc~str_a_i1p~3 str_a_I1P interface~str~3->proc~str_a_i1p~3 proc~str_i8p~3 str_I8P interface~str~3->proc~str_i8p~3 proc~str_i1p~3 str_I1P interface~str~3->proc~str_i1p~3 proc~strf_r8p~3 strf_R8P interface~str~3->proc~strf_r8p~3 proc~str_a_r4p~3->proc~str_r4p~3 proc~str_a_i4p~3->proc~str_i4p~3 proc~str_a_i8p~3->proc~str_i8p~3 proc~str_a_i2p~3->proc~str_i2p~3 proc~str_a_r8p~3->proc~str_r8p~3 proc~str_a_i1p~3->proc~str_i1p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i1p~3~~CalledByGraph proc~bctoi_i1p~3 bctoi_I1P interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i1p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P","tags":"","loc":"proc/bctoi_i1p~3.html","title":"bctoi_I1P – StringiFor"},{"text":"public interface str Convert number (real and integer) to string (number to string type casting). Calls interface~~str~3~~CallsGraph interface~str~3 str proc~strf_i2p~3 strf_I2P interface~str~3->proc~strf_i2p~3 proc~str_i4p~3 str_I4P interface~str~3->proc~str_i4p~3 proc~str_a_r4p~3 str_a_R4P interface~str~3->proc~str_a_r4p~3 proc~strf_i1p~3 strf_I1P interface~str~3->proc~strf_i1p~3 proc~strf_i8p~3 strf_I8P interface~str~3->proc~strf_i8p~3 proc~str_a_i4p~3 str_a_I4P interface~str~3->proc~str_a_i4p~3 proc~str_a_i8p~3 str_a_I8P interface~str~3->proc~str_a_i8p~3 proc~str_r8p~3 str_R8P interface~str~3->proc~str_r8p~3 proc~str_bol~3 str_bol interface~str~3->proc~str_bol~3 proc~strf_r4p~3 strf_R4P interface~str~3->proc~strf_r4p~3 proc~strf_i4p~3 strf_I4P interface~str~3->proc~strf_i4p~3 proc~str_a_i2p~3 str_a_I2P interface~str~3->proc~str_a_i2p~3 proc~str_i2p~3 str_I2P interface~str~3->proc~str_i2p~3 proc~str_a_r8p~3 str_a_R8P interface~str~3->proc~str_a_r8p~3 proc~str_r4p~3 str_R4P interface~str~3->proc~str_r4p~3 proc~str_a_i1p~3 str_a_I1P interface~str~3->proc~str_a_i1p~3 proc~str_i8p~3 str_I8P interface~str~3->proc~str_i8p~3 proc~str_i1p~3 str_I1P interface~str~3->proc~str_i1p~3 proc~strf_r8p~3 strf_R8P interface~str~3->proc~strf_r8p~3 proc~str_a_r4p~3->proc~str_r4p~3 proc~str_a_i4p~3->proc~str_i4p~3 proc~str_a_i8p~3->proc~str_i8p~3 proc~str_a_i2p~3->proc~str_i2p~3 proc~str_a_r8p~3->proc~str_r8p~3 proc~str_a_i1p~3->proc~str_i1p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~str~3~~CalledByGraph interface~str~3 str proc~bctoi_i2p~3 bctoi_I2P proc~bctoi_i2p~3->interface~str~3 proc~bctoi_i1p~3 bctoi_I1P proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3 bctoi_I8P proc~bctoi_i8p~3->interface~str~3 proc~bctor_r4p~3 bctor_R4P proc~bctor_r4p~3->interface~str~3 proc~bctor_r16p~3 bctor_R16P proc~bctor_r16p~3->interface~str~3 proc~bctor_r8p~3 bctor_R8P proc~bctor_r8p~3->interface~str~3 proc~bctoi_i4p~3 bctoi_I4P proc~bctoi_i4p~3->interface~str~3 interface~bcton~3 bcton interface~bcton~3->proc~bctoi_i2p~3 interface~bcton~3->proc~bctoi_i1p~3 interface~bcton~3->proc~bctoi_i8p~3 interface~bcton~3->proc~bctor_r4p~3 interface~bcton~3->proc~bctor_r8p~3 interface~bcton~3->proc~bctoi_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string.","tags":"","loc":"interface/str~3.html","title":"str – StringiFor"},{"text":"public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). Calls interface~~strz~3~~CallsGraph interface~strz~3 strz proc~strz_i1p~3 strz_I1P interface~strz~3->proc~strz_i1p~3 proc~strz_i8p~3 strz_I8P interface~strz~3->proc~strz_i8p~3 proc~strz_i2p~3 strz_I2P interface~strz~3->proc~strz_i2p~3 proc~strz_i4p~3 strz_I4P interface~strz~3->proc~strz_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros.","tags":"","loc":"interface/strz~3.html","title":"strz – StringiFor"},{"text":"public interface cton Convert string to number (real and integer, string to number type casting). Calls interface~~cton~3~~CallsGraph interface~cton~3 cton proc~ctoi_i4p~3 ctoi_I4P interface~cton~3->proc~ctoi_i4p~3 proc~ctor_r4p~3 ctor_R4P interface~cton~3->proc~ctor_r4p~3 proc~ctor_r8p~3 ctor_R8P interface~cton~3->proc~ctor_r8p~3 proc~ctoi_i1p~3 ctoi_I1P interface~cton~3->proc~ctoi_i1p~3 proc~ctoi_i2p~3 ctoi_I2P interface~cton~3->proc~ctoi_i2p~3 proc~ctoi_i8p~3 ctoi_I8P interface~cton~3->proc~ctoi_i8p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer.","tags":"","loc":"interface/cton~3.html","title":"cton – StringiFor"},{"text":"public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). Calls interface~~bstr~3~~CallsGraph interface~bstr~3 bstr proc~bstr_r8p~3 bstr_R8P interface~bstr~3->proc~bstr_r8p~3 proc~bstr_i2p~3 bstr_I2P interface~bstr~3->proc~bstr_i2p~3 proc~bstr_i1p~3 bstr_I1P interface~bstr~3->proc~bstr_i1p~3 proc~bstr_i8p~3 bstr_I8P interface~bstr~3->proc~bstr_i8p~3 proc~bstr_r4p~3 bstr_R4P interface~bstr~3->proc~bstr_r4p~3 proc~bstr_i4p~3 bstr_I4P interface~bstr~3->proc~bstr_i4p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits.","tags":"","loc":"interface/bstr~3.html","title":"bstr – StringiFor"},{"text":"public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). Calls interface~~bcton~3~~CallsGraph interface~bcton~3 bcton proc~bctoi_i2p~3 bctoi_I2P interface~bcton~3->proc~bctoi_i2p~3 proc~bctor_r4p~3 bctor_R4P interface~bcton~3->proc~bctor_r4p~3 proc~bctoi_i1p~3 bctoi_I1P interface~bcton~3->proc~bctoi_i1p~3 proc~bctoi_i8p~3 bctoi_I8P interface~bcton~3->proc~bctoi_i8p~3 proc~bctoi_i4p~3 bctoi_I4P interface~bcton~3->proc~bctoi_i4p~3 proc~bctor_r8p~3 bctor_R8P interface~bcton~3->proc~bctor_r8p~3 interface~str~3 str proc~bctoi_i2p~3->interface~str~3 proc~bctor_r4p~3->interface~str~3 proc~bctoi_i1p~3->interface~str~3 proc~bctoi_i8p~3->interface~str~3 proc~bctoi_i4p~3->interface~str~3 proc~bctor_r8p~3->interface~str~3 proc~strf_i2p~3 strf_I2P interface~str~3->proc~strf_i2p~3 proc~str_i4p~3 str_I4P interface~str~3->proc~str_i4p~3 proc~str_a_r4p~3 str_a_R4P interface~str~3->proc~str_a_r4p~3 proc~strf_i1p~3 strf_I1P interface~str~3->proc~strf_i1p~3 proc~strf_i8p~3 strf_I8P interface~str~3->proc~strf_i8p~3 proc~str_a_i4p~3 str_a_I4P interface~str~3->proc~str_a_i4p~3 proc~str_a_i8p~3 str_a_I8P interface~str~3->proc~str_a_i8p~3 proc~str_r8p~3 str_R8P interface~str~3->proc~str_r8p~3 proc~str_bol~3 str_bol interface~str~3->proc~str_bol~3 proc~strf_r4p~3 strf_R4P interface~str~3->proc~strf_r4p~3 proc~strf_i4p~3 strf_I4P interface~str~3->proc~strf_i4p~3 proc~str_a_i2p~3 str_a_I2P interface~str~3->proc~str_a_i2p~3 proc~str_i2p~3 str_I2P interface~str~3->proc~str_i2p~3 proc~str_a_r8p~3 str_a_R8P interface~str~3->proc~str_a_r8p~3 proc~str_r4p~3 str_R4P interface~str~3->proc~str_r4p~3 proc~str_a_i1p~3 str_a_I1P interface~str~3->proc~str_a_i1p~3 proc~str_i8p~3 str_I8P interface~str~3->proc~str_i8p~3 proc~str_i1p~3 str_I1P interface~str~3->proc~str_i1p~3 proc~strf_r8p~3 strf_R8P interface~str~3->proc~strf_r8p~3 proc~str_a_r4p~3->proc~str_r4p~3 proc~str_a_i4p~3->proc~str_i4p~3 proc~str_a_i8p~3->proc~str_i8p~3 proc~str_a_i2p~3->proc~str_i2p~3 proc~str_a_r8p~3->proc~str_r8p~3 proc~str_a_i1p~3->proc~str_i1p~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer.","tags":"","loc":"interface/bcton~3.html","title":"bcton – StringiFor"},{"text":"private elemental function digit_I8(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i8~3~~CalledByGraph proc~digit_i8~3 digit_I8 interface~digit~3 digit interface~digit~3->proc~digit_i8~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI8P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8","tags":"","loc":"proc/digit_i8~3.html","title":"digit_I8 – StringiFor"},{"text":"private elemental function digit_I4(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i4~3~~CalledByGraph proc~digit_i4~3 digit_I4 interface~digit~3 digit interface~digit~3->proc~digit_i4~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI4P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4","tags":"","loc":"proc/digit_i4~3.html","title":"digit_I4 – StringiFor"},{"text":"private elemental function digit_I2(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i2~3~~CalledByGraph proc~digit_i2~3 digit_I2 interface~digit~3 digit interface~digit~3->proc~digit_i2~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI2P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2","tags":"","loc":"proc/digit_i2~3.html","title":"digit_I2 – StringiFor"},{"text":"private elemental function digit_I1(n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Called By proc~~digit_i1~3~~CalledByGraph proc~digit_i1~3 digit_I1 interface~digit~3 digit interface~digit~3->proc~digit_i1~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=DI1P), public :: str Returned string containing input number plus padding zeros. Source Code elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1","tags":"","loc":"proc/digit_i1~3.html","title":"digit_I1 – StringiFor"},{"text":"public subroutine check_endian() Arguments None Description Check the type of bit ordering (big or little endian) of the running architecture. Note The result is stored into the endian global variable. Calls proc~~check_endian~3~~CallsGraph proc~check_endian~3 check_endian none~is_little_endian~3 is_little_endian proc~check_endian~3->none~is_little_endian~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~check_endian~3~~CalledByGraph proc~check_endian~3 check_endian proc~penf_init~3 penf_init proc~penf_init~3->proc~check_endian~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions pure function is_little_endian() result(is_little) Arguments None Return Value logical Logical output: true is the running architecture uses little endian ordering, false otherwise. Description Check if the type of the bit ordering of the running architecture is little endian. Source Code subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian","tags":"","loc":"proc/check_endian~3.html","title":"check_endian – StringiFor"},{"text":"public subroutine penf_init() Arguments None Description Initialize PENF's variables that are not initialized into the definition specification. Calls proc~~penf_init~3~~CallsGraph proc~penf_init~3 penf_init proc~check_endian~3 check_endian proc~penf_init~3->proc~check_endian~3 none~is_little_endian~3 is_little_endian proc~check_endian~3->none~is_little_endian~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init","tags":"","loc":"proc/penf_init~3.html","title":"penf_init – StringiFor"},{"text":"public subroutine penf_print(unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print to the specified unit the PENF's environment data. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: prefd Prefixing string. integer(kind=I4P), public :: iostatd IO error. character(len=500), public :: iomsgd Temporary variable for IO error message. Source Code subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print","tags":"","loc":"proc/penf_print~3.html","title":"penf_print – StringiFor"},{"text":"public interface digit Compute the number of digits in decimal base of the input integer. Calls interface~~digit~3~~CallsGraph interface~digit~3 digit proc~digit_i2~3 digit_I2 interface~digit~3->proc~digit_i2~3 proc~digit_i8~3 digit_I8 interface~digit~3->proc~digit_i8~3 proc~digit_i1~3 digit_I1 interface~digit~3->proc~digit_i1~3 proc~digit_i4~3 digit_I4 interface~digit~3->proc~digit_i4~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer.","tags":"","loc":"interface/digit~3.html","title":"digit – StringiFor"},{"text":"private elemental function count_substring(string_, substring) result(No) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_ String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Description Count the number of occurences of a substring into a string. Called By proc~~count_substring~~CalledByGraph proc~count_substring count_substring interface~count count interface~count->proc~count_substring Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I4P), public :: c1 Counters. integer(kind=I4P), public :: c2 Counters. Source Code elemental function count_substring ( string_ , substring ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: string_ !< String. character ( * ), intent ( in ) :: substring !< Substring. integer ( I4P ) :: No !< Number of occurrences. integer ( I4P ) :: c1 !< Counters. integer ( I4P ) :: c2 !< Counters. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( len ( substring ) > len ( string_ )) return c1 = 1 do c2 = index ( string = string_ ( c1 :), substring = substring ) if ( c2 == 0 ) return No = No + 1 c1 = c1 + c2 + len ( substring ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endfunction count_substring","tags":"","loc":"proc/count_substring.html","title":"count_substring – StringiFor"},{"text":"public subroutine read_file(file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read a file as a single string stream. The lines are returned as an array of strings that are read until the eof is reached.\n The line is read as an ascii stream read until the eor is reached. Note For unformatted read only access='stream' is supported with new_line as line terminator. Calls proc~~read_file~~CallsGraph proc~read_file read_file proc~read_lines read_lines proc~read_file->proc~read_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. integer, public :: unit Logical unit. logical, public :: does_exist Check if file exist. Source Code subroutine read_file ( file , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a file as a single string stream. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call read_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_file","tags":"","loc":"proc/read_file.html","title":"read_file – StringiFor"},{"text":"public subroutine read_lines(unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read lines (records) from a connected-formatted unit. Note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. The lines are returned as an array of strings that are read until the eof is reached.\n The line is read as an ascii stream read until the eor is reached. Note For unformatted read only access='stream' is supported with new_line as line terminator. Called By proc~~read_lines~~CalledByGraph proc~read_lines read_lines proc~read_file read_file proc~read_file->proc~read_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. character(kind=CK,len=1), public :: ch Character storage. integer, public :: l Counter. Source Code subroutine read_lines ( unit , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read lines (records) from a connected-formatted unit. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< The lines are returned as an array of strings that are read until the eof is reached. !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( out ), allocatable :: lines (:) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = 1 ) :: ch !< Character storage. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) select case ( form_ % chars ()) case ( 'FORMATTED' ) l = 0 do read ( unit , * , err = 10 , end = 10 ) l = l + 1 enddo case ( 'UNFORMATTED' ) l = 0 do read ( unit , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) l = l + 1 enddo endselect 10 rewind ( unit ) if ( l > 0 ) then allocate ( lines ( 1 : l )) l = 1 iostat_ = 0 do call lines ( l )% read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if (( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )). or .( l >= size ( lines , dim = 1 ))) then exit endif l = l + 1 enddo endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_lines","tags":"","loc":"proc/read_lines.html","title":"read_lines – StringiFor"},{"text":"public subroutine write_lines(unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write lines (records) to a connected-formatted unit. Called By proc~~write_lines~~CalledByGraph proc~write_lines write_lines proc~write_file write_file proc~write_file->proc~write_lines program~csv_naive_parser csv_naive_parser program~csv_naive_parser->proc~write_file Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: l Counter. Source Code subroutine write_lines ( unit , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write lines (records) to a connected-formatted unit. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_lines","tags":"","loc":"proc/write_lines.html","title":"write_lines – StringiFor"},{"text":"public subroutine write_file(file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write a single string stream into file. Note For unformatted read only access='stream' is supported with new_line as line terminator. Calls proc~~write_file~~CallsGraph proc~write_file write_file proc~write_lines write_lines proc~write_file->proc~write_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~write_file~~CalledByGraph proc~write_file write_file program~csv_naive_parser csv_naive_parser program~csv_naive_parser->proc~write_file Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. integer, public :: unit Logical unit. Source Code subroutine write_file ( file , lines , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: file !< File name. type ( string ), intent ( in ) :: lines ( 1 :) !< The lines. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call write_lines ( unit = unit , lines = lines , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_file","tags":"","loc":"proc/write_file.html","title":"write_file – StringiFor"},{"text":"public interface adjustl Builtin adjustl overloading. Calls interface~~adjustl~~CallsGraph interface~adjustl adjustl proc~sadjustl_character sadjustl_character interface~adjustl->proc~sadjustl_character Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public pure function sadjustl_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Left adjust a string by removing leading spaces (character output).","tags":"","loc":"interface/adjustl.html","title":"adjustl – StringiFor"},{"text":"public interface adjustr Builtin adjustr overloading. Calls interface~~adjustr~~CallsGraph interface~adjustr adjustr proc~sadjustr_character sadjustr_character interface~adjustr->proc~sadjustr_character Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public pure function sadjustr_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Right adjust a string by removing leading spaces (character output).","tags":"","loc":"interface/adjustr.html","title":"adjustr – StringiFor"},{"text":"public interface count Builtin count overloading. Calls interface~~count~~CallsGraph interface~count count proc~count_substring count_substring interface~count->proc~count_substring Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental function count_substring (string_, substring) result(No) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_ String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Description Count the number of occurences of a substring into a string.","tags":"","loc":"interface/count.html","title":"count – StringiFor"},{"text":"public interface index Builtin index overloading. Calls interface~~index~~CallsGraph interface~index index proc~sindex_string_string sindex_string_string interface~index->proc~sindex_string_string proc~sindex_string_character sindex_string_character interface~index->proc~sindex_string_character proc~sindex_character_string sindex_character_string interface~index->proc~sindex_character_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_character_string (string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first.","tags":"","loc":"interface/index.html","title":"index – StringiFor"},{"text":"public interface len Builtin len overloading. Calls interface~~len~~CallsGraph interface~len len proc~slen slen interface~len->proc~slen Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string.","tags":"","loc":"interface/len.html","title":"len – StringiFor"},{"text":"public interface len_trim Builtin len_trim overloading. Calls interface~~len_trim~~CallsGraph interface~len_trim len_trim proc~slen_trim slen_trim interface~len_trim->proc~slen_trim Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks.","tags":"","loc":"interface/len_trim.html","title":"len_trim – StringiFor"},{"text":"public interface repeat Builtin repeat overloading. Calls interface~~repeat~~CallsGraph interface~repeat repeat proc~srepeat_string_string srepeat_string_string interface~repeat->proc~srepeat_string_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string.","tags":"","loc":"interface/repeat.html","title":"repeat – StringiFor"},{"text":"public interface scan Builtin scan overloading. Calls interface~~scan~~CallsGraph interface~scan scan proc~sscan_string_character sscan_string_character interface~scan->proc~sscan_string_character proc~sscan_string_string sscan_string_string interface~scan->proc~sscan_string_string proc~sscan_character_string sscan_character_string interface~scan->proc~sscan_character_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_character_string (sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set .","tags":"","loc":"interface/scan.html","title":"scan – StringiFor"},{"text":"public interface trim Builtin trim overloading. Calls interface~~trim~~CallsGraph interface~trim trim proc~strim strim interface~trim->proc~strim Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces.","tags":"","loc":"interface/trim.html","title":"trim – StringiFor"},{"text":"private pure subroutine pack_data_R8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_r4~2~~CalledByGraph proc~pack_data_r8_r4~2 pack_data_R8_R4 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_r8_r4~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_R4","tags":"","loc":"proc/pack_data_r8_r4~2.html","title":"pack_data_R8_R4 – StringiFor"},{"text":"private pure subroutine pack_data_R8_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i8~2~~CalledByGraph proc~pack_data_r8_i8~2 pack_data_R8_I8 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_r8_i8~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I8","tags":"","loc":"proc/pack_data_r8_i8~2.html","title":"pack_data_R8_I8 – StringiFor"},{"text":"private pure subroutine pack_data_R8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i4~2~~CalledByGraph proc~pack_data_r8_i4~2 pack_data_R8_I4 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_r8_i4~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I4","tags":"","loc":"proc/pack_data_r8_i4~2.html","title":"pack_data_R8_I4 – StringiFor"},{"text":"private pure subroutine pack_data_R8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i2~2~~CalledByGraph proc~pack_data_r8_i2~2 pack_data_R8_I2 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_r8_i2~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I2","tags":"","loc":"proc/pack_data_r8_i2~2.html","title":"pack_data_R8_I2 – StringiFor"},{"text":"private pure subroutine pack_data_R8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r8_i1~2~~CalledByGraph proc~pack_data_r8_i1~2 pack_data_R8_I1 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_r8_i1~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R8_I1","tags":"","loc":"proc/pack_data_r8_i1~2.html","title":"pack_data_R8_I1 – StringiFor"},{"text":"private pure subroutine pack_data_R4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_r8~2~~CalledByGraph proc~pack_data_r4_r8~2 pack_data_R4_R8 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_r4_r8~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_R8","tags":"","loc":"proc/pack_data_r4_r8~2.html","title":"pack_data_R4_R8 – StringiFor"},{"text":"private pure subroutine pack_data_R4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i8~2~~CalledByGraph proc~pack_data_r4_i8~2 pack_data_R4_I8 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_r4_i8~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I8","tags":"","loc":"proc/pack_data_r4_i8~2.html","title":"pack_data_R4_I8 – StringiFor"},{"text":"private pure subroutine pack_data_R4_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i4~2~~CalledByGraph proc~pack_data_r4_i4~2 pack_data_R4_I4 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_r4_i4~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I4","tags":"","loc":"proc/pack_data_r4_i4~2.html","title":"pack_data_R4_I4 – StringiFor"},{"text":"private pure subroutine pack_data_R4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i2~2~~CalledByGraph proc~pack_data_r4_i2~2 pack_data_R4_I2 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_r4_i2~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I2","tags":"","loc":"proc/pack_data_r4_i2~2.html","title":"pack_data_R4_I2 – StringiFor"},{"text":"private pure subroutine pack_data_R4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_r4_i1~2~~CalledByGraph proc~pack_data_r4_i1~2 pack_data_R4_I1 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_r4_i1~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_R4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_R4_I1","tags":"","loc":"proc/pack_data_r4_i1~2.html","title":"pack_data_R4_I1 – StringiFor"},{"text":"private pure subroutine pack_data_I8_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_r8~2~~CalledByGraph proc~pack_data_i8_r8~2 pack_data_I8_R8 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i8_r8~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R8","tags":"","loc":"proc/pack_data_i8_r8~2.html","title":"pack_data_I8_R8 – StringiFor"},{"text":"private pure subroutine pack_data_I8_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_r4~2~~CalledByGraph proc~pack_data_i8_r4~2 pack_data_I8_R4 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i8_r4~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_R4","tags":"","loc":"proc/pack_data_i8_r4~2.html","title":"pack_data_I8_R4 – StringiFor"},{"text":"private pure subroutine pack_data_I8_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_i4~2~~CalledByGraph proc~pack_data_i8_i4~2 pack_data_I8_I4 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i8_i4~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I4","tags":"","loc":"proc/pack_data_i8_i4~2.html","title":"pack_data_I8_I4 – StringiFor"},{"text":"private pure subroutine pack_data_I8_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_i2~2~~CalledByGraph proc~pack_data_i8_i2~2 pack_data_I8_I2 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i8_i2~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I2","tags":"","loc":"proc/pack_data_i8_i2~2.html","title":"pack_data_I8_I2 – StringiFor"},{"text":"private pure subroutine pack_data_I8_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i8_i1~2~~CalledByGraph proc~pack_data_i8_i1~2 pack_data_I8_I1 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i8_i1~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I8_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I8_I1","tags":"","loc":"proc/pack_data_i8_i1~2.html","title":"pack_data_I8_I1 – StringiFor"},{"text":"private pure subroutine pack_data_I4_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_r8~2~~CalledByGraph proc~pack_data_i4_r8~2 pack_data_I4_R8 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i4_r8~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R8","tags":"","loc":"proc/pack_data_i4_r8~2.html","title":"pack_data_I4_R8 – StringiFor"},{"text":"private pure subroutine pack_data_I4_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_r4~2~~CalledByGraph proc~pack_data_i4_r4~2 pack_data_I4_R4 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i4_r4~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_R4","tags":"","loc":"proc/pack_data_i4_r4~2.html","title":"pack_data_I4_R4 – StringiFor"},{"text":"private pure subroutine pack_data_I4_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_i8~2~~CalledByGraph proc~pack_data_i4_i8~2 pack_data_I4_I8 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i4_i8~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I8","tags":"","loc":"proc/pack_data_i4_i8~2.html","title":"pack_data_I4_I8 – StringiFor"},{"text":"private pure subroutine pack_data_I4_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_i2~2~~CalledByGraph proc~pack_data_i4_i2~2 pack_data_I4_I2 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i4_i2~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I2","tags":"","loc":"proc/pack_data_i4_i2~2.html","title":"pack_data_I4_I2 – StringiFor"},{"text":"private pure subroutine pack_data_I4_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i4_i1~2~~CalledByGraph proc~pack_data_i4_i1~2 pack_data_I4_I1 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i4_i1~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I4_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I4_I1","tags":"","loc":"proc/pack_data_i4_i1~2.html","title":"pack_data_I4_I1 – StringiFor"},{"text":"private pure subroutine pack_data_I2_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_r8~2~~CalledByGraph proc~pack_data_i2_r8~2 pack_data_I2_R8 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i2_r8~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R8","tags":"","loc":"proc/pack_data_i2_r8~2.html","title":"pack_data_I2_R8 – StringiFor"},{"text":"private pure subroutine pack_data_I2_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_r4~2~~CalledByGraph proc~pack_data_i2_r4~2 pack_data_I2_R4 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i2_r4~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_R4","tags":"","loc":"proc/pack_data_i2_r4~2.html","title":"pack_data_I2_R4 – StringiFor"},{"text":"private pure subroutine pack_data_I2_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_i8~2~~CalledByGraph proc~pack_data_i2_i8~2 pack_data_I2_I8 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i2_i8~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I8","tags":"","loc":"proc/pack_data_i2_i8~2.html","title":"pack_data_I2_I8 – StringiFor"},{"text":"private pure subroutine pack_data_I2_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_i4~2~~CalledByGraph proc~pack_data_i2_i4~2 pack_data_I2_I4 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i2_i4~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I4","tags":"","loc":"proc/pack_data_i2_i4~2.html","title":"pack_data_I2_I4 – StringiFor"},{"text":"private pure subroutine pack_data_I2_I1(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i2_i1~2~~CalledByGraph proc~pack_data_i2_i1~2 pack_data_I2_I1 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i2_i1~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I2_I1 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I2_I1","tags":"","loc":"proc/pack_data_i2_i1~2.html","title":"pack_data_I2_I1 – StringiFor"},{"text":"private pure subroutine pack_data_I1_R8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_r8~2~~CalledByGraph proc~pack_data_i1_r8~2 pack_data_I1_R8 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i1_r8~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_R8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R8","tags":"","loc":"proc/pack_data_i1_r8~2.html","title":"pack_data_I1_R8 – StringiFor"},{"text":"private pure subroutine pack_data_I1_R4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_r4~2~~CalledByGraph proc~pack_data_i1_r4~2 pack_data_I1_R4 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i1_r4~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_R4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_R4","tags":"","loc":"proc/pack_data_i1_r4~2.html","title":"pack_data_I1_R4 – StringiFor"},{"text":"private pure subroutine pack_data_I1_I8(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_i8~2~~CalledByGraph proc~pack_data_i1_i8~2 pack_data_I1_I8 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i1_i8~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_I8 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I8","tags":"","loc":"proc/pack_data_i1_i8~2.html","title":"pack_data_I1_I8 – StringiFor"},{"text":"private pure subroutine pack_data_I1_I4(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_i4~2~~CalledByGraph proc~pack_data_i1_i4~2 pack_data_I1_I4 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i1_i4~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_I4 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I4","tags":"","loc":"proc/pack_data_i1_i4~2.html","title":"pack_data_I1_I4 – StringiFor"},{"text":"private pure subroutine pack_data_I1_I2(a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Called By proc~~pack_data_i1_i2~2~~CalledByGraph proc~pack_data_i1_i2~2 pack_data_I1_I2 interface~pack_data~2 pack_data interface~pack_data~2->proc~pack_data_i1_i2~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: p1 (:) Temporary packed data of first stream. integer(kind=I1P), public, allocatable :: p2 (:) Temporary packed data of second stream. integer(kind=I4P), public :: np Size of temporary packed data. Source Code pure subroutine pack_data_I1_I2 ( a1 , a2 , packed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pack different kinds of data into single I1P array. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. integer ( I4P ) :: np !< Size of temporary packed data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- np = size ( transfer ( a1 , p1 )) ; allocate ( p1 ( 1 : np )) ; p1 = transfer ( a1 , p1 ) np = size ( transfer ( a2 , p2 )) ; allocate ( p2 ( 1 : np )) ; p2 = transfer ( a2 , p2 ) if ( allocated ( packed )) deallocate ( packed ) ; allocate ( packed ( 1 : size ( p1 , dim = 1 ) + size ( p2 , dim = 1 ))) ; packed = [ p1 , p2 ] deallocate ( p1 , p2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine pack_data_I1_I2","tags":"","loc":"proc/pack_data_i1_i2~2.html","title":"pack_data_I1_I2 – StringiFor"},{"text":"public interface pack_data Pack different kinds of data into single I1P array. This is useful for encoding different (heterogeneous) kinds variables into a single (homogeneous) stream of bits. Note This procedure exploits the transfer builtin function, that from the standard (2003+) is defined as TRANSFER(SOURCE, MOLD [, SIZE]) . Data object having a physical representation identical to that of SOURCE but with the type\n and type parameters of MOLD . The result is of the same type and type parameters as MOLD .\n If MOLD is an array and SIZE is absent, the result is an array and of rank one. Its size is as small as possible such\n that its physical representation is not shorter than that of SOURCE . Presently, the following combinations are available: Arrays-Arrays: real(any)-real(any); real(any)-integer(any); integer(any)-integer(any); integer(any)-real(any); real(any)-character; character-real(any); integer(any)-character; character-integer(any); Scalars-Scalars: real(any)-real(any); real(any)-integer(any); integer(any)-integer(any); integer(any)-real(any); real(any)-character; character-real(any); integer(any)-character; character-integer(any); Examples of usage Packing two real arrays, one with kind R8P and one with R4P real ( R8P ) :: array_r8 ( 1 : 12 ) real ( R4P ) :: array_r4 ( - 1 : 5 ) integer ( I1P ), allocatable :: rpack ... call pack_data ( a1 = array_r8 , a2 = array_r4 , packed = rpack ) Packing two arrays, one real with kind R4P and one integer with I4P real ( R4P ) :: array_r4 ( 2 ) integer ( I4P ) :: array_i4 ( 0 : 2 ) integer ( I1P ), allocatable :: rpack ... call pack_data ( a1 = array_r4 , a2 = array_i4 , packed = rpack ) Calls interface~~pack_data~2~~CallsGraph interface~pack_data~2 pack_data proc~pack_data_i8_r8~2 pack_data_I8_R8 interface~pack_data~2->proc~pack_data_i8_r8~2 proc~pack_data_i1_r4~2 pack_data_I1_R4 interface~pack_data~2->proc~pack_data_i1_r4~2 proc~pack_data_i1_r8~2 pack_data_I1_R8 interface~pack_data~2->proc~pack_data_i1_r8~2 proc~pack_data_i8_r4~2 pack_data_I8_R4 interface~pack_data~2->proc~pack_data_i8_r4~2 proc~pack_data_i2_i4~2 pack_data_I2_I4 interface~pack_data~2->proc~pack_data_i2_i4~2 proc~pack_data_i1_i8~2 pack_data_I1_I8 interface~pack_data~2->proc~pack_data_i1_i8~2 proc~pack_data_i8_i4~2 pack_data_I8_I4 interface~pack_data~2->proc~pack_data_i8_i4~2 proc~pack_data_i1_i4~2 pack_data_I1_I4 interface~pack_data~2->proc~pack_data_i1_i4~2 proc~pack_data_i8_i2~2 pack_data_I8_I2 interface~pack_data~2->proc~pack_data_i8_i2~2 proc~pack_data_i4_i2~2 pack_data_I4_I2 interface~pack_data~2->proc~pack_data_i4_i2~2 proc~pack_data_i1_i2~2 pack_data_I1_I2 interface~pack_data~2->proc~pack_data_i1_i2~2 proc~pack_data_i8_i1~2 pack_data_I8_I1 interface~pack_data~2->proc~pack_data_i8_i1~2 proc~pack_data_i4_r8~2 pack_data_I4_R8 interface~pack_data~2->proc~pack_data_i4_r8~2 proc~pack_data_i2_r4~2 pack_data_I2_R4 interface~pack_data~2->proc~pack_data_i2_r4~2 proc~pack_data_r8_r4~2 pack_data_R8_R4 interface~pack_data~2->proc~pack_data_r8_r4~2 proc~pack_data_i4_r4~2 pack_data_I4_R4 interface~pack_data~2->proc~pack_data_i4_r4~2 proc~pack_data_r8_i8~2 pack_data_R8_I8 interface~pack_data~2->proc~pack_data_r8_i8~2 proc~pack_data_i2_i1~2 pack_data_I2_I1 interface~pack_data~2->proc~pack_data_i2_i1~2 proc~pack_data_r8_i4~2 pack_data_R8_I4 interface~pack_data~2->proc~pack_data_r8_i4~2 proc~pack_data_i4_i1~2 pack_data_I4_I1 interface~pack_data~2->proc~pack_data_i4_i1~2 proc~pack_data_r8_i2~2 pack_data_R8_I2 interface~pack_data~2->proc~pack_data_r8_i2~2 proc~pack_data_i2_r8~2 pack_data_I2_R8 interface~pack_data~2->proc~pack_data_i2_r8~2 proc~pack_data_r4_r8~2 pack_data_R4_R8 interface~pack_data~2->proc~pack_data_r4_r8~2 proc~pack_data_i2_i8~2 pack_data_I2_I8 interface~pack_data~2->proc~pack_data_i2_i8~2 proc~pack_data_r4_i8~2 pack_data_R4_I8 interface~pack_data~2->proc~pack_data_r4_i8~2 proc~pack_data_r4_i4~2 pack_data_R4_I4 interface~pack_data~2->proc~pack_data_r4_i4~2 proc~pack_data_i4_i8~2 pack_data_I4_I8 interface~pack_data~2->proc~pack_data_i4_i8~2 proc~pack_data_r4_i2~2 pack_data_R4_I2 interface~pack_data~2->proc~pack_data_r4_i2~2 proc~pack_data_r4_i1~2 pack_data_R4_I1 interface~pack_data~2->proc~pack_data_r4_i1~2 proc~pack_data_r8_i1~2 pack_data_R8_I1 interface~pack_data~2->proc~pack_data_r8_i1~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array.","tags":"","loc":"interface/pack_data~2.html","title":"pack_data – StringiFor"},{"text":"public subroutine b64_init() Arguments None Description Initialize the BeFoR64 library. Note This procedure must be called before encoding/decoding anything! Called By proc~~b64_init~2~~CalledByGraph proc~b64_init~2 b64_init proc~autotest~2 autotest proc~autotest~2->proc~b64_init~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize the BeFoR64 library. !< !< @note This procedure **must** be called before encoding/decoding anything! !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init is_b64_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_init","tags":"","loc":"proc/b64_init~2.html","title":"b64_init – StringiFor"},{"text":"private pure subroutine encode_bits(bits, padd, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: bits (1:) Bits to be encoded. integer(kind=I4P), intent(in) :: padd Number of padding characters ('='). character(len=*), intent(out) :: code Characters code. Description Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) +--first octet--+-second octet--+--third octet--+\n |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|\n +-----------+---+-------+-------+---+-----------+\n |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|\n +--1.index--+--2.index--+--3.index--+--4.index--+ Note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. Note The number of paddings must be computed outside this procedure, into the calling scope. Warning This procedure is the backend of encoding, thus it must be never called outside the module. Called By proc~~encode_bits~2~~CalledByGraph proc~encode_bits~2 encode_bits proc~b64_encode_string_a~2 b64_encode_string_a proc~b64_encode_string_a~2->proc~encode_bits~2 proc~b64_encode_i4~2 b64_encode_I4 proc~b64_encode_i4~2->proc~encode_bits~2 proc~b64_encode_r4_a~2 b64_encode_R4_a proc~b64_encode_r4_a~2->proc~encode_bits~2 proc~b64_encode_i4_a~2 b64_encode_I4_a proc~b64_encode_i4_a~2->proc~encode_bits~2 proc~b64_encode_i2~2 b64_encode_I2 proc~b64_encode_i2~2->proc~encode_bits~2 proc~b64_encode_r16_a~2 b64_encode_R16_a proc~b64_encode_r16_a~2->proc~encode_bits~2 proc~b64_encode_r8~2 b64_encode_R8 proc~b64_encode_r8~2->proc~encode_bits~2 proc~b64_encode_i1_a~2 b64_encode_I1_a proc~b64_encode_i1_a~2->proc~encode_bits~2 proc~b64_encode_r16~2 b64_encode_R16 proc~b64_encode_r16~2->proc~encode_bits~2 proc~b64_encode_i1~2 b64_encode_I1 proc~b64_encode_i1~2->proc~encode_bits~2 proc~b64_encode_string~2 b64_encode_string proc~b64_encode_string~2->proc~encode_bits~2 proc~b64_encode_r8_a~2 b64_encode_R8_a proc~b64_encode_r8_a~2->proc~encode_bits~2 proc~b64_encode_i2_a~2 b64_encode_I2_a proc~b64_encode_i2_a~2->proc~encode_bits~2 proc~b64_encode_i8_a~2 b64_encode_I8_a proc~b64_encode_i8_a~2->proc~encode_bits~2 proc~b64_encode_i8~2 b64_encode_I8 proc~b64_encode_i8~2->proc~encode_bits~2 proc~b64_encode_r4~2 b64_encode_R4 proc~b64_encode_r4~2->proc~encode_bits~2 proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_string_a~2 proc~b64_encode_up_a~2->proc~b64_encode_r4_a~2 proc~b64_encode_up_a~2->proc~b64_encode_i4_a~2 proc~b64_encode_up_a~2->proc~b64_encode_i1_a~2 proc~b64_encode_up_a~2->proc~b64_encode_r8_a~2 proc~b64_encode_up_a~2->proc~b64_encode_i2_a~2 proc~b64_encode_up_a~2->proc~b64_encode_i8_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_string_a~2 interface~b64_encode~2->proc~b64_encode_i4~2 interface~b64_encode~2->proc~b64_encode_r4_a~2 interface~b64_encode~2->proc~b64_encode_i4_a~2 interface~b64_encode~2->proc~b64_encode_i2~2 interface~b64_encode~2->proc~b64_encode_r8~2 interface~b64_encode~2->proc~b64_encode_i1_a~2 interface~b64_encode~2->proc~b64_encode_i1~2 interface~b64_encode~2->proc~b64_encode_string~2 interface~b64_encode~2->proc~b64_encode_r8_a~2 interface~b64_encode~2->proc~b64_encode_i2_a~2 interface~b64_encode~2->proc~b64_encode_i8_a~2 interface~b64_encode~2->proc~b64_encode_i8~2 interface~b64_encode~2->proc~b64_encode_r4~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_i4~2 proc~b64_encode_up~2->proc~b64_encode_i2~2 proc~b64_encode_up~2->proc~b64_encode_r8~2 proc~b64_encode_up~2->proc~b64_encode_i1~2 proc~b64_encode_up~2->proc~b64_encode_string~2 proc~b64_encode_up~2->proc~b64_encode_i8~2 proc~b64_encode_up~2->proc~b64_encode_r4~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: sixb (1:4) 6 bits slices (stored into 8 bits integer) of 24 bits input. integer(kind=I8P), public :: c Counter. integer(kind=I8P), public :: e Counter. integer(kind=I8P), public :: Nb Length of bits array. Source Code pure subroutine encode_bits ( bits , padd , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). !< !< The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) !<``` !< +--first octet--+-second octet--+--third octet--+ !< |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0| !< +-----------+---+-------+-------+---+-----------+ !< |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0| !< +--1.index--+--2.index--+--3.index--+--4.index--+ !<``` !< @note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. !< !< @note The number of paddings must be computed outside this procedure, into the calling scope. !< !< @warning This procedure is the backend of encoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: bits ( 1 :) !< Bits to be encoded. integer ( I4P ), intent ( in ) :: padd !< Number of padding characters ('='). character ( * ), intent ( out ) :: code !< Characters code. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) c = 1_I8P do e = 1_I8P , Nb , 3_I8P ! loop over array elements: 3 bytes (24 bits) scanning sixb = 0_I1P call mvbits ( bits ( e ), 2 , 6 , sixb ( 1 ), 0 ) call mvbits ( bits ( e ), 0 , 2 , sixb ( 2 ), 4 ) if ( e + 1 <= Nb ) then call mvbits ( bits ( e + 1 ), 4 , 4 , sixb ( 2 ), 0 ) call mvbits ( bits ( e + 1 ), 0 , 4 , sixb ( 3 ), 2 ) endif if ( e + 2 <= Nb ) then call mvbits ( bits ( e + 2 ), 6 , 2 , sixb ( 3 ), 0 ) call mvbits ( bits ( e + 2 ), 0 , 6 , sixb ( 4 ), 0 ) endif sixb = sixb + 1_I1P code ( c : c ) = base64 ( sixb ( 1 ): sixb ( 1 )) code ( c + 1 : c + 1 ) = base64 ( sixb ( 2 ): sixb ( 2 )) code ( c + 2 : c + 2 ) = base64 ( sixb ( 3 ): sixb ( 3 )) code ( c + 3 : c + 3 ) = base64 ( sixb ( 4 ): sixb ( 4 )) c = c + 4_I8P enddo if ( padd > 0 ) code ( len ( code ) - padd + 1 :) = repeat ( '=' , padd ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine encode_bits","tags":"","loc":"proc/encode_bits~2.html","title":"encode_bits – StringiFor"},{"text":"private pure subroutine decode_bits(code, bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Characters code. integer(kind=I1P), intent(out) :: bits (1:) Bits decoded. Description Decode a base64 string into a sequence of bits stream. The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code QUJD the decoding process must do +-b64 char--+-b64 char--+-b64 char--+-b64 char--+\n |      Q    |      U    |      J    |      D    |\n +-b64 index-+-b64 index-+-b64 index-+-b64 index-+\n !      16   |      20   |      9    |      3    |\n +-6 bits----+-6 bits----+-6 bits----+-6 bits----+\n |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1|\n +-----------+---+-------+-------+---+-----------+\n |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1|\n +-----8 bits----+-----8 bits----+-----8 bits----+ Note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. Warning This procedure is the backend of decoding, thus it must be never called outside the module. Called By proc~~decode_bits~2~~CalledByGraph proc~decode_bits~2 decode_bits proc~b64_decode_i8~2 b64_decode_I8 proc~b64_decode_i8~2->proc~decode_bits~2 proc~b64_decode_string~2 b64_decode_string proc~b64_decode_string~2->proc~decode_bits~2 proc~b64_decode_string_a~2 b64_decode_string_a proc~b64_decode_string_a~2->proc~decode_bits~2 proc~b64_decode_i2~2 b64_decode_I2 proc~b64_decode_i2~2->proc~decode_bits~2 proc~b64_decode_i2_a~2 b64_decode_I2_a proc~b64_decode_i2_a~2->proc~decode_bits~2 proc~b64_decode_i4~2 b64_decode_I4 proc~b64_decode_i4~2->proc~decode_bits~2 proc~b64_decode_i4_a~2 b64_decode_I4_a proc~b64_decode_i4_a~2->proc~decode_bits~2 proc~b64_decode_i1_a~2 b64_decode_I1_a proc~b64_decode_i1_a~2->proc~decode_bits~2 proc~b64_decode_r8~2 b64_decode_R8 proc~b64_decode_r8~2->proc~decode_bits~2 proc~b64_decode_r16_a~2 b64_decode_R16_a proc~b64_decode_r16_a~2->proc~decode_bits~2 proc~b64_decode_r8_a~2 b64_decode_R8_a proc~b64_decode_r8_a~2->proc~decode_bits~2 proc~b64_decode_r4~2 b64_decode_R4 proc~b64_decode_r4~2->proc~decode_bits~2 proc~b64_decode_i1~2 b64_decode_I1 proc~b64_decode_i1~2->proc~decode_bits~2 proc~b64_decode_r4_a~2 b64_decode_R4_a proc~b64_decode_r4_a~2->proc~decode_bits~2 proc~b64_decode_r16~2 b64_decode_R16 proc~b64_decode_r16~2->proc~decode_bits~2 proc~b64_decode_i8_a~2 b64_decode_I8_a proc~b64_decode_i8_a~2->proc~decode_bits~2 proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_i8~2 proc~b64_decode_up~2->proc~b64_decode_string~2 proc~b64_decode_up~2->proc~b64_decode_i2~2 proc~b64_decode_up~2->proc~b64_decode_i4~2 proc~b64_decode_up~2->proc~b64_decode_r8~2 proc~b64_decode_up~2->proc~b64_decode_r4~2 proc~b64_decode_up~2->proc~b64_decode_i1~2 interface~b64_decode~2 b64_decode interface~b64_decode~2->proc~b64_decode_i8~2 interface~b64_decode~2->proc~b64_decode_string~2 interface~b64_decode~2->proc~b64_decode_string_a~2 interface~b64_decode~2->proc~b64_decode_i2~2 interface~b64_decode~2->proc~b64_decode_i2_a~2 interface~b64_decode~2->proc~b64_decode_i4~2 interface~b64_decode~2->proc~b64_decode_i4_a~2 interface~b64_decode~2->proc~b64_decode_i1_a~2 interface~b64_decode~2->proc~b64_decode_r8~2 interface~b64_decode~2->proc~b64_decode_r8_a~2 interface~b64_decode~2->proc~b64_decode_r4~2 interface~b64_decode~2->proc~b64_decode_i1~2 interface~b64_decode~2->proc~b64_decode_r4_a~2 interface~b64_decode~2->proc~b64_decode_i8_a~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_string_a~2 proc~b64_decode_up_a~2->proc~b64_decode_i2_a~2 proc~b64_decode_up_a~2->proc~b64_decode_i4_a~2 proc~b64_decode_up_a~2->proc~b64_decode_i1_a~2 proc~b64_decode_up_a~2->proc~b64_decode_r8_a~2 proc~b64_decode_up_a~2->proc~b64_decode_r4_a~2 proc~b64_decode_up_a~2->proc~b64_decode_i8_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public :: sixb (1:4) 6 bits slices (stored into 8 bits integer) of 24 bits input. integer(kind=I8P), public :: c Counter. integer(kind=I8P), public :: e Counter. integer(kind=I8P), public :: Nb Length of bits array. Source Code pure subroutine decode_bits ( code , bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 string into a sequence of bits stream. !< !< The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code !< `QUJD` the decoding process must do !<``` !< +-b64 char--+-b64 char--+-b64 char--+-b64 char--+ !< |      Q    |      U    |      J    |      D    | !< +-b64 index-+-b64 index-+-b64 index-+-b64 index-+ !< !      16   |      20   |      9    |      3    | !< +-6 bits----+-6 bits----+-6 bits----+-6 bits----+ !< |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1| !< +-----------+---+-------+-------+---+-----------+ !< |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1| !< +-----8 bits----+-----8 bits----+-----8 bits----+ !<``` !< @note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. !< !< @warning This procedure is the backend of decoding, thus it must be never called outside the module. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Characters code. integer ( I1P ), intent ( out ) :: bits ( 1 :) !< Bits decoded. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- Nb = size ( bits , dim = 1 , kind = I8P ) e = 1_I8P do c = 1_I8P , len ( code ), 4_I8P ! loop over code characters: 3 bytes (24 bits) scanning sixb = 0_I1P sixb ( 1 ) = index ( base64 , code ( c : c )) - 1 sixb ( 2 ) = index ( base64 , code ( c + 1 : c + 1 )) - 1 sixb ( 3 ) = index ( base64 , code ( c + 2 : c + 2 )) - 1 sixb ( 4 ) = index ( base64 , code ( c + 3 : c + 3 )) - 1 call mvbits ( sixb ( 1 ), 0 , 6 , bits ( e ), 2 ) ; call mvbits ( sixb ( 2 ), 4 , 2 , bits ( e ), 0 ) if ( e + 1 <= Nb ) then call mvbits ( sixb ( 2 ), 0 , 4 , bits ( e + 1 ), 4 ) ; call mvbits ( sixb ( 3 ), 2 , 4 , bits ( e + 1 ), 0 ) endif if ( e + 2 <= Nb ) then call mvbits ( sixb ( 3 ), 0 , 2 , bits ( e + 2 ), 6 ) ; call mvbits ( sixb ( 4 ), 0 , 6 , bits ( e + 2 ), 0 ) endif e = e + 3_I8P enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine decode_bits","tags":"","loc":"proc/decode_bits~2.html","title":"decode_bits – StringiFor"},{"text":"public subroutine b64_encode_up(up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode an unlimited polymorphic scalar to base64. Calls proc~~b64_encode_up~2~~CallsGraph proc~b64_encode_up~2 b64_encode_up proc~b64_encode_i4~2 b64_encode_I4 proc~b64_encode_up~2->proc~b64_encode_i4~2 proc~b64_encode_i2~2 b64_encode_I2 proc~b64_encode_up~2->proc~b64_encode_i2~2 proc~b64_encode_r8~2 b64_encode_R8 proc~b64_encode_up~2->proc~b64_encode_r8~2 proc~b64_encode_i1~2 b64_encode_I1 proc~b64_encode_up~2->proc~b64_encode_i1~2 proc~b64_encode_string~2 b64_encode_string proc~b64_encode_up~2->proc~b64_encode_string~2 proc~b64_encode_i8~2 b64_encode_I8 proc~b64_encode_up~2->proc~b64_encode_i8~2 proc~b64_encode_r4~2 b64_encode_R4 proc~b64_encode_up~2->proc~b64_encode_r4~2 proc~encode_bits~2 encode_bits proc~b64_encode_i4~2->proc~encode_bits~2 proc~b64_encode_i2~2->proc~encode_bits~2 proc~b64_encode_r8~2->proc~encode_bits~2 proc~b64_encode_i1~2->proc~encode_bits~2 proc~b64_encode_string~2->proc~encode_bits~2 interface~byte_size byte_size proc~b64_encode_string~2->interface~byte_size proc~b64_encode_i8~2->proc~encode_bits~2 proc~b64_encode_r4~2->proc~encode_bits~2 proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_encode_up ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic scalar to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8 ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4 ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8 ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4 ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2 ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1 ( n = up , code = code ) type is ( character ( * )) call b64_encode_string ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up","tags":"","loc":"proc/b64_encode_up~2.html","title":"b64_encode_up – StringiFor"},{"text":"private pure subroutine b64_encode_up_a(up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64. Calls proc~~b64_encode_up_a~2~~CallsGraph proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_string_a~2 b64_encode_string_a proc~b64_encode_up_a~2->proc~b64_encode_string_a~2 proc~b64_encode_i4_a~2 b64_encode_I4_a proc~b64_encode_up_a~2->proc~b64_encode_i4_a~2 proc~b64_encode_i2_a~2 b64_encode_I2_a proc~b64_encode_up_a~2->proc~b64_encode_i2_a~2 proc~b64_encode_r8_a~2 b64_encode_R8_a proc~b64_encode_up_a~2->proc~b64_encode_r8_a~2 proc~b64_encode_i1_a~2 b64_encode_I1_a proc~b64_encode_up_a~2->proc~b64_encode_i1_a~2 proc~b64_encode_i8_a~2 b64_encode_I8_a proc~b64_encode_up_a~2->proc~b64_encode_i8_a~2 proc~b64_encode_r4_a~2 b64_encode_R4_a proc~b64_encode_up_a~2->proc~b64_encode_r4_a~2 interface~byte_size byte_size proc~b64_encode_string_a~2->interface~byte_size proc~encode_bits~2 encode_bits proc~b64_encode_string_a~2->proc~encode_bits~2 proc~b64_encode_i4_a~2->proc~encode_bits~2 proc~b64_encode_i2_a~2->proc~encode_bits~2 proc~b64_encode_r8_a~2->proc~encode_bits~2 proc~b64_encode_i1_a~2->proc~encode_bits~2 proc~b64_encode_i8_a~2->proc~encode_bits~2 proc~b64_encode_r4_a~2->proc~encode_bits~2 proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_up_a~2~~CalledByGraph proc~b64_encode_up_a~2 b64_encode_up_a interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine b64_encode_up_a ( up , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode an unlimited polymorphic array to base64. !--------------------------------------------------------------------------------------------------------------------------------- class ( * ), intent ( in ) :: up ( 1 :) !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_encode_R8_a ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4_a ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8_a ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4_a ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2_a ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1_a ( n = up , code = code ) type is ( character ( * )) call b64_encode_string_a ( s = up , code = code ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_up_a","tags":"","loc":"proc/b64_encode_up_a~2.html","title":"b64_encode_up_a – StringiFor"},{"text":"public subroutine b64_decode_up(code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. class(*), intent(out) :: up Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic scalar from base64. Calls proc~~b64_decode_up~2~~CallsGraph proc~b64_decode_up~2 b64_decode_up proc~b64_decode_i8~2 b64_decode_I8 proc~b64_decode_up~2->proc~b64_decode_i8~2 proc~b64_decode_string~2 b64_decode_string proc~b64_decode_up~2->proc~b64_decode_string~2 proc~b64_decode_i2~2 b64_decode_I2 proc~b64_decode_up~2->proc~b64_decode_i2~2 proc~b64_decode_i4~2 b64_decode_I4 proc~b64_decode_up~2->proc~b64_decode_i4~2 proc~b64_decode_r8~2 b64_decode_R8 proc~b64_decode_up~2->proc~b64_decode_r8~2 proc~b64_decode_r4~2 b64_decode_R4 proc~b64_decode_up~2->proc~b64_decode_r4~2 proc~b64_decode_i1~2 b64_decode_I1 proc~b64_decode_up~2->proc~b64_decode_i1~2 proc~decode_bits~2 decode_bits proc~b64_decode_i8~2->proc~decode_bits~2 proc~b64_decode_string~2->proc~decode_bits~2 interface~byte_size byte_size proc~b64_decode_string~2->interface~byte_size proc~b64_decode_i2~2->proc~decode_bits~2 proc~b64_decode_i4~2->proc~decode_bits~2 proc~b64_decode_r8~2->proc~decode_bits~2 proc~b64_decode_r4~2->proc~decode_bits~2 proc~b64_decode_i1~2->proc~decode_bits~2 proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_decode_up ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic scalar from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. class ( * ), intent ( out ) :: up !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8 ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4 ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8 ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4 ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2 ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1 ( code = code , n = up ) type is ( character ( * )) call b64_decode_string ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up","tags":"","loc":"proc/b64_decode_up~2.html","title":"b64_decode_up – StringiFor"},{"text":"private subroutine b64_decode_up_a(code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64. Calls proc~~b64_decode_up_a~2~~CallsGraph proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_i8_a~2 b64_decode_I8_a proc~b64_decode_up_a~2->proc~b64_decode_i8_a~2 proc~b64_decode_string_a~2 b64_decode_string_a proc~b64_decode_up_a~2->proc~b64_decode_string_a~2 proc~b64_decode_i4_a~2 b64_decode_I4_a proc~b64_decode_up_a~2->proc~b64_decode_i4_a~2 proc~b64_decode_r4_a~2 b64_decode_R4_a proc~b64_decode_up_a~2->proc~b64_decode_r4_a~2 proc~b64_decode_r8_a~2 b64_decode_R8_a proc~b64_decode_up_a~2->proc~b64_decode_r8_a~2 proc~b64_decode_i1_a~2 b64_decode_I1_a proc~b64_decode_up_a~2->proc~b64_decode_i1_a~2 proc~b64_decode_i2_a~2 b64_decode_I2_a proc~b64_decode_up_a~2->proc~b64_decode_i2_a~2 proc~decode_bits~2 decode_bits proc~b64_decode_i8_a~2->proc~decode_bits~2 proc~b64_decode_string_a~2->proc~decode_bits~2 interface~byte_size byte_size proc~b64_decode_string_a~2->interface~byte_size proc~b64_decode_i4_a~2->proc~decode_bits~2 proc~b64_decode_r4_a~2->proc~decode_bits~2 proc~b64_decode_r8_a~2->proc~decode_bits~2 proc~b64_decode_i1_a~2->proc~decode_bits~2 proc~b64_decode_i2_a~2->proc~decode_bits~2 proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_up_a~2~~CalledByGraph proc~b64_decode_up_a~2 b64_decode_up_a interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine b64_decode_up_a ( code , up ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode an unlimited polymorphic array from base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. class ( * ), intent ( out ) :: up ( 1 :) !< Unlimited polymorphic variable to be decoded. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- select type ( up ) type is ( real ( R8P )) call b64_decode_R8_a ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4_a ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8_a ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4_a ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2_a ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1_a ( code = code , n = up ) type is ( character ( * )) call b64_decode_string_a ( code = code , s = up ) endselect return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_up_a","tags":"","loc":"proc/b64_decode_up_a~2.html","title":"b64_decode_up_a – StringiFor"},{"text":"private pure subroutine b64_encode_R16(n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R16P). Calls proc~~b64_encode_r16~2~~CallsGraph proc~b64_encode_r16~2 b64_encode_R16 proc~encode_bits~2 encode_bits proc~b64_encode_r16~2->proc~encode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_R16 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR16P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16","tags":"","loc":"proc/b64_encode_r16~2.html","title":"b64_encode_R16 – StringiFor"},{"text":"private pure subroutine b64_encode_R8(n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). Calls proc~~b64_encode_r8~2~~CallsGraph proc~b64_encode_r8~2 b64_encode_R8 proc~encode_bits~2 encode_bits proc~b64_encode_r8~2->proc~encode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r8~2~~CalledByGraph proc~b64_encode_r8~2 b64_encode_R8 proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_r8~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_r8~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_R8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR8P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8","tags":"","loc":"proc/b64_encode_r8~2.html","title":"b64_encode_R8 – StringiFor"},{"text":"private pure subroutine b64_encode_R4(n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). Calls proc~~b64_encode_r4~2~~CallsGraph proc~b64_encode_r4~2 b64_encode_R4 proc~encode_bits~2 encode_bits proc~b64_encode_r4~2->proc~encode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r4~2~~CalledByGraph proc~b64_encode_r4~2 b64_encode_R4 proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_r4~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_r4~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_R4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR4P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4","tags":"","loc":"proc/b64_encode_r4~2.html","title":"b64_encode_R4 – StringiFor"},{"text":"private pure subroutine b64_encode_I8(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). Calls proc~~b64_encode_i8~2~~CallsGraph proc~b64_encode_i8~2 b64_encode_I8 proc~encode_bits~2 encode_bits proc~b64_encode_i8~2->proc~encode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i8~2~~CalledByGraph proc~b64_encode_i8~2 b64_encode_I8 proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_i8~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_i8~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I8 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8","tags":"","loc":"proc/b64_encode_i8~2.html","title":"b64_encode_I8 – StringiFor"},{"text":"private pure subroutine b64_encode_I4(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). Calls proc~~b64_encode_i4~2~~CallsGraph proc~b64_encode_i4~2 b64_encode_I4 proc~encode_bits~2 encode_bits proc~b64_encode_i4~2->proc~encode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i4~2~~CalledByGraph proc~b64_encode_i4~2 b64_encode_I4 proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_i4~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_i4~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I4 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI4P ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4","tags":"","loc":"proc/b64_encode_i4~2.html","title":"b64_encode_I4 – StringiFor"},{"text":"private pure subroutine b64_encode_I2(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). Calls proc~~b64_encode_i2~2~~CallsGraph proc~b64_encode_i2~2 b64_encode_I2 proc~encode_bits~2 encode_bits proc~b64_encode_i2~2->proc~encode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i2~2~~CalledByGraph proc~b64_encode_i2~2 b64_encode_I2 proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_i2~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_i2~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I2 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI2P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2","tags":"","loc":"proc/b64_encode_i2~2.html","title":"b64_encode_I2 – StringiFor"},{"text":"private pure subroutine b64_encode_I1(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). Calls proc~~b64_encode_i1~2~~CallsGraph proc~b64_encode_i1~2 b64_encode_I1 proc~encode_bits~2 encode_bits proc~b64_encode_i1~2->proc~encode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i1~2~~CalledByGraph proc~b64_encode_i1~2 b64_encode_I1 proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_i1~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_i1~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). Source Code pure subroutine b64_encode_I1 ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar number to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 :(( BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI1P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1","tags":"","loc":"proc/b64_encode_i1~2.html","title":"b64_encode_I1 – StringiFor"},{"text":"private pure subroutine b64_encode_string(s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. Calls proc~~b64_encode_string~2~~CallsGraph proc~b64_encode_string~2 b64_encode_string interface~byte_size byte_size proc~b64_encode_string~2->interface~byte_size proc~encode_bits~2 encode_bits proc~b64_encode_string~2->proc~encode_bits~2 proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_string~2~~CalledByGraph proc~b64_encode_string~2 b64_encode_string proc~b64_encode_up~2 b64_encode_up proc~b64_encode_up~2->proc~b64_encode_string~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_string~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I4P), public :: BYCHS Bytes of character string. Source Code pure subroutine b64_encode_string ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode scalar string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string","tags":"","loc":"proc/b64_encode_string~2.html","title":"b64_encode_string – StringiFor"},{"text":"private pure subroutine b64_encode_R16_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R16P). Calls proc~~b64_encode_r16_a~2~~CallsGraph proc~b64_encode_r16_a~2 b64_encode_R16_a proc~encode_bits~2 encode_bits proc~b64_encode_r16_a~2->proc~encode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_R16_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R16P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR16P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R16_a","tags":"","loc":"proc/b64_encode_r16_a~2.html","title":"b64_encode_R16_a – StringiFor"},{"text":"private pure subroutine b64_encode_R8_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). Calls proc~~b64_encode_r8_a~2~~CallsGraph proc~b64_encode_r8_a~2 b64_encode_R8_a proc~encode_bits~2 encode_bits proc~b64_encode_r8_a~2->proc~encode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r8_a~2~~CalledByGraph proc~b64_encode_r8_a~2 b64_encode_R8_a proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_r8_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_r8_a~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_R8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R8P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R8_a","tags":"","loc":"proc/b64_encode_r8_a~2.html","title":"b64_encode_R8_a – StringiFor"},{"text":"private pure subroutine b64_encode_R4_a(n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). Calls proc~~b64_encode_r4_a~2~~CallsGraph proc~b64_encode_r4_a~2 b64_encode_R4_a proc~encode_bits~2 encode_bits proc~b64_encode_r4_a~2->proc~encode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r4_a~2~~CalledByGraph proc~b64_encode_r4_a~2 b64_encode_R4_a proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_r4_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_r4_a~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_R4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (R4P). !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_R4_a","tags":"","loc":"proc/b64_encode_r4_a~2.html","title":"b64_encode_R4_a – StringiFor"},{"text":"private pure subroutine b64_encode_I8_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). Calls proc~~b64_encode_i8_a~2~~CallsGraph proc~b64_encode_i8_a~2 b64_encode_I8_a proc~encode_bits~2 encode_bits proc~b64_encode_i8_a~2->proc~encode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i8_a~2~~CalledByGraph proc~b64_encode_i8_a~2 b64_encode_I8_a proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_i8_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_i8_a~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I8_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I8P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I8_a","tags":"","loc":"proc/b64_encode_i8_a~2.html","title":"b64_encode_I8_a – StringiFor"},{"text":"private pure subroutine b64_encode_I4_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). Calls proc~~b64_encode_i4_a~2~~CallsGraph proc~b64_encode_i4_a~2 b64_encode_I4_a proc~encode_bits~2 encode_bits proc~b64_encode_i4_a~2->proc~encode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i4_a~2~~CalledByGraph proc~b64_encode_i4_a~2 b64_encode_I4_a proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_i4_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_i4_a~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I4_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I4P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I4_a","tags":"","loc":"proc/b64_encode_i4_a~2.html","title":"b64_encode_I4_a – StringiFor"},{"text":"private pure subroutine b64_encode_I2_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). Calls proc~~b64_encode_i2_a~2~~CallsGraph proc~b64_encode_i2_a~2 b64_encode_I2_a proc~encode_bits~2 encode_bits proc~b64_encode_i2_a~2->proc~encode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i2_a~2~~CalledByGraph proc~b64_encode_i2_a~2 b64_encode_I2_a proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_i2_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_i2_a~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I2_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I2P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI2P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I2_a","tags":"","loc":"proc/b64_encode_i2_a~2.html","title":"b64_encode_I2_a – StringiFor"},{"text":"private pure subroutine b64_encode_I1_a(n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). Calls proc~~b64_encode_i1_a~2~~CallsGraph proc~b64_encode_i1_a~2 b64_encode_I1_a proc~encode_bits~2 encode_bits proc~b64_encode_i1_a~2->proc~encode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i1_a~2~~CalledByGraph proc~b64_encode_i1_a~2 b64_encode_I1_a proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_i1_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_i1_a~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I8P), public :: ns Size of n. Source Code pure subroutine b64_encode_I1_a ( n , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array numbers to base64 (I1P). !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI1P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_I1_a","tags":"","loc":"proc/b64_encode_i1_a~2.html","title":"b64_encode_I1_a – StringiFor"},{"text":"private pure subroutine b64_encode_string_a(s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64. Calls proc~~b64_encode_string_a~2~~CallsGraph proc~b64_encode_string_a~2 b64_encode_string_a interface~byte_size byte_size proc~b64_encode_string_a~2->interface~byte_size proc~encode_bits~2 encode_bits proc~b64_encode_string_a~2->proc~encode_bits~2 proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_string_a~2~~CalledByGraph proc~b64_encode_string_a~2 b64_encode_string_a proc~b64_encode_up_a~2 b64_encode_up_a proc~b64_encode_up_a~2->proc~b64_encode_string_a~2 interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->proc~b64_encode_up_a~2 interface~b64_encode_up~2->interface~b64_encode_up~2 interface~b64_encode~2 b64_encode interface~b64_encode~2->proc~b64_encode_string_a~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. integer(kind=I4P), public :: padd Number of padding characters ('='). integer(kind=I4P), public :: BYCHS Bytes of character string. Source Code pure subroutine b64_encode_string_a ( s , code ) !--------------------------------------------------------------------------------------------------------------------------------- !< Encode array string to base64. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: s ( 1 :) !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- BYCHS = byte_size ( s ( 1 )) * size ( s , dim = 1 ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_encode_string_a","tags":"","loc":"proc/b64_encode_string_a~2.html","title":"b64_encode_string_a – StringiFor"},{"text":"private elemental subroutine b64_decode_R16(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R16P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R16P). Calls proc~~b64_decode_r16~2~~CallsGraph proc~b64_decode_r16~2 b64_decode_R16 proc~decode_bits~2 decode_bits proc~b64_decode_r16~2->proc~decode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_R16 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R16P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16","tags":"","loc":"proc/b64_decode_r16~2.html","title":"b64_decode_R16 – StringiFor"},{"text":"private elemental subroutine b64_decode_R8(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). Calls proc~~b64_decode_r8~2~~CallsGraph proc~b64_decode_r8~2 b64_decode_R8 proc~decode_bits~2 decode_bits proc~b64_decode_r8~2->proc~decode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r8~2~~CalledByGraph proc~b64_decode_r8~2 b64_decode_R8 proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_r8~2 interface~b64_decode~2 b64_decode interface~b64_decode~2->proc~b64_decode_r8~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_R8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8","tags":"","loc":"proc/b64_decode_r8~2.html","title":"b64_decode_R8 – StringiFor"},{"text":"private elemental subroutine b64_decode_R4(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). Calls proc~~b64_decode_r4~2~~CallsGraph proc~b64_decode_r4~2 b64_decode_R4 proc~decode_bits~2 decode_bits proc~b64_decode_r4~2->proc~decode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r4~2~~CalledByGraph proc~b64_decode_r4~2 b64_decode_R4 proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_r4~2 interface~b64_decode~2 b64_decode interface~b64_decode~2->proc~b64_decode_r4~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_R4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4","tags":"","loc":"proc/b64_decode_r4~2.html","title":"b64_decode_R4 – StringiFor"},{"text":"private elemental subroutine b64_decode_I8(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). Calls proc~~b64_decode_i8~2~~CallsGraph proc~b64_decode_i8~2 b64_decode_I8 proc~decode_bits~2 decode_bits proc~b64_decode_i8~2->proc~decode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i8~2~~CalledByGraph proc~b64_decode_i8~2 b64_decode_I8 proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_i8~2 interface~b64_decode~2 b64_decode interface~b64_decode~2->proc~b64_decode_i8~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I8 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8","tags":"","loc":"proc/b64_decode_i8~2.html","title":"b64_decode_I8 – StringiFor"},{"text":"private elemental subroutine b64_decode_I4(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). Calls proc~~b64_decode_i4~2~~CallsGraph proc~b64_decode_i4~2 b64_decode_I4 proc~decode_bits~2 decode_bits proc~b64_decode_i4~2->proc~decode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i4~2~~CalledByGraph proc~b64_decode_i4~2 b64_decode_I4 proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_i4~2 interface~b64_decode~2 b64_decode interface~b64_decode~2->proc~b64_decode_i4~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I4 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4","tags":"","loc":"proc/b64_decode_i4~2.html","title":"b64_decode_I4 – StringiFor"},{"text":"private elemental subroutine b64_decode_I2(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). Calls proc~~b64_decode_i2~2~~CallsGraph proc~b64_decode_i2~2 b64_decode_I2 proc~decode_bits~2 decode_bits proc~b64_decode_i2~2->proc~decode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i2~2~~CalledByGraph proc~b64_decode_i2~2 b64_decode_I2 proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_i2~2 interface~b64_decode~2 b64_decode interface~b64_decode~2->proc~b64_decode_i2~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I2 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I2P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2","tags":"","loc":"proc/b64_decode_i2~2.html","title":"b64_decode_I2 – StringiFor"},{"text":"private elemental subroutine b64_decode_I1(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). Calls proc~~b64_decode_i1~2~~CallsGraph proc~b64_decode_i1~2 b64_decode_I1 proc~decode_bits~2 decode_bits proc~b64_decode_i1~2->proc~decode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i1~2~~CalledByGraph proc~b64_decode_i1~2 b64_decode_I1 proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_i1~2 interface~b64_decode~2 b64_decode interface~b64_decode~2->proc~b64_decode_i1~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_I1 ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar number (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I1P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1","tags":"","loc":"proc/b64_decode_i1~2.html","title":"b64_decode_I1 – StringiFor"},{"text":"private elemental subroutine b64_decode_string(code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. Calls proc~~b64_decode_string~2~~CallsGraph proc~b64_decode_string~2 b64_decode_string interface~byte_size byte_size proc~b64_decode_string~2->interface~byte_size proc~decode_bits~2 decode_bits proc~b64_decode_string~2->proc~decode_bits~2 proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_string~2~~CalledByGraph proc~b64_decode_string~2 b64_decode_string proc~b64_decode_up~2 b64_decode_up proc~b64_decode_up~2->proc~b64_decode_string~2 interface~b64_decode~2 b64_decode interface~b64_decode~2->proc~b64_decode_string~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code elemental subroutine b64_decode_string ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into a scalar string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string","tags":"","loc":"proc/b64_decode_string~2.html","title":"b64_decode_string – StringiFor"},{"text":"private pure subroutine b64_decode_R16_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R16P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R16P). Calls proc~~b64_decode_r16_a~2~~CallsGraph proc~b64_decode_r16_a~2 b64_decode_R16_a proc~decode_bits~2 decode_bits proc~b64_decode_r16_a~2->proc~decode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_R16_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R16P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R16P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R16_a","tags":"","loc":"proc/b64_decode_r16_a~2.html","title":"b64_decode_R16_a – StringiFor"},{"text":"private pure subroutine b64_decode_R8_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). Calls proc~~b64_decode_r8_a~2~~CallsGraph proc~b64_decode_r8_a~2 b64_decode_R8_a proc~decode_bits~2 decode_bits proc~b64_decode_r8_a~2->proc~decode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r8_a~2~~CalledByGraph proc~b64_decode_r8_a~2 b64_decode_R8_a proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_r8_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 interface~b64_decode~2 b64_decode interface~b64_decode~2->proc~b64_decode_r8_a~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_R8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R8_a","tags":"","loc":"proc/b64_decode_r8_a~2.html","title":"b64_decode_R8_a – StringiFor"},{"text":"private pure subroutine b64_decode_R4_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). Calls proc~~b64_decode_r4_a~2~~CallsGraph proc~b64_decode_r4_a~2 b64_decode_R4_a proc~decode_bits~2 decode_bits proc~b64_decode_r4_a~2->proc~decode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r4_a~2~~CalledByGraph proc~b64_decode_r4_a~2 b64_decode_R4_a proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_r4_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 interface~b64_decode~2 b64_decode interface~b64_decode~2->proc~b64_decode_r4_a~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_R4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (R4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. real ( R4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_R4_a","tags":"","loc":"proc/b64_decode_r4_a~2.html","title":"b64_decode_R4_a – StringiFor"},{"text":"private pure subroutine b64_decode_I8_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). Calls proc~~b64_decode_i8_a~2~~CallsGraph proc~b64_decode_i8_a~2 b64_decode_I8_a proc~decode_bits~2 decode_bits proc~b64_decode_i8_a~2->proc~decode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i8_a~2~~CalledByGraph proc~b64_decode_i8_a~2 b64_decode_I8_a proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_i8_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 interface~b64_decode~2 b64_decode interface~b64_decode~2->proc~b64_decode_i8_a~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I8_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I8P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I8_a","tags":"","loc":"proc/b64_decode_i8_a~2.html","title":"b64_decode_I8_a – StringiFor"},{"text":"private pure subroutine b64_decode_I4_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). Calls proc~~b64_decode_i4_a~2~~CallsGraph proc~b64_decode_i4_a~2 b64_decode_I4_a proc~decode_bits~2 decode_bits proc~b64_decode_i4_a~2->proc~decode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i4_a~2~~CalledByGraph proc~b64_decode_i4_a~2 b64_decode_I4_a proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_i4_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 interface~b64_decode~2 b64_decode interface~b64_decode~2->proc~b64_decode_i4_a~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I4_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I4P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I4_a","tags":"","loc":"proc/b64_decode_i4_a~2.html","title":"b64_decode_I4_a – StringiFor"},{"text":"private pure subroutine b64_decode_I2_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). Calls proc~~b64_decode_i2_a~2~~CallsGraph proc~b64_decode_i2_a~2 b64_decode_I2_a proc~decode_bits~2 decode_bits proc~b64_decode_i2_a~2->proc~decode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i2_a~2~~CalledByGraph proc~b64_decode_i2_a~2 b64_decode_I2_a proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_i2_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 interface~b64_decode~2 b64_decode interface~b64_decode~2->proc~b64_decode_i2_a~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I2_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I2P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I2P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I2_a","tags":"","loc":"proc/b64_decode_i2_a~2.html","title":"b64_decode_I2_a – StringiFor"},{"text":"private pure subroutine b64_decode_I1_a(code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). Calls proc~~b64_decode_i1_a~2~~CallsGraph proc~b64_decode_i1_a~2 b64_decode_I1_a proc~decode_bits~2 decode_bits proc~b64_decode_i1_a~2->proc~decode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i1_a~2~~CalledByGraph proc~b64_decode_i1_a~2 b64_decode_I1_a proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_i1_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 interface~b64_decode~2 b64_decode interface~b64_decode~2->proc~b64_decode_i1_a~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_I1_a ( code , n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array numbers (I1P). !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded array. integer ( I1P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_I1_a","tags":"","loc":"proc/b64_decode_i1_a~2.html","title":"b64_decode_I1_a – StringiFor"},{"text":"private pure subroutine b64_decode_string_a(code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings. Calls proc~~b64_decode_string_a~2~~CallsGraph proc~b64_decode_string_a~2 b64_decode_string_a interface~byte_size byte_size proc~b64_decode_string_a~2->interface~byte_size proc~decode_bits~2 decode_bits proc~b64_decode_string_a~2->proc~decode_bits~2 proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_string_a~2~~CalledByGraph proc~b64_decode_string_a~2 b64_decode_string_a proc~b64_decode_up_a~2 b64_decode_up_a proc~b64_decode_up_a~2->proc~b64_decode_string_a~2 interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->proc~b64_decode_up_a~2 interface~b64_decode_up~2->interface~b64_decode_up~2 interface~b64_decode~2 b64_decode interface~b64_decode~2->proc~b64_decode_string_a~2 proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, allocatable :: nI1P (:) One byte integer array containing n. Source Code pure subroutine b64_decode_string_a ( code , s ) !--------------------------------------------------------------------------------------------------------------------------------- !< Decode a base64 code into an array of strings. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s ( 1 :) !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- allocate ( nI1P ( 1 : byte_size ( s ( 1 )) * size ( s , dim = 1 ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine b64_decode_string_a","tags":"","loc":"proc/b64_decode_string_a~2.html","title":"b64_decode_string_a – StringiFor"},{"text":"public subroutine autotest() Arguments None Description Procedure for autotesting the library functionalities. Note Into the src directory there is a small python script ( validation.py ) that can be used to validate the library\n correctness by a comparison with other widely used tools such as the python builtin module struct . Calls proc~~autotest~2~~CallsGraph proc~autotest~2 autotest interface~b64_decode~2 b64_decode proc~autotest~2->interface~b64_decode~2 proc~b64_init~2 b64_init proc~autotest~2->proc~b64_init~2 interface~str str proc~autotest~2->interface~str interface~b64_encode~2 b64_encode proc~autotest~2->interface~b64_encode~2 proc~b64_decode_i8~2 b64_decode_I8 interface~b64_decode~2->proc~b64_decode_i8~2 proc~b64_decode_i8_a~2 b64_decode_I8_a interface~b64_decode~2->proc~b64_decode_i8_a~2 proc~b64_decode_string_a~2 b64_decode_string_a interface~b64_decode~2->proc~b64_decode_string_a~2 proc~b64_decode_i2~2 b64_decode_I2 interface~b64_decode~2->proc~b64_decode_i2~2 proc~b64_decode_i4~2 b64_decode_I4 interface~b64_decode~2->proc~b64_decode_i4~2 proc~b64_decode_string~2 b64_decode_string interface~b64_decode~2->proc~b64_decode_string~2 proc~b64_decode_i4_a~2 b64_decode_I4_a interface~b64_decode~2->proc~b64_decode_i4_a~2 proc~b64_decode_i1_a~2 b64_decode_I1_a interface~b64_decode~2->proc~b64_decode_i1_a~2 proc~b64_decode_r8~2 b64_decode_R8 interface~b64_decode~2->proc~b64_decode_r8~2 proc~b64_decode_r8_a~2 b64_decode_R8_a interface~b64_decode~2->proc~b64_decode_r8_a~2 proc~b64_decode_i1~2 b64_decode_I1 interface~b64_decode~2->proc~b64_decode_i1~2 proc~b64_decode_r4~2 b64_decode_R4 interface~b64_decode~2->proc~b64_decode_r4~2 proc~b64_decode_r4_a~2 b64_decode_R4_a interface~b64_decode~2->proc~b64_decode_r4_a~2 proc~b64_decode_i2_a~2 b64_decode_I2_a interface~b64_decode~2->proc~b64_decode_i2_a~2 proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~b64_encode_string_a~2 b64_encode_string_a interface~b64_encode~2->proc~b64_encode_string_a~2 proc~b64_encode_i4~2 b64_encode_I4 interface~b64_encode~2->proc~b64_encode_i4~2 proc~b64_encode_i1~2 b64_encode_I1 interface~b64_encode~2->proc~b64_encode_i1~2 proc~b64_encode_i4_a~2 b64_encode_I4_a interface~b64_encode~2->proc~b64_encode_i4_a~2 proc~b64_encode_r8~2 b64_encode_R8 interface~b64_encode~2->proc~b64_encode_r8~2 proc~b64_encode_i8_a~2 b64_encode_I8_a interface~b64_encode~2->proc~b64_encode_i8_a~2 proc~b64_encode_i1_a~2 b64_encode_I1_a interface~b64_encode~2->proc~b64_encode_i1_a~2 proc~b64_encode_r4_a~2 b64_encode_R4_a interface~b64_encode~2->proc~b64_encode_r4_a~2 proc~b64_encode_string~2 b64_encode_string interface~b64_encode~2->proc~b64_encode_string~2 proc~b64_encode_i2~2 b64_encode_I2 interface~b64_encode~2->proc~b64_encode_i2~2 proc~b64_encode_r8_a~2 b64_encode_R8_a interface~b64_encode~2->proc~b64_encode_r8_a~2 proc~b64_encode_i2_a~2 b64_encode_I2_a interface~b64_encode~2->proc~b64_encode_i2_a~2 proc~b64_encode_i8~2 b64_encode_I8 interface~b64_encode~2->proc~b64_encode_i8~2 proc~b64_encode_r4~2 b64_encode_R4 interface~b64_encode~2->proc~b64_encode_r4~2 proc~decode_bits~2 decode_bits proc~b64_decode_i8~2->proc~decode_bits~2 proc~b64_decode_i8_a~2->proc~decode_bits~2 proc~b64_decode_string_a~2->proc~decode_bits~2 interface~byte_size byte_size proc~b64_decode_string_a~2->interface~byte_size proc~b64_decode_i2~2->proc~decode_bits~2 proc~b64_decode_i4~2->proc~decode_bits~2 proc~b64_decode_string~2->proc~decode_bits~2 proc~b64_decode_string~2->interface~byte_size proc~b64_decode_i4_a~2->proc~decode_bits~2 proc~b64_decode_i1_a~2->proc~decode_bits~2 proc~b64_decode_r8~2->proc~decode_bits~2 proc~b64_decode_r8_a~2->proc~decode_bits~2 proc~b64_decode_i1~2->proc~decode_bits~2 proc~b64_decode_r4~2->proc~decode_bits~2 proc~b64_decode_r4_a~2->proc~decode_bits~2 proc~b64_decode_i2_a~2->proc~decode_bits~2 proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~b64_encode_string_a~2->interface~byte_size proc~encode_bits~2 encode_bits proc~b64_encode_string_a~2->proc~encode_bits~2 proc~b64_encode_i4~2->proc~encode_bits~2 proc~b64_encode_i1~2->proc~encode_bits~2 proc~b64_encode_i4_a~2->proc~encode_bits~2 proc~b64_encode_r8~2->proc~encode_bits~2 proc~b64_encode_i8_a~2->proc~encode_bits~2 proc~b64_encode_i1_a~2->proc~encode_bits~2 proc~b64_encode_r4_a~2->proc~encode_bits~2 proc~b64_encode_string~2->interface~byte_size proc~b64_encode_string~2->proc~encode_bits~2 proc~b64_encode_i2~2->proc~encode_bits~2 proc~b64_encode_r8_a~2->proc~encode_bits~2 proc~b64_encode_i2_a~2->proc~encode_bits~2 proc~b64_encode_i8~2->proc~encode_bits~2 proc~b64_encode_r4~2->proc~encode_bits~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: code64 Base64 code. logical, public :: ok Flag for checking the result of encoding/decoding. real(kind=R8P), public :: scalar_R8 Decoded scalar. real(kind=R4P), public :: scalar_R4 Decoded scalar. integer(kind=I8P), public :: scalar_I8 Decoded scalar. integer(kind=I4P), public :: scalar_I4 Decoded scalar. integer(kind=I2P), public :: scalar_I2 Decoded scalar. integer(kind=I1P), public :: scalar_I1 Decoded scalar. real(kind=R8P), public :: array_R8 (1:2) Decoded array. real(kind=R4P), public :: array_R4 (1:2) Decoded array. integer(kind=I8P), public :: array_I8 (1:4) Decoded array. integer(kind=I4P), public :: array_I4 (1:2) Decoded array. integer(kind=I2P), public :: array_I2 (1:2) Decoded array. integer(kind=I1P), public :: array_I1 (1:2) Decoded array. character(len=5), public :: array_s (1:2) Decoded array. Source Code subroutine autotest () !--------------------------------------------------------------------------------------------------------------------------------- !< Procedure for autotesting the library functionalities. !< !< @note Into the *src* directory there is a small python script (*validation.py*) that can be used to validate the library !< correctness by a comparison with other widely used tools such as the python builtin module *struct*. !--------------------------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable :: code64 !< Base64 code. logical :: ok !< Flag for checking the result of encoding/decoding. #ifdef r16p real ( R16P ) :: scalar_R16 !< Decoded scalar. #endif real ( R8P ) :: scalar_R8 !< Decoded scalar. real ( R4P ) :: scalar_R4 !< Decoded scalar. integer ( I8P ) :: scalar_I8 !< Decoded scalar. integer ( I4P ) :: scalar_I4 !< Decoded scalar. integer ( I2P ) :: scalar_I2 !< Decoded scalar. integer ( I1P ) :: scalar_I1 !< Decoded scalar. real ( R8P ) :: array_R8 ( 1 : 2 ) !< Decoded array. real ( R4P ) :: array_R4 ( 1 : 2 ) !< Decoded array. integer ( I8P ) :: array_I8 ( 1 : 4 ) !< Decoded array. integer ( I4P ) :: array_I4 ( 1 : 2 ) !< Decoded array. integer ( I2P ) :: array_I2 ( 1 : 2 ) !< Decoded array. integer ( I1P ) :: array_I1 ( 1 : 2 ) !< Decoded array. character ( 5 ) :: array_s ( 1 : 2 ) !< Decoded array. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call b64_Init print \"(A)\" , 'Encoders' print \"(A)\" , 'Scalars' #ifdef r16p call b64_encode ( n = 13 4.231_R16P , code = code64 ) ok = code64 == 'CKwcWmTHYEA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 13 4.231_R16P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'CKwcWmTHYEA=' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = 1._R8P , code = code64 ) ok = code64 == 'AAAAAAAA8D8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 1._R8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 0._R4P , code = code64 ) ok = code64 == 'AAAAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 0._R4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 23_I8P , code = code64 ) ok = code64 == 'FwAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 23_I8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 2023_I4P , code = code64 ) ok = code64 == '5wcAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 2023_I4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n =- 203_I2P , code = code64 ) ok = code64 == 'Nf8=' print \"(A)\" , '+ Code of ' // trim ( str ( n =- 203_I2P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 120_I1P , code = code64 ) ok = code64 == 'eA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 120_I1P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = 'hello' , code = code64 ) ok = code64 == 'aGVsbG8=' print \"(A)\" , '+ Code of hello: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG8=' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' #ifdef r16p call b64_encode ( n = [ 12 1._R16P , 2.32_R16P ], code = code64 ) ok = code64 == 'AAAAAABAXkCPwvUoXI8CQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 12 1._R16P , 2.32_R16P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAABAXkCPwvUoXI8CQA==' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = [ 1._R8P , 2._R8P ], code = code64 ) ok = code64 == 'AAAAAAAA8D8AAAAAAAAAQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8AAAAAAAAAQA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 0._R4P , - 3 2.12_R4P ], code = code64 ) ok = code64 == 'AAAAAOF6AMI=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAOF6AMI=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], code = code64 ) ok = code64 == 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 2023_I4P , - 24_I4P ], code = code64 ) ok = code64 == '5wcAAOj///8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAOj///8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ - 203_I2P , - 10_I2P ], code = code64 ) ok = code64 == 'Nf/2/w==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf/2/w==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 120_I1P , - 1_I1P ], code = code64 ) ok = code64 == 'eP8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eP8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = [ 'hello' , 'world' ], code = code64 ) ok = code64 == 'aGVsbG93b3JsZA==' print \"(A)\" , '+ Code of [hello,world]: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG93b3JsZA==' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Decoders' print \"(A)\" , 'Scalars' call b64_decode ( code = 'AAAAAAAA8D8=' , n = scalar_R8 ) ok = str ( n = scalar_R8 ) == str ( n = 1._R8P ) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8=' // ': \"' // trim ( str ( n = scalar_R8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 1._R8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAA==' , n = scalar_R4 ) ok = str ( n = scalar_R4 ) == str ( n = 0._R4P ) print \"(A)\" , '+ Decode of ' // 'AAAAAA==' // ': \"' // trim ( str ( n = scalar_R4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 0._R4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'FwAAAAAAAAA=' , n = scalar_I8 ) ok = str ( n = scalar_I8 ) == str ( n = 23_I8P ) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAAA=' // ': \"' // trim ( str ( n = scalar_I8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 23_I8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAA==' , n = scalar_I4 ) ok = str ( n = scalar_I4 ) == str ( n = 2023_I4P ) print \"(A)\" , '+ Decode of ' // '5wcAAA==' // ': \"' // trim ( str ( n = scalar_I4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 2023_I4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf8=' , n = scalar_I2 ) ok = str ( n = scalar_I2 ) == str ( n =- 203_I2P ) print \"(A)\" , '+ Decode of ' // 'Nf8=' // ': \"' // trim ( str ( n = scalar_I2 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n =- 203_I2P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eA==' , n = scalar_I1 ) ok = str ( n = scalar_I1 ) == str ( n = 120_I1P ) print \"(A)\" , '+ Decode of ' // 'eA==' // ': \"' // trim ( str ( n = scalar_I1 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 120_I1P )) // '\", Is it correct?' , ok if (. not . ok ) stop code64 = repeat ( ' ' , 5 ) call b64_decode ( code = 'aGVsbG8=' , s = code64 ) ok = 'hello' == code64 print \"(A)\" , '+ Decode of ' // 'aGVsbG8=' // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected value: \"hello\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' call b64_decode ( code = 'AAAAAAAA8D8AAAAAAAAAQA==' , n = array_R8 ) ok = str ( n = array_R8 ) == str ( n = [ 1._R8P , 2._R8P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8AAAAAAAAAQA==' // ': \"' // trim ( str ( n = array_R8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAOF6AMI=' , n = array_R4 ) ok = str ( n = array_R4 ) == str ( n = [ 0._R4P , - 3 2.12_R4P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAOF6AMI=' // ': \"' // trim ( str ( n = array_R4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop ! ok = test_decode_array(code=, input=) ; if (.not.ok) stop call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = array_I8 ) ok = str ( n = array_I8 ) == str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ]) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // ': \"' // & trim ( str ( n = array_I8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // & '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAOj///8=' , n = array_I4 ) ok = str ( n = array_I4 ) == str ( n = [ 2023_I4P , - 24_I4P ]) print \"(A)\" , '+ Decode of ' // '5wcAAOj///8=' // ': \"' // trim ( str ( n = array_I4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf/2/w==' , n = array_I2 ) ok = str ( n = array_I2 ) == str ( n = [ - 203_I2P , - 10_I2P ]) print \"(A)\" , '+ Decode of ' // 'Nf/2/w==' // ': \"' // trim ( str ( n = array_I2 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eP8=' , n = array_I1 ) ok = str ( n = array_I1 ) == str ( n = [ 120_I1P , - 1_I1P ]) print \"(A)\" , '+ Decode of ' // 'eP8=' // ': \"' // trim ( str ( n = array_I1 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'aGVsbG93b3JsZA==' , s = array_s ) ok = array_s ( 1 ) // array_s ( 2 ) == 'helloworld' print \"(A)\" , '+ Decode of ' // 'aGVsbG93b3JsZA==' // ': \"' // array_s ( 1 ) // array_s ( 2 ) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"helloworld\", Is it correct?' , ok if (. not . ok ) stop return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine autotest","tags":"","loc":"proc/autotest~2.html","title":"autotest – StringiFor"},{"text":"public interface b64_encode Encode numbers (integer and real) to base64. This is an interface for encoding integer and real numbers of any kinds into a base64 string. This interface can encode both\n scalar and array. Warning The encoded string is returned as varying length character string, character(len=:), allocatable:: string , thus the\n compiler must support such a Fortran (2003) feature. Note Before start to encode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = 1 2._R8P , code = code64 ) Array encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = [ 12_I4P , 1_I4P ], code = code64 ) Note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The encoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_encode~2~~CallsGraph interface~b64_encode~2 b64_encode proc~b64_encode_string_a~2 b64_encode_string_a interface~b64_encode~2->proc~b64_encode_string_a~2 proc~b64_encode_i4~2 b64_encode_I4 interface~b64_encode~2->proc~b64_encode_i4~2 proc~b64_encode_i1~2 b64_encode_I1 interface~b64_encode~2->proc~b64_encode_i1~2 proc~b64_encode_i4_a~2 b64_encode_I4_a interface~b64_encode~2->proc~b64_encode_i4_a~2 proc~b64_encode_r8~2 b64_encode_R8 interface~b64_encode~2->proc~b64_encode_r8~2 proc~b64_encode_i8_a~2 b64_encode_I8_a interface~b64_encode~2->proc~b64_encode_i8_a~2 proc~b64_encode_i1_a~2 b64_encode_I1_a interface~b64_encode~2->proc~b64_encode_i1_a~2 proc~b64_encode_r4_a~2 b64_encode_R4_a interface~b64_encode~2->proc~b64_encode_r4_a~2 proc~b64_encode_string~2 b64_encode_string interface~b64_encode~2->proc~b64_encode_string~2 proc~b64_encode_i2~2 b64_encode_I2 interface~b64_encode~2->proc~b64_encode_i2~2 proc~b64_encode_r8_a~2 b64_encode_R8_a interface~b64_encode~2->proc~b64_encode_r8_a~2 proc~b64_encode_i2_a~2 b64_encode_I2_a interface~b64_encode~2->proc~b64_encode_i2_a~2 proc~b64_encode_i8~2 b64_encode_I8 interface~b64_encode~2->proc~b64_encode_i8~2 proc~b64_encode_r4~2 b64_encode_R4 interface~b64_encode~2->proc~b64_encode_r4~2 interface~byte_size byte_size proc~b64_encode_string_a~2->interface~byte_size proc~encode_bits~2 encode_bits proc~b64_encode_string_a~2->proc~encode_bits~2 proc~b64_encode_i4~2->proc~encode_bits~2 proc~b64_encode_i1~2->proc~encode_bits~2 proc~b64_encode_i4_a~2->proc~encode_bits~2 proc~b64_encode_r8~2->proc~encode_bits~2 proc~b64_encode_i8_a~2->proc~encode_bits~2 proc~b64_encode_i1_a~2->proc~encode_bits~2 proc~b64_encode_r4_a~2->proc~encode_bits~2 proc~b64_encode_string~2->interface~byte_size proc~b64_encode_string~2->proc~encode_bits~2 proc~b64_encode_i2~2->proc~encode_bits~2 proc~b64_encode_r8_a~2->proc~encode_bits~2 proc~b64_encode_i2_a~2->proc~encode_bits~2 proc~b64_encode_i8~2->proc~encode_bits~2 proc~b64_encode_r4~2->proc~encode_bits~2 proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~b64_encode~2~~CalledByGraph interface~b64_encode~2 b64_encode proc~autotest~2 autotest proc~autotest~2->interface~b64_encode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine b64_encode_R8 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). private pure subroutine b64_encode_R8_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). private pure subroutine b64_encode_R4 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). private pure subroutine b64_encode_R4_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). private pure subroutine b64_encode_I8 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). private pure subroutine b64_encode_I8_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). private pure subroutine b64_encode_I4 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). private pure subroutine b64_encode_I4_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). private pure subroutine b64_encode_I2 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). private pure subroutine b64_encode_I2_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). private pure subroutine b64_encode_I1 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). private pure subroutine b64_encode_I1_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). private pure subroutine b64_encode_string (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. private pure subroutine b64_encode_string_a (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64.","tags":"","loc":"interface/b64_encode~2.html","title":"b64_encode – StringiFor"},{"text":"public interface b64_encode_up Encode unlimited polymorphic variable to base64. This is an interface for encoding both scalar and array. Warning The encoded string is returned as varying length character string, character(len=:), allocatable:: string , thus the\n compiler must support such a Fortran (2003) feature. Note Before start to encode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode_up ( up = 1 2._R8P , code = code64 ) Array encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode_up ( up = [ 12_I4P , 1_I4P ], code = code64 ) Note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The encoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_encode_up~2~~CallsGraph interface~b64_encode_up~2 b64_encode_up interface~b64_encode_up~2->interface~b64_encode_up~2 proc~b64_encode_up_a~2 b64_encode_up_a interface~b64_encode_up~2->proc~b64_encode_up_a~2 proc~b64_encode_string_a~2 b64_encode_string_a proc~b64_encode_up_a~2->proc~b64_encode_string_a~2 proc~b64_encode_i4_a~2 b64_encode_I4_a proc~b64_encode_up_a~2->proc~b64_encode_i4_a~2 proc~b64_encode_i2_a~2 b64_encode_I2_a proc~b64_encode_up_a~2->proc~b64_encode_i2_a~2 proc~b64_encode_r8_a~2 b64_encode_R8_a proc~b64_encode_up_a~2->proc~b64_encode_r8_a~2 proc~b64_encode_i1_a~2 b64_encode_I1_a proc~b64_encode_up_a~2->proc~b64_encode_i1_a~2 proc~b64_encode_i8_a~2 b64_encode_I8_a proc~b64_encode_up_a~2->proc~b64_encode_i8_a~2 proc~b64_encode_r4_a~2 b64_encode_R4_a proc~b64_encode_up_a~2->proc~b64_encode_r4_a~2 interface~byte_size byte_size proc~b64_encode_string_a~2->interface~byte_size proc~encode_bits~2 encode_bits proc~b64_encode_string_a~2->proc~encode_bits~2 proc~b64_encode_i4_a~2->proc~encode_bits~2 proc~b64_encode_i2_a~2->proc~encode_bits~2 proc~b64_encode_r8_a~2->proc~encode_bits~2 proc~b64_encode_i1_a~2->proc~encode_bits~2 proc~b64_encode_i8_a~2->proc~encode_bits~2 proc~b64_encode_r4_a~2->proc~encode_bits~2 proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public interface b64_encode_up () Arguments None Description Encode unlimited polymorphic variable to base64. private pure subroutine b64_encode_up_a (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64.","tags":"","loc":"interface/b64_encode_up~2.html","title":"b64_encode_up – StringiFor"},{"text":"public interface b64_decode Decode numbers (integer and real) from base64. This is an interface for decoding integer and real numbers of any kinds from a base64 string. This interface can decode both\n scalar and array. Note Before start to decode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar decoding real ( R8P ) :: decoded ! scalar to be decoded ... call b64_decode ( code = 'AAAAAAAA8D8=' , n = decoded ) Array decoding integer ( I8P ) :: decoded ( 1 : 4 ) ! array to be decoded ... call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = decoded ) Note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The decoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_decode~2~~CallsGraph interface~b64_decode~2 b64_decode proc~b64_decode_i8~2 b64_decode_I8 interface~b64_decode~2->proc~b64_decode_i8~2 proc~b64_decode_i8_a~2 b64_decode_I8_a interface~b64_decode~2->proc~b64_decode_i8_a~2 proc~b64_decode_string_a~2 b64_decode_string_a interface~b64_decode~2->proc~b64_decode_string_a~2 proc~b64_decode_i2~2 b64_decode_I2 interface~b64_decode~2->proc~b64_decode_i2~2 proc~b64_decode_i4~2 b64_decode_I4 interface~b64_decode~2->proc~b64_decode_i4~2 proc~b64_decode_string~2 b64_decode_string interface~b64_decode~2->proc~b64_decode_string~2 proc~b64_decode_i4_a~2 b64_decode_I4_a interface~b64_decode~2->proc~b64_decode_i4_a~2 proc~b64_decode_i1_a~2 b64_decode_I1_a interface~b64_decode~2->proc~b64_decode_i1_a~2 proc~b64_decode_r8~2 b64_decode_R8 interface~b64_decode~2->proc~b64_decode_r8~2 proc~b64_decode_r8_a~2 b64_decode_R8_a interface~b64_decode~2->proc~b64_decode_r8_a~2 proc~b64_decode_i1~2 b64_decode_I1 interface~b64_decode~2->proc~b64_decode_i1~2 proc~b64_decode_r4~2 b64_decode_R4 interface~b64_decode~2->proc~b64_decode_r4~2 proc~b64_decode_r4_a~2 b64_decode_R4_a interface~b64_decode~2->proc~b64_decode_r4_a~2 proc~b64_decode_i2_a~2 b64_decode_I2_a interface~b64_decode~2->proc~b64_decode_i2_a~2 proc~decode_bits~2 decode_bits proc~b64_decode_i8~2->proc~decode_bits~2 proc~b64_decode_i8_a~2->proc~decode_bits~2 proc~b64_decode_string_a~2->proc~decode_bits~2 interface~byte_size byte_size proc~b64_decode_string_a~2->interface~byte_size proc~b64_decode_i2~2->proc~decode_bits~2 proc~b64_decode_i4~2->proc~decode_bits~2 proc~b64_decode_string~2->proc~decode_bits~2 proc~b64_decode_string~2->interface~byte_size proc~b64_decode_i4_a~2->proc~decode_bits~2 proc~b64_decode_i1_a~2->proc~decode_bits~2 proc~b64_decode_r8~2->proc~decode_bits~2 proc~b64_decode_r8_a~2->proc~decode_bits~2 proc~b64_decode_i1~2->proc~decode_bits~2 proc~b64_decode_r4~2->proc~decode_bits~2 proc~b64_decode_r4_a~2->proc~decode_bits~2 proc~b64_decode_i2_a~2->proc~decode_bits~2 proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~b64_decode~2~~CalledByGraph interface~b64_decode~2 b64_decode proc~autotest~2 autotest proc~autotest~2->interface~b64_decode~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private elemental subroutine b64_decode_R8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). private pure subroutine b64_decode_R8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). private elemental subroutine b64_decode_R4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). private pure subroutine b64_decode_R4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). private elemental subroutine b64_decode_I8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). private pure subroutine b64_decode_I8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). private elemental subroutine b64_decode_I4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). private pure subroutine b64_decode_I4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). private elemental subroutine b64_decode_I2 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). private pure subroutine b64_decode_I2_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). private elemental subroutine b64_decode_I1 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). private pure subroutine b64_decode_I1_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). private elemental subroutine b64_decode_string (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. private pure subroutine b64_decode_string_a (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings.","tags":"","loc":"interface/b64_decode~2.html","title":"b64_decode – StringiFor"},{"text":"public interface b64_decode_up Decode unlimited polymorphic variable from base64. This is an interface for decoding both scalar and array. Note Before start to decode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar decoding real ( R8P ) :: decoded ! scalar to be decoded ... call b64_decode_up ( code = 'AAAAAAAA8D8=' , up = decoded ) Array decoding integer ( I8P ) :: decoded ( 1 : 4 ) ! array to be decoded ... call b64_decode_up ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , up = decoded ) Note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The decoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_decode_up~2~~CallsGraph interface~b64_decode_up~2 b64_decode_up interface~b64_decode_up~2->interface~b64_decode_up~2 proc~b64_decode_up_a~2 b64_decode_up_a interface~b64_decode_up~2->proc~b64_decode_up_a~2 proc~b64_decode_i8_a~2 b64_decode_I8_a proc~b64_decode_up_a~2->proc~b64_decode_i8_a~2 proc~b64_decode_string_a~2 b64_decode_string_a proc~b64_decode_up_a~2->proc~b64_decode_string_a~2 proc~b64_decode_i4_a~2 b64_decode_I4_a proc~b64_decode_up_a~2->proc~b64_decode_i4_a~2 proc~b64_decode_r4_a~2 b64_decode_R4_a proc~b64_decode_up_a~2->proc~b64_decode_r4_a~2 proc~b64_decode_r8_a~2 b64_decode_R8_a proc~b64_decode_up_a~2->proc~b64_decode_r8_a~2 proc~b64_decode_i1_a~2 b64_decode_I1_a proc~b64_decode_up_a~2->proc~b64_decode_i1_a~2 proc~b64_decode_i2_a~2 b64_decode_I2_a proc~b64_decode_up_a~2->proc~b64_decode_i2_a~2 proc~decode_bits~2 decode_bits proc~b64_decode_i8_a~2->proc~decode_bits~2 proc~b64_decode_string_a~2->proc~decode_bits~2 interface~byte_size byte_size proc~b64_decode_string_a~2->interface~byte_size proc~b64_decode_i4_a~2->proc~decode_bits~2 proc~b64_decode_r4_a~2->proc~decode_bits~2 proc~b64_decode_r8_a~2->proc~decode_bits~2 proc~b64_decode_i1_a~2->proc~decode_bits~2 proc~b64_decode_i2_a~2->proc~decode_bits~2 proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures public interface b64_decode_up () Arguments None Description Decode unlimited polymorphic variable from base64. private subroutine b64_decode_up_a (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64.","tags":"","loc":"interface/b64_decode_up~2.html","title":"b64_decode_up – StringiFor"},{"text":"private elemental function sadjustl(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. Source Code elemental function sadjustl ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl","tags":"","loc":"proc/sadjustl.html","title":"sadjustl – StringiFor"},{"text":"public pure function sadjustl_character(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Left adjust a string by removing leading spaces (character output). Called By proc~~sadjustl_character~~CalledByGraph proc~sadjustl_character sadjustl_character interface~adjustl adjustl interface~adjustl->proc~sadjustl_character Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function sadjustl_character ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces (character output). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = len ( self % raw )) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) adjusted = adjustl ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl_character","tags":"","loc":"proc/sadjustl_character.html","title":"sadjustl_character – StringiFor"},{"text":"private elemental function sadjustr(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. Source Code elemental function sadjustr ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr","tags":"","loc":"proc/sadjustr.html","title":"sadjustr – StringiFor"},{"text":"public pure function sadjustr_character(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Right adjust a string by removing leading spaces (character output). Called By proc~~sadjustr_character~~CalledByGraph proc~sadjustr_character sadjustr_character interface~adjustr adjustr interface~adjustr->proc~sadjustr_character Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function sadjustr_character ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces (character output). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = len ( self % raw )) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) adjusted = adjustr ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr_character","tags":"","loc":"proc/sadjustr_character.html","title":"sadjustr_character – StringiFor"},{"text":"private elemental function scount(self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore \"isolated\" occurrences. Return Value integer Number of occurrences. Description Count the number of occurences of a substring into a string. Note If ignore_isolated is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those\n occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a\n right companion). Variables Type Visibility Attributes Name Initial logical, public :: ignore_isolated_ Ignore \"isolated\" occurrences, local variable. integer, public :: c1 Counter. integer, public :: c2 Counter. Source Code elemental function scount ( self , substring , ignore_isolated ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !< !< @note If `ignore_isolated` is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those !< occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a !< right companion). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: substring !< Substring. logical , intent ( in ), optional :: ignore_isolated !< Ignore \"isolated\" occurrences. integer :: No !< Number of occurrences. logical :: ignore_isolated_ !< Ignore \"isolated\" occurrences, local variable. integer :: c1 !< Counter. integer :: c2 !< Counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( allocated ( self % raw )) then if ( len ( substring ) > len ( self % raw )) return ignore_isolated_ = . false . ; if ( present ( ignore_isolated )) ignore_isolated_ = ignore_isolated #ifdef __GFORTRAN__ temporary = self % raw #endif c1 = 1 do #ifdef __GFORTRAN__ c2 = index ( string = temporary ( c1 :), substring = substring ) #else c2 = index ( string = self % raw ( c1 :), substring = substring ) #endif if ( c2 == 0 ) return if (. not .( ignore_isolated_ . and .( c1 == 1. or . c1 + c2 - 1 == len ( self % raw ) - len ( substring ) + 1 ))) then No = No + 1 endif c1 = c1 + c2 - 1 + len ( substring ) enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction scount","tags":"","loc":"proc/scount.html","title":"scount – StringiFor"},{"text":"public elemental function sindex_string_string(self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Called By proc~~sindex_string_string~~CalledByGraph proc~sindex_string_string sindex_string_string interface~index index interface~index->proc~sindex_string_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sindex_string_string ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_string_string","tags":"","loc":"proc/sindex_string_string.html","title":"sindex_string_string – StringiFor"},{"text":"public elemental function sindex_string_character(self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Called By proc~~sindex_string_character~~CalledByGraph proc~sindex_string_character sindex_string_character interface~index index interface~index->proc~sindex_string_character Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sindex_string_character ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_string_character","tags":"","loc":"proc/sindex_string_character.html","title":"sindex_string_character – StringiFor"},{"text":"public elemental function sindex_character_string(string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Called By proc~~sindex_character_string~~CalledByGraph proc~sindex_character_string sindex_character_string interface~index index interface~index->proc~sindex_character_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sindex_character_string ( string_ , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: string_ !< The string. type ( string ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( substring % raw )) then i = index ( string = string_ , substring = substring % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex_character_string","tags":"","loc":"proc/sindex_character_string.html","title":"sindex_character_string – StringiFor"},{"text":"public elemental function slen(self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. Called By proc~~slen~~CalledByGraph proc~slen slen interface~len len interface~len->proc~slen Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function slen ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen","tags":"","loc":"proc/slen.html","title":"slen – StringiFor"},{"text":"public elemental function slen_trim(self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks. Called By proc~~slen_trim~~CalledByGraph proc~slen_trim slen_trim interface~len_trim len_trim interface~len_trim->proc~slen_trim Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function slen_trim ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string, ignoring any trailing blanks. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen_trim","tags":"","loc":"proc/slen_trim.html","title":"slen_trim – StringiFor"},{"text":"public elemental function srepeat_string_string(self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. Called By proc~~srepeat_string_string~~CalledByGraph proc~srepeat_string_string srepeat_string_string interface~repeat repeat interface~repeat->proc~srepeat_string_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function srepeat_string_string ( self , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenates several copies of an input string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = self % raw , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat_string_string","tags":"","loc":"proc/srepeat_string_string.html","title":"srepeat_string_string – StringiFor"},{"text":"private elemental function srepeat_character_string(self, rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. Source Code elemental function srepeat_character_string ( self , rstring , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenates several copies of an input string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< String to be repeated. character ( kind = CK , len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = rstring , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat_character_string","tags":"","loc":"proc/srepeat_character_string.html","title":"srepeat_character_string – StringiFor"},{"text":"public elemental function sscan_string_string(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Called By proc~~sscan_string_string~~CalledByGraph proc~sscan_string_string sscan_string_string interface~scan scan interface~scan->proc~sscan_string_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sscan_string_string ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw ). and . allocated ( set % raw )) then i = scan ( string = self % raw , set = set % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_string_string","tags":"","loc":"proc/sscan_string_string.html","title":"sscan_string_string – StringiFor"},{"text":"public elemental function sscan_string_character(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Called By proc~~sscan_string_character~~CalledByGraph proc~sscan_string_character sscan_string_character interface~scan scan interface~scan->proc~sscan_string_character Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sscan_string_character ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_string_character","tags":"","loc":"proc/sscan_string_character.html","title":"sscan_string_character – StringiFor"},{"text":"public elemental function sscan_character_string(sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Called By proc~~sscan_character_string~~CalledByGraph proc~sscan_character_string sscan_character_string interface~scan scan interface~scan->proc~sscan_character_string Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function sscan_character_string ( sstring , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: sstring !< The string. type ( string ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( set % raw )) then i = scan ( string = sstring , set = set % raw , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan_character_string","tags":"","loc":"proc/sscan_character_string.html","title":"sscan_character_string – StringiFor"},{"text":"public elemental function strim(self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. Called By proc~~strim~~CalledByGraph proc~strim strim interface~trim trim interface~trim->proc~strim Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function strim ( self ) result ( trimmed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Remove leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strim","tags":"","loc":"proc/strim.html","title":"strim – StringiFor"},{"text":"private elemental function sverify(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Source Code elemental function sverify ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sverify","tags":"","loc":"proc/sverify.html","title":"sverify – StringiFor"},{"text":"private elemental function basedir(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. Description Return the base directory name of a string containing a file name. Example type ( string ) :: astring astring = '/bar/foo.tar.bz2' print '(A)' , astring % basedir () // '' ! print \"/bar\" Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: pos Character position. Source Code elemental function basedir ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base directory name of a string containing a file name. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = '/bar/foo.tar.bz2' !< print '(A)', astring%basedir()//'' ! print \"/bar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. type ( string ) :: basedir !< Base directory name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basedir = self pos = index ( self % raw , sep_ , back = . true .) if ( pos > 0 ) basedir % raw = self % raw ( 1 : pos - 1 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basedir","tags":"","loc":"proc/basedir.html","title":"basedir – StringiFor"},{"text":"private elemental function basename(self, sep, extension, strip_last_extension) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. character(kind=CK,len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. Description Return the base file name of a string containing a file name. Optionally, the extension is also stripped if provided or the last one if required, e.g. Example type ( string ) :: astring astring = 'bar/foo.tar.bz2' print '(A)' , astring % basename ( extension = '.tar.bz2' ) // '' ! print \"foo\" print '(A)' , astring % basename ( strip_last_extension = . true .) // '' ! print \"foo.tar\" Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: pos Character position. Source Code elemental function basename ( self , sep , extension , strip_last_extension ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'bar/foo.tar.bz2' !< print '(A)', astring%basename(extension='.tar.bz2')//''        ! print \"foo\" !< print '(A)', astring%basename(strip_last_extension=.true.)//'' ! print \"foo.tar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , sep_ , back = . true .) if ( pos > 0 ) basename % raw = temporary ( pos + 1 :) #else pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) #endif if ( present ( extension )) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , extension , back = . true .) if ( pos > 0 ) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) #endif elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , '.' , back = . true .) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , '.' , back = . true .) basename % raw = basename % raw ( 1 : pos - 1 ) #endif endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basename","tags":"","loc":"proc/basename.html","title":"basename – StringiFor"},{"text":"private elemental function camelcase(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. Description Return a string with all words capitalized without spaces. Note Multiple subsequent separators are collapsed to one occurence. Example ```fortran\n type(string) :: astring\n astring = 'caMeL caSe var'\n print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" Variables Type Visibility Attributes Name Initial type( string ), public, allocatable :: tokens (:) String tokens. Source Code elemental function camelcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction camelcase","tags":"","loc":"proc/camelcase.html","title":"camelcase – StringiFor"},{"text":"private elemental function capitalize(self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with its first character capitalized and the rest lowercased. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function capitalize ( self ) result ( capitalized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with its first character capitalized and the rest lowercased. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction capitalize","tags":"","loc":"proc/capitalize.html","title":"capitalize – StringiFor"},{"text":"private pure function chars(self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data. Source Code pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars","tags":"","loc":"proc/chars.html","title":"chars – StringiFor"},{"text":"private elemental function decode(self, codec) result(decoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Decoded string. Description Return a string decoded accordingly the codec. Note Only BASE64 codec is currently available. Example ```fortran\n type(string) :: astring\n astring = 'SG93IGFyZSB5b3U/'\n print '(A)', astring%decode(codec='base64')//'' ! print \"How are you?\" Calls proc~~decode~~CallsGraph proc~decode decode interface~b64_decode b64_decode proc~decode->interface~b64_decode proc~b64_decode_i4_a b64_decode_I4_a interface~b64_decode->proc~b64_decode_i4_a proc~b64_decode_r8 b64_decode_R8 interface~b64_decode->proc~b64_decode_r8 proc~b64_decode_i1 b64_decode_I1 interface~b64_decode->proc~b64_decode_i1 proc~b64_decode_r8_a b64_decode_R8_a interface~b64_decode->proc~b64_decode_r8_a proc~b64_decode_r4 b64_decode_R4 interface~b64_decode->proc~b64_decode_r4 proc~b64_decode_i1_a b64_decode_I1_a interface~b64_decode->proc~b64_decode_i1_a proc~b64_decode_string_a b64_decode_string_a interface~b64_decode->proc~b64_decode_string_a proc~b64_decode_r4_a b64_decode_R4_a interface~b64_decode->proc~b64_decode_r4_a proc~b64_decode_i8 b64_decode_I8 interface~b64_decode->proc~b64_decode_i8 proc~b64_decode_i2 b64_decode_I2 interface~b64_decode->proc~b64_decode_i2 proc~b64_decode_i8_a b64_decode_I8_a interface~b64_decode->proc~b64_decode_i8_a proc~b64_decode_string b64_decode_string interface~b64_decode->proc~b64_decode_string proc~b64_decode_i4 b64_decode_I4 interface~b64_decode->proc~b64_decode_i4 proc~b64_decode_i2_a b64_decode_I2_a interface~b64_decode->proc~b64_decode_i2_a proc~decode_bits decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_i1->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string_a->interface~byte_size proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_i8->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_string->proc~decode_bits proc~b64_decode_string->interface~byte_size proc~b64_decode_i4->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( string ), public :: codec_u Encoding codec in upper case string. Source Code elemental function decode ( self , codec ) result ( decoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(A)', astring%decode(codec='base64')//'' ! print \"How are you?\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction decode","tags":"","loc":"proc/decode.html","title":"decode – StringiFor"},{"text":"private elemental function encode(self, codec) result(encoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Encoded string. Description Return a string encoded accordingly the codec. Note Only BASE64 codec is currently available. Example ```fortran\n type(string) :: astring\n astring = 'How are you?'\n print '(A)', astring%encode(codec='base64')//'' ! print \"SG93IGFyZSB5b3U/\" Calls proc~~encode~~CallsGraph proc~encode encode interface~b64_encode b64_encode proc~encode->interface~b64_encode proc~b64_encode_r8 b64_encode_R8 interface~b64_encode->proc~b64_encode_r8 proc~b64_encode_i1 b64_encode_I1 interface~b64_encode->proc~b64_encode_i1 proc~b64_encode_i4_a b64_encode_I4_a interface~b64_encode->proc~b64_encode_i4_a proc~b64_encode_i1_a b64_encode_I1_a interface~b64_encode->proc~b64_encode_i1_a proc~b64_encode_string b64_encode_string interface~b64_encode->proc~b64_encode_string proc~b64_encode_r4_a b64_encode_R4_a interface~b64_encode->proc~b64_encode_r4_a proc~b64_encode_r4 b64_encode_R4 interface~b64_encode->proc~b64_encode_r4 proc~b64_encode_string_a b64_encode_string_a interface~b64_encode->proc~b64_encode_string_a proc~b64_encode_i8 b64_encode_I8 interface~b64_encode->proc~b64_encode_i8 proc~b64_encode_i2 b64_encode_I2 interface~b64_encode->proc~b64_encode_i2 proc~b64_encode_r8_a b64_encode_R8_a interface~b64_encode->proc~b64_encode_r8_a proc~b64_encode_i2_a b64_encode_I2_a interface~b64_encode->proc~b64_encode_i2_a proc~b64_encode_i4 b64_encode_I4 interface~b64_encode->proc~b64_encode_i4 proc~b64_encode_i8_a b64_encode_I8_a interface~b64_encode->proc~b64_encode_i8_a proc~encode_bits encode_bits proc~b64_encode_r8->proc~encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_string->proc~encode_bits interface~byte_size byte_size proc~b64_encode_string->interface~byte_size proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_string_a->proc~encode_bits proc~b64_encode_string_a->interface~byte_size proc~b64_encode_i8->proc~encode_bits proc~b64_encode_i2->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i4->proc~encode_bits proc~b64_encode_i8_a->proc~encode_bits proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental function encode ( self , codec ) result ( encoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(A)', astring%encode(codec='base64')//'' ! print \"SG93IGFyZSB5b3U/\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction encode","tags":"","loc":"proc/encode.html","title":"encode – StringiFor"},{"text":"private elemental function escape(self, to_escape, esc) result(escaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK,len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. Description Escape backslashes (or custom escape character). Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: esc_ Character to escape, local variable. integer, public :: c Character counter. Source Code elemental function escape ( self , to_escape , esc ) result ( escaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Escape backslashes (or custom escape character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction escape","tags":"","loc":"proc/escape.html","title":"escape – StringiFor"},{"text":"private elemental function extension(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. Description Return the extension of a string containing a file name. Variables Type Visibility Attributes Name Initial integer, public :: pos Character position. Source Code elemental function basename ( self , sep , extension , strip_last_extension ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the base file name of a string containing a file name. !< !< Optionally, the extension is also stripped if provided or the last one if required, e.g. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'bar/foo.tar.bz2' !< print '(A)', astring%basename(extension='.tar.bz2')//''        ! print \"foo\" !< print '(A)', astring%basename(strip_last_extension=.true.)//'' ! print \"foo.tar\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Directory separator. character ( kind = CK , len =* ), intent ( in ), optional :: extension !< File extension. logical , intent ( in ), optional :: strip_last_extension !< Flag to enable the stripping of last extension. type ( string ) :: basename !< Base file name. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = UIX_DIR_SEP ; if ( present ( sep )) sep_ = sep basename = self #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , sep_ , back = . true .) if ( pos > 0 ) basename % raw = temporary ( pos + 1 :) #else pos = index ( basename % raw , sep_ , back = . true .) if ( pos > 0 ) basename % raw = self % raw ( pos + 1 :) #endif if ( present ( extension )) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , extension , back = . true .) if ( pos > 0 ) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , extension , back = . true .) if ( pos > 0 ) basename % raw = basename % raw ( 1 : pos - 1 ) #endif elseif ( present ( strip_last_extension )) then if ( strip_last_extension ) then #ifdef __GFORTRAN__ temporary = basename % raw pos = index ( temporary , '.' , back = . true .) basename % raw = temporary ( 1 : pos - 1 ) #else pos = index ( basename % raw , '.' , back = . true .) basename % raw = basename % raw ( 1 : pos - 1 ) #endif endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction basename elemental function camelcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized without spaces. !< !< @note Multiple subsequent separators are collapsed to one occurence. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'caMeL caSe var' !< print '(A)', astring%camelcase()//'' ! print \"CamelCaseVar\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: camelcase !< Camel case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % capitalize () camelcase = camelcase % join ( array = tokens ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction camelcase elemental function capitalize ( self ) result ( capitalized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with its first character capitalized and the rest lowercased. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction capitalize pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars elemental function decode ( self , codec ) result ( decoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string decoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'SG93IGFyZSB5b3U/' !< print '(A)', astring%decode(codec='base64')//'' ! print \"How are you?\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: decoded !< Decoded string. type ( string ) :: codec_u !< Encoding codec in upper case string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then decoded = self codec_u = codec select case ( codec_u % upper () // '' ) case ( 'BASE64' ) call b64_decode ( code = self % raw , s = decoded % raw ) endselect decoded = decoded % strip ( remove_nulls = . true .) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction decode elemental function encode ( self , codec ) result ( encoded ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string encoded accordingly the codec. !< !< @note Only BASE64 codec is currently available. !< !<### Example !< !<```fortran !< type(string) :: astring !< astring = 'How are you?' !< print '(A)', astring%encode(codec='base64')//'' ! print \"SG93IGFyZSB5b3U/\" !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: codec !< Encoding codec. type ( string ) :: encoded !< Encoded string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then encoded = codec select case ( encoded % upper () // '' ) case ( 'BASE64' ) call b64_encode ( s = self % raw , code = encoded % raw ) endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction encode elemental function escape ( self , to_escape , esc ) result ( escaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Escape backslashes (or custom escape character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_escape !< Character to be escaped. character ( kind = CK , len =* ), intent ( in ), optional :: esc !< Character used to escape. type ( string ) :: escaped !< Escaped string. character ( kind = CK , len = :), allocatable :: esc_ !< Character to escape, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then esc_ = BACKSLASH ; if ( present ( esc )) esc_ = esc escaped % raw = '' do c = 1 , len ( self % raw ) if ( self % raw ( c : c ) == to_escape ) then escaped % raw = escaped % raw // esc_ // to_escape else escaped % raw = escaped % raw // self % raw ( c : c ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction escape elemental function extension ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the extension of a string containing a file name. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: extension !< Extension file name. integer :: pos !< Character position. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then extension = '' pos = index ( self % raw , '.' , back = . true .) #ifdef __GFORTRAN__ temporary = self % raw if ( pos > 0 ) extension % raw = temporary ( pos :) #else if ( pos > 0 ) extension % raw = self % raw ( pos :) #endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction extension","tags":"","loc":"proc/extension.html","title":"extension – StringiFor"},{"text":"private elemental function fill(self, width, right, filling_char) result(filled) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK,len=1), intent(in), optional :: filling_char Filling character (default \"0\"). Return Value type( string ) Filled string. Description Pad string on the left (or right) with zeros (or other char) to fill width. Variables Type Visibility Attributes Name Initial logical, public :: right_ Fill on the right instead of left, local variable. character(kind=CK,len=1), public :: filling_char_ Filling character (default \"0\"), local variable. Source Code elemental function fill ( self , width , right , filling_char ) result ( filled ) !--------------------------------------------------------------------------------------------------------------------------------- !< Pad string on the left (or right) with zeros (or other char) to fill width. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: width !< Final width of filled string. logical , intent ( in ), optional :: right !< Fill on the right instead of left. character ( kind = CK , len = 1 ), intent ( in ), optional :: filling_char !< Filling character (default \"0\"). type ( string ) :: filled !< Filled string. logical :: right_ !< Fill on the right instead of left, local variable. character ( kind = CK , len = 1 ) :: filling_char_ !< Filling character (default \"0\"), local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( width > len ( self % raw )) then right_ = . false . ; if ( present ( right )) right_ = right filling_char_ = '0' ; if ( present ( filling_char )) filling_char_ = filling_char if (. not . right_ ) then filled % raw = repeat ( filling_char_ , width - len ( self % raw )) // self % raw else filled % raw = self % raw // repeat ( filling_char_ , width - len ( self % raw )) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction fill","tags":"","loc":"proc/fill.html","title":"fill – StringiFor"},{"text":"private elemental function insert_character(self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. Variables Type Visibility Attributes Name Initial integer, public :: safepos Safe position from which insert substring. Source Code elemental function insert_character ( self , substring , pos ) result ( inserted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Insert substring into string at a specified position. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then inserted = self safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring // self % raw ( safepos :) endif else inserted % raw = substring endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction insert_character","tags":"","loc":"proc/insert_character.html","title":"insert_character – StringiFor"},{"text":"private elemental function insert_string(self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. Variables Type Visibility Attributes Name Initial integer, public :: safepos Safe position from which insert substring. Source Code elemental function insert_string ( self , substring , pos ) result ( inserted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Insert substring into string at a specified position. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: substring !< Substring. integer , intent ( in ) :: pos !< Position from which insert substring. type ( string ) :: inserted !< Inserted string. integer :: safepos !< Safe position from which insert substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then inserted = self if ( allocated ( substring % raw )) then safepos = min ( max ( 1 , pos ), len ( self % raw )) if ( safepos == 1 ) then inserted % raw = substring % raw // self % raw elseif ( safepos == len ( self % raw )) then inserted % raw = self % raw // substring % raw else inserted % raw = self % raw ( 1 : safepos - 1 ) // substring % raw // self % raw ( safepos :) endif endif else if ( allocated ( substring % raw )) inserted % raw = substring % raw endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction insert_string","tags":"","loc":"proc/insert_string.html","title":"insert_string – StringiFor"},{"text":"private pure function join_strings(self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden\n passing a custom separator. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: a Counter. Source Code pure function join_strings ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of strings. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( allocated ( array ( a )% raw )) join % raw = join % raw // sep_ // array ( a )% raw enddo if ( allocated ( array ( 1 )% raw )) then join % raw = array ( 1 )% raw // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_strings","tags":"","loc":"proc/join_strings.html","title":"join_strings – StringiFor"},{"text":"private pure function join_characters(self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden\n passing a custom separator. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: a Counter. Source Code pure function join_characters ( self , array , sep ) result ( join ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string that is a join of an array of characters. !< !< The join-separator is set equals to self if self has a value or it is set to a null string ''. This value can be overridden !< passing a custom separator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: array ( 1 :) !< Array to be joined. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: join !< The join of array. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: a !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = self % raw else sep_ = '' endif if ( present ( sep )) sep_ = sep join = '' do a = 2 , size ( array , dim = 1 ) if ( array ( a ) /= '' ) join % raw = join % raw // sep_ // array ( a ) enddo if ( array ( 1 ) /= '' ) then join % raw = array ( 1 ) // join % raw else join % raw = join % raw ( len ( sep_ ) + 1 : len ( join % raw )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction join_characters","tags":"","loc":"proc/join_characters.html","title":"join_characters – StringiFor"},{"text":"private elemental function lower(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all lowercase characters. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. Source Code elemental function lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all lowercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: lower !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then lower = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) lower % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lower","tags":"","loc":"proc/lower.html","title":"lower – StringiFor"},{"text":"private pure function partition(self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )\n  (1:3) after the separator. Description Split string at separator and return the 3 parts (before, the separator and after). Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: c Character counter. Source Code pure function partition ( self , sep ) result ( partitions ) !--------------------------------------------------------------------------------------------------------------------------------- !< Split string at separator and return the 3 parts (before, the separator and after). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: partitions ( 1 : 3 ) !< Partions: before the separator, the separator itsels and !< after the separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: c !< Character counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep partitions ( 1 ) = self partitions ( 2 ) = sep_ partitions ( 3 ) = '' if ( len ( sep_ ) >= len ( self % raw )) return c = index ( self % raw , sep_ ) if ( c > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw partitions ( 1 )% raw = temporary ( 1 : c - 1 ) partitions ( 2 )% raw = temporary ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = temporary ( c + len ( sep_ ):) #else partitions ( 1 )% raw = self % raw ( 1 : c - 1 ) partitions ( 2 )% raw = self % raw ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = self % raw ( c + len ( sep_ ):) #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction partition","tags":"","loc":"proc/partition.html","title":"partition – StringiFor"},{"text":"private elemental function replace(self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Description Return a string with all occurrences of substring old replaced by new. Variables Type Visibility Attributes Name Initial integer, public :: r Counter. Source Code elemental function replace ( self , old , new , count ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all occurrences of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. integer , intent ( in ), optional :: count !< Number of old occurences to be replaced. type ( string ) :: replaced !< The string with old replaced by new. integer :: r !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self r = 0 do if ( index ( replaced % raw , old ) > 0 ) then replaced = replaced % replace_one_occurrence ( old = old , new = new ) r = r + 1 if ( present ( count )) then if ( r >= count ) exit endif else exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace","tags":"","loc":"proc/replace.html","title":"replace – StringiFor"},{"text":"private elemental function reverse(self) result(reversed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. Description Return a reversed string. Variables Type Visibility Attributes Name Initial integer, public :: length Length of the string. integer, public :: c Counter. Source Code elemental function reverse ( self ) result ( reversed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a reversed string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: reversed !< The reversed string. integer :: length !< Length of the string. integer :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then reversed = self length = len ( self % raw ) do c = 1 , length reversed % raw ( c : c ) = self % raw ( length - c + 1 : length - c + 1 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction reverse","tags":"","loc":"proc/reverse.html","title":"reverse – StringiFor"},{"text":"private function search(self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: tag_start Start tag. character(kind=CK,len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK,len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. Description Search for tagged record into string, return the first record found (if any) matching the tags. Optionally, returns the indexes of tag start/end, thus this is not an elemental function. Note The tagged record is searched into self if allocated otherwise into in_string if passed or, eventually, into in_character is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are\n zero. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: raw Raw string into which search the tag. integer, public :: istart_ Starting index of tag inside the string, local variable. integer, public :: iend_ Ending index of tag inside the string, local variable. logical, public :: found Flag for inquiring search result. integer, public :: nested_tags Number of nested tags inside tag. integer, public :: t Counter. Source Code function search ( self , tag_start , tag_end , in_string , in_character , istart , iend ) result ( tag ) !--------------------------------------------------------------------------------------------------------------------------------- !< Search for *tagged* record into string, return the first record found (if any) matching the tags. !< !< Optionally, returns the indexes of tag start/end, thus this is not an `elemental` function. !< !< @note The tagged record is searched into self if allocated otherwise into `in_string` if passed or, eventually, into !< `in_character` is passed. If tag is not found the return string is not allocated and the start/end indexes (if requested) are !< zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: tag_start !< Start tag. character ( kind = CK , len =* ), intent ( in ) :: tag_end !< End tag. type ( string ), intent ( in ), optional :: in_string !< Search into this string. character ( kind = CK , len =* ), intent ( in ), optional :: in_character !< Search into this character string. integer , intent ( out ), optional :: istart !< Starting index of tag inside the string. integer , intent ( out ), optional :: iend !< Ending index of tag inside the string. type ( string ) :: tag !< First tag found. character ( kind = CK , len = :), allocatable :: raw !< Raw string into which search the tag. integer :: istart_ !< Starting index of tag inside the string, local variable. integer :: iend_ !< Ending index of tag inside the string, local variable. logical :: found !< Flag for inquiring search result. integer :: nested_tags !< Number of nested tags inside tag. integer :: t !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- raw = '' if ( present ( in_string )) then raw = in_string % raw elseif ( present ( in_character )) then raw = in_character else if ( allocated ( self % raw )) then raw = self % raw endif endif istart_ = 0 iend_ = 0 if ( raw /= '' ) then found = . false . istart_ = index ( raw , tag_start ) iend_ = index ( raw , tag_end ) if ( istart_ > 0. and . iend_ > 0 ) then iend_ = iend_ + len ( tag_end ) - 1 tag % raw = raw ( istart_ : iend_ ) nested_tags = tag % count ( tag_start ) if ( nested_tags > 1 ) then do t = 2 , nested_tags iend_ = iend_ + len ( tag_end ) - 1 + index ( raw ( iend_ + 1 :), tag_end ) enddo tag % raw = raw ( istart_ : iend_ ) endif endif endif if ( present ( istart )) istart = istart_ if ( present ( iend )) iend = iend_ return !--------------------------------------------------------------------------------------------------------------------------------- endfunction search","tags":"","loc":"proc/search.html","title":"search – StringiFor"},{"text":"private pure function slice(self, istart, iend) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: istart Slice start index. integer, intent(in) :: iend Slice end   index. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data sliced. Example type ( string ) :: astring !< A string. astring = 'the Quick Brown fox Jumps over the Lazy Dog.' print \"(A)\" , astring % slice ( 11 , 25 ) ! print \"Brown fox Jumps\" Source Code pure function slice ( self , istart , iend ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data sliced. !< !<### Example !< !<```fortran !< type(string) :: astring        !< A string. !< astring = 'the Quick Brown fox Jumps over the Lazy Dog.' !< print \"(A)\", astring%slice(11,25) ! print \"Brown fox Jumps\" !<``` !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: istart !< Slice start index. integer , intent ( in ) :: iend !< Slice end   index. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw ( istart : iend ) else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slice","tags":"","loc":"proc/slice.html","title":"slice – StringiFor"},{"text":"private elemental function snakecase(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. Description Return a string with all words lowercase separated by \"_\". Note Multiple subsequent separators are collapsed to one occurence. Variables Type Visibility Attributes Name Initial type( string ), public, allocatable :: tokens (:) String tokens. Source Code elemental function snakecase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words lowercase separated by \"_\". !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: snakecase !< Snake case string. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = tokens , sep = sep ) tokens = tokens % lower () snakecase = snakecase % join ( array = tokens , sep = '_' ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction snakecase","tags":"","loc":"proc/snakecase.html","title":"snakecase – StringiFor"},{"text":"private elemental function startcase(self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. Description Return a string with all words capitalized, e.g. title case. Note Multiple subsequent separators are collapsed to one occurence. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. type( string ), public, allocatable :: tokens (:) String tokens. Source Code elemental function startcase ( self , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all words capitalized, e.g. title case. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: startcase !< Start case string. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. type ( string ), allocatable :: tokens (:) !< String tokens. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep call self % split ( tokens = tokens , sep = sep_ ) tokens = tokens % capitalize () startcase = startcase % join ( array = tokens , sep = sep_ ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction startcase","tags":"","loc":"proc/startcase.html","title":"startcase – StringiFor"},{"text":"private elemental function strip(self, remove_nulls) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: remove_nulls Remove null characters at the end. Return Value type( string ) The stripped string. Description Return a copy of the string with the leading and trailing characters removed. Variables Type Visibility Attributes Name Initial integer, public :: c Counter. Source Code elemental function strip ( self , remove_nulls ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with the leading and trailing characters removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: remove_nulls !< Remove null characters at the end. type ( string ) :: strip !< The stripped string. integer :: c !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then strip = self % adjustl () strip = strip % trim () if ( present ( remove_nulls )) then if ( remove_nulls ) then c = index ( self % raw , char ( 0 )) if ( c > 0 ) strip % raw = strip % raw ( 1 : c - 1 ) endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strip","tags":"","loc":"proc/strip.html","title":"strip – StringiFor"},{"text":"private elemental function swapcase(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a copy of the string with uppercase characters converted to lowercase and vice versa. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. Source Code elemental function swapcase ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with uppercase characters converted to lowercase and vice versa. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: swapcase !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then swapcase = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) then swapcase % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) else n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) swapcase % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction swapcase","tags":"","loc":"proc/swapcase.html","title":"swapcase – StringiFor"},{"text":"private elemental function to_integer_I1P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). Source Code elemental function to_integer_I1P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I1P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I1P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I1P","tags":"","loc":"proc/to_integer_i1p.html","title":"to_integer_I1P – StringiFor"},{"text":"private elemental function to_integer_I2P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). Source Code elemental function to_integer_I2P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I2P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I2P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I2P","tags":"","loc":"proc/to_integer_i2p.html","title":"to_integer_I2P – StringiFor"},{"text":"private elemental function to_integer_I4P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). Source Code elemental function to_integer_I4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I4P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I4P","tags":"","loc":"proc/to_integer_i4p.html","title":"to_integer_I4P – StringiFor"},{"text":"private elemental function to_integer_I8P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). Source Code elemental function to_integer_I8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to integer (I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer ( I8P ), intent ( in ) :: kind !< Mold parameter for kind detection. integer ( I8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_integer ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_integer_I8P","tags":"","loc":"proc/to_integer_i8p.html","title":"to_integer_I8P – StringiFor"},{"text":"private elemental function to_real_R4P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). Source Code elemental function to_real_R4P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R4P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R4P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R4P","tags":"","loc":"proc/to_real_r4p.html","title":"to_real_R4P – StringiFor"},{"text":"private elemental function to_real_R8P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). Source Code elemental function to_real_R8P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R8P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R8P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R8P","tags":"","loc":"proc/to_real_r8p.html","title":"to_real_R8P – StringiFor"},{"text":"private elemental function to_real_R16P(self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. Description Cast string to real (R16P). Source Code elemental function to_real_R16P ( self , kind ) result ( to_number ) !--------------------------------------------------------------------------------------------------------------------------------- !< Cast string to real (R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. real ( R16P ), intent ( in ) :: kind !< Mold parameter for kind detection. real ( R16P ) :: to_number !< The number into the string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then if ( self % is_real ()) read ( self % raw , * ) to_number endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction to_real_R16P","tags":"","loc":"proc/to_real_r16p.html","title":"to_real_R16P – StringiFor"},{"text":"private elemental function unescape(self, to_unescape, unesc) result(unescaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_unescape Character to be unescaped. character(kind=CK,len=*), intent(in), optional :: unesc Character used to unescape. Return Value type( string ) Escaped string. Description Unescape double backslashes (or custom escaped character). Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: unesc_ Character to unescape, local variable. integer, public :: c Character counter. Source Code elemental function unescape ( self , to_unescape , unesc ) result ( unescaped ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unescape double backslashes (or custom escaped character). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = 1 ), intent ( in ) :: to_unescape !< Character to be unescaped. character ( kind = CK , len =* ), intent ( in ), optional :: unesc !< Character used to unescape. type ( string ) :: unescaped !< Escaped string. character ( kind = CK , len = :), allocatable :: unesc_ !< Character to unescape, local variable. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then unesc_ = '' ; if ( present ( unesc )) unesc_ = unesc unescaped % raw = '' c = 1 do if ( c > len ( self % raw )) exit if ( c == len ( self % raw )) then unescaped % raw = unescaped % raw // self % raw ( c : c ) exit else if ( self % raw ( c : c + 1 ) == BACKSLASH // to_unescape ) then unescaped % raw = unescaped % raw // to_unescape c = c + 2 else unescaped % raw = unescaped % raw // self % raw ( c : c ) c = c + 1 endif endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unescape","tags":"","loc":"proc/unescape.html","title":"unescape – StringiFor"},{"text":"private elemental function unique(self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Description Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. Note Eventual multiple trailing white space are not reduced to one occurrence. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: substring_ Substring, default value. Source Code elemental function unique ( self , substring ) result ( uniq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: substring !< Substring which multiple occurences must be reduced to one. character ( kind = CK , len = :), allocatable :: substring_ !< Substring, default value. type ( string ) :: uniq !< String parsed. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then substring_ = SPACE ; if ( present ( substring )) substring_ = substring uniq = self do if (. not . uniq % index ( repeat ( substring_ , 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( substring_ , 2 ), new = substring_ ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unique","tags":"","loc":"proc/unique.html","title":"unique – StringiFor"},{"text":"private elemental function upper(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all uppercase characters. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. Source Code elemental function upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all uppercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then upper = self do n1 = 1 , len ( self % raw ) n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) upper % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper","tags":"","loc":"proc/upper.html","title":"upper – StringiFor"},{"text":"private elemental function end_with(self, suffix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string ends with a specified suffix. Variables Type Visibility Attributes Name Initial integer, public :: start_ Start position into the string, local variable. integer, public :: end_ End position into the string, local variable. Source Code elemental function end_with ( self , suffix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string ends with a specified suffix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: suffix !< Searched suffix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: end_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- end_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( suffix ) <= len ( self % raw ( start_ : end_ ))) then end_with = index ( self % raw ( start_ : end_ ), suffix ) == ( len ( self % raw ( start_ : end_ )) - len ( suffix ) + 1 ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction end_with","tags":"","loc":"proc/end_with.html","title":"end_with – StringiFor"},{"text":"private elemental function is_allocated(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if the string is allocated. Source Code elemental function is_allocated ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string is allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_allocated !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_allocated = allocated ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_allocated","tags":"","loc":"proc/is_allocated.html","title":"is_allocated – StringiFor"},{"text":"private elemental function is_digit(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are digits. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function is_digit ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are digits. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_digit !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_digit = . false . if ( allocated ( self % raw )) then do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( '0' : '9' ) is_digit = . true . case default is_digit = . false . exit end select enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_digit","tags":"","loc":"proc/is_digit.html","title":"is_digit – StringiFor"},{"text":"private elemental function is_integer(self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains an integer. The regular expression is \\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s* . The parse algorithm is done in stages: S0 S1 S2 S3 S4 S5 S6 \\s* [\\+\\-]? \\d+ [eE] \\+? \\d+ \\s* Exit on stages-parsing results in: S0 S1 S2 S3 S4 S5 S6 F F T F F T T Note This implementation is courtesy of tomedunn Variables Type Visibility Attributes Name Initial logical, public :: allow_spaces_ Allow leading-trailing spaces, local variable. integer, public :: stage Stages counter. integer, public :: c Character counter. Source Code elemental function is_integer ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains an integer. !< !< The regular expression is `\\s*[\\+\\-]?\\d+([eE]\\+?\\d+)?\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3   | S4  | S5  | S6  | !< |-----|---------|-----|------|-----|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d+`|`[eE]`|`\\+?`|`\\d+`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | !< |----|----|----|----|----|----|----| !< |  F |  F |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L294) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_integer !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_integer = . true . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 6 ) is_integer = allow_spaces_ case ( 2 , 5 ) is_integer = allow_spaces_ stage = 6 case default is_integer = . false . endselect case ( '-' ) select case ( stage ) case ( 0 ) stage = 1 case default is_integer = . false . end select case ( '+' ) select case ( stage ) case ( 0 ) stage = 1 case ( 3 ) stage = 4 case default is_integer = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 case ( 3 : 4 ) stage = 5 case default continue endselect case ( 'e' , 'E' ) select case ( stage ) case ( 2 ) stage = 3 case default is_integer = . false . endselect case default is_integer = . false . endselect if (. not . is_integer ) exit enddo endif if ( is_integer ) then select case ( stage ) case ( 2 , 5 , 6 ) is_integer = . true . case default is_integer = . false . end select endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_integer","tags":"","loc":"proc/is_integer.html","title":"is_integer – StringiFor"},{"text":"private elemental function is_lower(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are lowercase. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function is_lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are lowercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_lower !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_lower = . false . if ( allocated ( self % raw )) then is_lower = . true . do c = 1 , len ( self % raw ) if ( index ( UPPER_ALPHABET , self % raw ( c : c )) > 0 ) then is_lower = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_lower","tags":"","loc":"proc/is_lower.html","title":"is_lower – StringiFor"},{"text":"private elemental function is_number(self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a number (real or integer). Source Code elemental function is_number ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a number (real or integer). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_number !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_number = ( self % is_integer ( allow_spaces = allow_spaces ). or . self % is_real ( allow_spaces = allow_spaces )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_number","tags":"","loc":"proc/is_number.html","title":"is_number – StringiFor"},{"text":"private elemental function is_real(self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a real. The regular expression is \\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s* . The parse algorithm is done in stages: S0 S1 S2 S3 S4 S5 S6 S7 S8 \\s* [\\+\\-]? \\d* \\.? \\d* [deDE] [\\+\\-]? \\d* \\s* Exit on stages-parsing results in: S0 S1 S2 S3 S4 S5 S6 S7 S8 Note This implementation is courtesy of tomedunn Variables Type Visibility Attributes Name Initial logical, public :: allow_spaces_ Allow leading-trailing spaces, local variable. logical, public :: has_leading_digit Check the presence of leading digits. integer, public :: stage Stages counter. integer, public :: c Character counter. Source Code elemental function is_real ( self , allow_spaces ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string contains a real. !< !< The regular expression is `\\s*[\\+\\-]?\\d*(|\\.?\\d*([deDE][\\+\\-]?\\d+)?)\\s*`. The parse algorithm is done in stages: !< !< | S0  | S1      | S2  | S3  | S4  | S5     | S6      | S7  | S8  | !< |-----|---------|-----|-----|-----|--------|---------|-----|-----| !< |`\\s*`|`[\\+\\-]?`|`\\d*`|`\\.?`|`\\d*`|`[deDE]`|`[\\+\\-]?`|`\\d*`|`\\s*`| !< !< Exit on stages-parsing results in: !< !< | S0 | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | !< |----|----|----|----|----|----|----|----|----| !  |  F |  F |  T |  T |  T |  F |  F |  T |  T | !< !< @note This implementation is courtesy of !< [tomedunn](https://github.com/tomedunn/fortran-string-utility-module/blob/master/src/string_utility_module.f90#L614) !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical , intent ( in ), optional :: allow_spaces !< Allow leading-trailing spaces. logical :: is_real !< Result of the test. logical :: allow_spaces_ !< Allow leading-trailing spaces, local variable. logical :: has_leading_digit !< Check the presence of leading digits. integer :: stage !< Stages counter. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then allow_spaces_ = . true . ; if ( present ( allow_spaces )) allow_spaces_ = allow_spaces stage = 0 is_real = . true . has_leading_digit = . false . do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( SPACE , TAB ) select case ( stage ) case ( 0 , 8 ) is_real = allow_spaces_ continue case ( 2 : 4 , 7 ) is_real = allow_spaces_ stage = 8 case default is_real = . false . endselect case ( '+' , '-' ) select case ( stage ) case ( 0 ) stage = 1 case ( 5 ) stage = 6 case default is_real = . false . endselect case ( '0' : '9' ) select case ( stage ) case ( 0 : 1 ) stage = 2 has_leading_digit = . true . case ( 3 ) stage = 4 case ( 5 : 6 ) stage = 7 case default continue endselect case ( '.' ) select case ( stage ) case ( 0 : 2 ) stage = 3 case default is_real = . false . endselect case ( 'e' , 'E' , 'd' , 'D' ) select case ( stage ) case ( 2 : 4 ) stage = 5 case default is_real = . false . endselect case default is_real = . false . endselect if (. not . is_real ) exit enddo endif if ( is_real ) then select case ( stage ) case ( 2 , 4 , 7 , 8 ) is_real = . true . case ( 3 ) is_real = has_leading_digit case default is_real = . false . endselect endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_real","tags":"","loc":"proc/is_real.html","title":"is_real – StringiFor"},{"text":"private elemental function is_upper(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are uppercase. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function is_upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are uppercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_upper !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_upper = . false . if ( allocated ( self % raw )) then is_upper = . true . do c = 1 , len ( self % raw ) if ( index ( LOWER_ALPHABET , self % raw ( c : c )) > 0 ) then is_upper = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_upper","tags":"","loc":"proc/is_upper.html","title":"is_upper – StringiFor"},{"text":"private elemental function start_with(self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string starts with a specified prefix. Variables Type Visibility Attributes Name Initial integer, public :: start_ Start position into the string, local variable. integer, public :: end_ End position into the string, local variable. Source Code elemental function start_with ( self , prefix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string starts with a specified prefix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: prefix !< Searched prefix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: start_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- start_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( prefix ) <= len ( self % raw ( start_ : end_ ))) then start_with = index ( self % raw ( start_ : end_ ), prefix ) == 1 endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction start_with","tags":"","loc":"proc/start_with.html","title":"start_with – StringiFor"},{"text":"private pure function string_concat_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. Source Code pure function string_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string","tags":"","loc":"proc/string_concat_string.html","title":"string_concat_string – StringiFor"},{"text":"private pure function string_concat_character(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. Source Code pure function string_concat_character ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character","tags":"","loc":"proc/string_concat_character.html","title":"string_concat_character – StringiFor"},{"text":"private pure function character_concat_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). Source Code pure function character_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string","tags":"","loc":"proc/character_concat_string.html","title":"character_concat_string – StringiFor"},{"text":"private elemental function string_concat_string_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: temporary Temporary concatenated string. Source Code elemental function string_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( kind = CK , len = :), allocatable :: temporary !< Temporary concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string_string","tags":"","loc":"proc/string_concat_string_string.html","title":"string_concat_string_string – StringiFor"},{"text":"private elemental function string_concat_character_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. Source Code elemental function string_concat_character_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character_string","tags":"","loc":"proc/string_concat_character_string.html","title":"string_concat_character_string – StringiFor"},{"text":"private elemental function character_concat_string_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). Source Code elemental function character_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string_string","tags":"","loc":"proc/character_concat_string_string.html","title":"character_concat_string_string – StringiFor"},{"text":"private elemental function string_eq_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. Source Code elemental function string_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw == rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_eq_string","tags":"","loc":"proc/string_eq_string.html","title":"string_eq_string – StringiFor"},{"text":"private elemental function string_eq_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. Source Code elemental function string_eq_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw == rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_eq_character","tags":"","loc":"proc/string_eq_character.html","title":"string_eq_character – StringiFor"},{"text":"private elemental function character_eq_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character (inverted) logical operator. Source Code elemental function character_eq_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Equal to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = rhs % raw == lhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_eq_string","tags":"","loc":"proc/character_eq_string.html","title":"character_eq_string – StringiFor"},{"text":"private elemental function string_ne_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to string logical operator. Source Code elemental function string_ne_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw /= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ne_string","tags":"","loc":"proc/string_ne_string.html","title":"string_ne_string – StringiFor"},{"text":"private elemental function string_ne_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character logical operator. Source Code elemental function string_ne_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw /= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ne_character","tags":"","loc":"proc/string_ne_character.html","title":"string_ne_character – StringiFor"},{"text":"private elemental function character_ne_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character (inverted) logical operator. Source Code elemental function character_ne_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Not equal to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = rhs % raw /= lhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_ne_string","tags":"","loc":"proc/character_ne_string.html","title":"character_ne_string – StringiFor"},{"text":"private elemental function string_lt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to string logical operator. Source Code elemental function string_lt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw < rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_lt_string","tags":"","loc":"proc/string_lt_string.html","title":"string_lt_string – StringiFor"},{"text":"private elemental function string_lt_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character logical operator. Source Code elemental function string_lt_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw < rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_lt_character","tags":"","loc":"proc/string_lt_character.html","title":"string_lt_character – StringiFor"},{"text":"private elemental function character_lt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character (inverted) logical operator. Source Code elemental function character_lt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs < rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_lt_string","tags":"","loc":"proc/character_lt_string.html","title":"character_lt_string – StringiFor"},{"text":"private elemental function string_le_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to string logical operator. Source Code elemental function string_le_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw <= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_le_string","tags":"","loc":"proc/string_le_string.html","title":"string_le_string – StringiFor"},{"text":"private elemental function string_le_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character logical operator. Source Code elemental function string_le_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw <= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_le_character","tags":"","loc":"proc/string_le_character.html","title":"string_le_character – StringiFor"},{"text":"private elemental function character_le_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character (inverted) logical operator. Source Code elemental function character_le_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Lower equal than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs <= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_le_string","tags":"","loc":"proc/character_le_string.html","title":"character_le_string – StringiFor"},{"text":"private elemental function string_ge_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to string logical operator. Source Code elemental function string_ge_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw >= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ge_string","tags":"","loc":"proc/string_ge_string.html","title":"string_ge_string – StringiFor"},{"text":"private elemental function string_ge_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character logical operator. Source Code elemental function string_ge_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw >= rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_ge_character","tags":"","loc":"proc/string_ge_character.html","title":"string_ge_character – StringiFor"},{"text":"private elemental function character_ge_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character (inverted) logical operator. Source Code elemental function character_ge_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater equal than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs >= rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_ge_string","tags":"","loc":"proc/character_ge_string.html","title":"character_ge_string – StringiFor"},{"text":"private elemental function string_gt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to string logical operator. Source Code elemental function string_gt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to string logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw > rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_gt_string","tags":"","loc":"proc/string_gt_string.html","title":"string_gt_string – StringiFor"},{"text":"private elemental function string_gt_character(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character logical operator. Source Code elemental function string_gt_character ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to character logical operator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs % raw > rhs return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_gt_character","tags":"","loc":"proc/string_gt_character.html","title":"string_gt_character – StringiFor"},{"text":"private elemental function character_gt_string(lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character (inverted) logical operator. Source Code elemental function character_gt_string ( lhs , rhs ) result ( is_it ) !--------------------------------------------------------------------------------------------------------------------------------- !< Greater than to character (inverted) logical operator. !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. logical :: is_it !< Opreator test result. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_it = lhs > rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_gt_string","tags":"","loc":"proc/character_gt_string.html","title":"character_gt_string – StringiFor"},{"text":"private elemental function replace_one_occurrence(self, old, new) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Description Return a string with the first occurrence of substring old replaced by new. Variables Type Visibility Attributes Name Initial integer, public :: pos Position from which replace old. Source Code elemental function replace_one_occurrence ( self , old , new ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with the first occurrence of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. type ( string ) :: replaced !< The string with old replaced by new. integer :: pos !< Position from which replace old. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self pos = index ( string = self % raw , substring = old ) if ( pos > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw if ( pos == 1 ) then replaced % raw = new // temporary ( len ( old ) + 1 :) else replaced % raw = temporary ( 1 : pos - 1 ) // new // temporary ( pos + len ( old ):) endif #else if ( pos == 1 ) then replaced % raw = new // self % raw ( len ( old ) + 1 :) else replaced % raw = self % raw ( 1 : pos - 1 ) // new // self % raw ( pos + len ( old ):) endif #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace_one_occurrence","tags":"","loc":"proc/replace_one_occurrence.html","title":"replace_one_occurrence – StringiFor"},{"text":"private elemental subroutine free(self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Description Free dynamic memory. Source Code elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) deallocate ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free.html","title":"free – StringiFor"},{"text":"private subroutine read_file(self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read a file as a single string stream. Note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a new_line character. Note For unformatted read only access='stream' is supported with new_line as line terminator. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. integer, public :: unit Logical unit. logical, public :: does_exist Check if file exist. Source Code subroutine read_file ( self , file , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a file as a single string stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. logical :: does_exist !< Check if file exist. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg inquire ( file = file , iomsg = iomsg_ , iostat = iostat_ , exist = does_exist ) if ( does_exist ) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , status = 'OLD' , action = 'READ' , form = 'UNFORMATTED' , access = 'STREAM' , & iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % read_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_file","tags":"","loc":"proc/read_file~2.html","title":"read_file – StringiFor"},{"text":"private subroutine read_line(self, unit, form, iostat, iomsg) Uses: iso_fortran_env Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read line (record) from a connected unit. The line is read as an ascii stream read until the eor is reached. Note For unformatted read only access='stream' is supported with new_line as line terminator. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. character(kind=CK,len=:), public, allocatable :: line Line storage. character(kind=CK,len=1), public :: ch Character storage. Source Code subroutine read_line ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read line (record) from a connected unit. !< !< The line is read as an ascii stream read until the eor is reached. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_eor !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. character ( kind = CK , len = :), allocatable :: line !< Line storage. character ( kind = CK , len = 1 ) :: ch !< Character storage. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg line = '' select case ( form_ % chars ()) case ( 'FORMATTED' ) do read ( unit , \"(A)\" , advance = 'no' , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 , eor = 10 ) ch line = line // ch enddo case ( 'UNFORMATTED' ) do read ( unit , iostat = iostat_ , iomsg = iomsg_ , err = 10 , end = 10 ) ch if ( ch == new_line ( 'a' )) then iostat_ = iostat_eor exit endif line = line // ch enddo endselect 10 if ( line /= '' ) self % raw = line if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_line","tags":"","loc":"proc/read_line.html","title":"read_line – StringiFor"},{"text":"private subroutine read_lines(self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read (all) lines (records) from a connected unit as a single ascii stream. Note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a new_line character. The line is read as an ascii stream read until the eor is reached. Note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. Note For unformatted read only access='stream' is supported with new_line as line terminator. Variables Type Visibility Attributes Name Initial integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. type( string ), public :: lines Lines storage. type( string ), public :: line Line storage. Source Code subroutine read_lines ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read (all) lines (records) from a connected unit as a single ascii stream. !< !< @note All the lines are stored into the string self as a single ascii stream. Each line (record) is separated by a `new_line` !< character. The line is read as an ascii stream read until the eor is reached. !< !< @note The connected unit is rewinded. At a successful exit current record is at eof, at the beginning otherwise. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. type ( string ) :: lines !< Lines storage. type ( string ) :: line !< Line storage. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg rewind ( unit ) iostat_ = 0 lines % raw = '' do line % raw = '' call line % read_line ( unit = unit , form = form , iostat = iostat_ , iomsg = iomsg_ ) if ( iostat_ /= 0. and .. not . is_iostat_eor ( iostat_ )) then exit elseif ( line /= '' ) then lines % raw = lines % raw // line % raw // new_line ( 'a' ) endif enddo if ( lines % raw /= '' ) self % raw = lines % raw if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_lines","tags":"","loc":"proc/read_lines~2.html","title":"read_lines – StringiFor"},{"text":"private pure subroutine split(self, tokens, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. Description Return a list of substring in the string, using sep as the delimiter string. Note Multiple subsequent separators are collapsed to one occurence. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: No Number of occurrences of sep. integer, public :: t Character counter. type( string ), public :: temporary Temporary storage. type( string ), public, allocatable :: temp_toks (:,:) Temporary tokens substring. Source Code pure subroutine split ( self , tokens , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a list of substring in the string, using sep as the delimiter string. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: No !< Number of occurrences of sep. integer :: t !< Character counter. type ( string ) :: temporary !< Temporary storage. type ( string ), allocatable :: temp_toks (:,:) !< Temporary tokens substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep temporary = self % unique ( sep_ ) No = temporary % count ( sep_ ) allocate ( temp_toks ( 3 , No )) temp_toks (:, 1 ) = temporary % partition ( sep_ ) if ( No > 1 ) then do t = 2 , No temp_toks (:, t ) = temp_toks ( 3 , t - 1 )% partition ( sep_ ) enddo endif if ( temp_toks ( 1 , 1 )% raw /= '' . and . temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No + 1 )) do t = 1 , No if ( t == No ) then tokens ( t ) = temp_toks ( 1 , t ) tokens ( t + 1 ) = temp_toks ( 3 , t ) else tokens ( t ) = temp_toks ( 1 , t ) endif enddo elseif ( temp_toks ( 1 , 1 )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No tokens ( t ) = temp_toks ( 1 , t ) enddo elseif ( temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No )) do t = 2 , No if ( t == No ) then tokens ( t - 1 ) = temp_toks ( 1 , t ) tokens ( t ) = temp_toks ( 3 , t ) else tokens ( t - 1 ) = temp_toks ( 1 , t ) endif enddo else allocate ( tokens ( No - 1 )) do t = 2 , No tokens ( t - 1 ) = temp_toks ( 1 , t ) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine split","tags":"","loc":"proc/split.html","title":"split – StringiFor"},{"text":"private subroutine write_file(self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write a single string stream into file. Note For unformatted read only access='stream' is supported with new_line as line terminator. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. integer, public :: unit Logical unit. Source Code subroutine write_file ( self , file , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write a single string stream into file. !< !< @note For unformatted read only `access='stream'` is supported with new_line as line terminator. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( len =* ), intent ( in ) :: file !< File name. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. integer :: unit !< Logical unit. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) case ( 'UNFORMATTED' ) open ( newunit = unit , file = file , action = 'WRITE' , form = 'UNFORMATTED' , access = 'STREAM' , iomsg = iomsg_ , iostat = iostat_ , err = 10 ) endselect call self % write_lines ( unit = unit , form = form , iomsg = iomsg_ , iostat = iostat_ ) 10 close ( unit ) if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_file","tags":"","loc":"proc/write_file~2.html","title":"write_file – StringiFor"},{"text":"private subroutine write_line(self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write line (record) to a connected unit. Note If the connected unit is unformatted a new_line() character is added at the end (if necessary) to mark the end of line. Variables Type Visibility Attributes Name Initial type( string ), public :: form_ Format of unit, local variable. integer, public :: iostat_ IO status code, local variable. character(len=:), public, allocatable :: iomsg_ IO status message, local variable. Source Code subroutine write_line ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write line (record) to a connected unit. !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ) :: form_ !< Format of unit, local variable. integer :: iostat_ !< IO status code, local variable. character ( len = :), allocatable :: iomsg_ !< IO status message, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- iostat_ = 0 iomsg_ = repeat ( ' ' , 99 ) ; if ( present ( iomsg )) iomsg_ = iomsg if ( allocated ( self % raw )) then form_ = 'FORMATTED' ; if ( present ( form )) form_ = form ; form_ = form_ % upper () select case ( form_ % chars ()) case ( 'FORMATTED' ) write ( unit , \"(A)\" , iostat = iostat_ , iomsg = iomsg_ ) self % raw case ( 'UNFORMATTED' ) if ( self % end_with ( new_line ( 'a' ))) then write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw else write ( unit , iostat = iostat_ , iomsg = iomsg_ ) self % raw // new_line ( 'a' ) endif endselect endif if ( present ( iostat )) iostat = iostat_ if ( present ( iomsg )) iomsg = iomsg_ return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_line","tags":"","loc":"proc/write_line.html","title":"write_line – StringiFor"},{"text":"private subroutine write_lines(self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write lines (records) to a connected unit. This method checks if self contains more than one line (records) and writes them as lines (records). Note If the connected unit is unformatted a new_line() character is added at the end (if necessary) to mark the end of line. Variables Type Visibility Attributes Name Initial type( string ), public, allocatable :: lines (:) Lines. integer, public :: l Counter. Source Code subroutine write_lines ( self , unit , form , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Write lines (records) to a connected unit. !< !< This method checks if self contains more than one line (records) and writes them as lines (records). !< !< @note If the connected unit is unformatted a `new_line()` character is added at the end (if necessary) to mark the end of line. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ), optional :: form !< Format of unit. integer , intent ( out ), optional :: iostat !< IO status code. character ( len =* ), intent ( inout ), optional :: iomsg !< IO status message. type ( string ), allocatable :: lines (:) !< Lines. integer :: l !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then call self % split ( tokens = lines , sep = new_line ( 'a' )) do l = 1 , size ( lines , dim = 1 ) call lines ( l )% write_line ( unit = unit , form = form , iostat = iostat , iomsg = iomsg ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_lines","tags":"","loc":"proc/write_lines~2.html","title":"write_lines – StringiFor"},{"text":"private elemental subroutine string_assign_string(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. Source Code elemental subroutine string_assign_string ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from string input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) lhs % raw = rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_string","tags":"","loc":"proc/string_assign_string.html","title":"string_assign_string – StringiFor"},{"text":"private elemental subroutine string_assign_character(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. Source Code elemental subroutine string_assign_character ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from character input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_character","tags":"","loc":"proc/string_assign_character.html","title":"string_assign_character – StringiFor"},{"text":"private elemental subroutine string_assign_integer_I1P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i1p~~CallsGraph proc~string_assign_integer_i1p string_assign_integer_I1P interface~str str proc~string_assign_integer_i1p->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I1P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I1P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I1P","tags":"","loc":"proc/string_assign_integer_i1p.html","title":"string_assign_integer_I1P – StringiFor"},{"text":"private elemental subroutine string_assign_integer_I2P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i2p~~CallsGraph proc~string_assign_integer_i2p string_assign_integer_I2P interface~str str proc~string_assign_integer_i2p->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I2P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I2P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I2P","tags":"","loc":"proc/string_assign_integer_i2p.html","title":"string_assign_integer_I2P – StringiFor"},{"text":"private elemental subroutine string_assign_integer_I4P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i4p~~CallsGraph proc~string_assign_integer_i4p string_assign_integer_I4P interface~str str proc~string_assign_integer_i4p->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I4P","tags":"","loc":"proc/string_assign_integer_i4p.html","title":"string_assign_integer_I4P – StringiFor"},{"text":"private elemental subroutine string_assign_integer_I8P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_integer_i8p~~CallsGraph proc~string_assign_integer_i8p string_assign_integer_I8P interface~str str proc~string_assign_integer_i8p->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_integer_I8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. integer ( I8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_integer_I8P","tags":"","loc":"proc/string_assign_integer_i8p.html","title":"string_assign_integer_I8P – StringiFor"},{"text":"private elemental subroutine string_assign_real_R4P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_real_r4p~~CallsGraph proc~string_assign_real_r4p string_assign_real_R4P interface~str str proc~string_assign_real_r4p->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_real_R4P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R4P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R4P","tags":"","loc":"proc/string_assign_real_r4p.html","title":"string_assign_real_R4P – StringiFor"},{"text":"private elemental subroutine string_assign_real_R8P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_real_r8p~~CallsGraph proc~string_assign_real_r8p string_assign_real_R8P interface~str str proc~string_assign_real_r8p->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_real_R8P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R8P","tags":"","loc":"proc/string_assign_real_r8p.html","title":"string_assign_real_R8P – StringiFor"},{"text":"private elemental subroutine string_assign_real_R16P(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. Calls proc~~string_assign_real_r16p~~CallsGraph proc~string_assign_real_r16p string_assign_real_R16P interface~str str proc~string_assign_real_r16p->interface~str proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code elemental subroutine string_assign_real_R16P ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from real input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. real ( R16P ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = trim ( str ( rhs )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_real_R16P","tags":"","loc":"proc/string_assign_real_r16p.html","title":"string_assign_real_R16P – StringiFor"},{"text":"private subroutine read_formatted(dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Calls proc~~read_formatted~~CallsGraph proc~read_formatted read_formatted proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~read_formatted->proc~get_next_non_blank_character_any_record proc~get_next_non_blank_character_this_record get_next_non_blank_character_this_record proc~get_next_non_blank_character_any_record->proc~get_next_non_blank_character_this_record Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=len(iomsg)), public :: local_iomsg Local variant of iomsg, so it doesn't get inappropriately redefined. character(kind=CK,len=1), public :: delim String delimiter, if any. character(kind=CK,len=100), public :: temporary Temporary storage string. Source Code subroutine read_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len = len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. character ( kind = CK , len = 1 ) :: delim !< String delimiter, if any. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( iotype == 'LISTDIRECTED' ) then call get_next_non_blank_character_any_record ( unit = unit , ch = delim , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return if ( delim == '\"' . OR . delim == \"'\" ) then call dtv % read_delimited ( unit = unit , delim = delim , iostat = iostat , iomsg = local_iomsg ) else ! step back before the non-blank read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited_listdirected ( unit = unit , iostat = iostat , iomsg = local_iomsg ) endif if ( is_iostat_eor ( iostat )) then ! suppress IOSTAT_EOR iostat = 0 elseif ( iostat /= 0 ) then iomsg = local_iomsg endif return else read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted","tags":"","loc":"proc/read_formatted.html","title":"read_formatted – StringiFor"},{"text":"private subroutine read_delimited(dtv, unit, delim, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(out) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(in) :: delim String delimiter. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Read a delimited string from a unit connected for formatted input. If the closing delimiter is followed by end of record, then we return end of record. Variables Type Visibility Attributes Name Initial character(kind=CK,len=1), public :: ch A character read. logical, public :: was_delim Indicates that the last character read was a delimiter. Source Code subroutine read_delimited ( dtv , unit , delim , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read a delimited string from a unit connected for formatted input. !< !< If the closing delimiter is followed by end of record, then we return end of record. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( out ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( in ) :: delim !< String delimiter. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. logical :: was_delim !< Indicates that the last character read was a delimiter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- was_delim = . false . dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then if ( was_delim ) then ! end of delimited string followed by end of record is end of the string. Pass back the end of record condition to the ! caller return else ! end of record without terminating delimiter - move along cycle endif elseif ( iostat /= 0 ) THEN return endif if ( ch == delim ) then if ( was_delim ) then ! doubled delimiter is one delimiter in the value dtv % raw = dtv % raw // ch was_delim = . false . else ! need to test next character to see what is happening was_delim = . true . endif elseif ( was_delim ) then ! the previous character was actually the delimiter for the end of the string. Put back this character read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) return else dtv % raw = dtv % raw // ch endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_delimited","tags":"","loc":"proc/read_delimited.html","title":"read_delimited – StringiFor"},{"text":"private subroutine read_undelimited_listdirected(dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. If input is terminated by end of record, then this procedure returns an end-of-record condition. Calls proc~~read_undelimited_listdirected~~CallsGraph proc~read_undelimited_listdirected read_undelimited_listdirected proc~get_decimal_mode get_decimal_mode proc~read_undelimited_listdirected->proc~get_decimal_mode Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: decimal_point True if DECIMAL=POINT in effect. Source Code subroutine read_undelimited_listdirected ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. !< !< A blank, comma/semicolon (depending on the decimal mode), slash or end of record terminates the string. !< !< If input is terminated by end of record, then this procedure returns an end-of-record condition. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. logical :: decimal_point !<True if DECIMAL=POINT in effect. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call get_decimal_mode ( unit = unit , decimal_point = decimal_point , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return call dtv % read_undelimited ( unit = unit , terminators = ' ' // '/' // merge ( CK_ ',' , CK_ ';' , decimal_point ), iostat = iostat , iomsg = iomsg ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_undelimited_listdirected","tags":"","loc":"proc/read_undelimited_listdirected.html","title":"read_undelimited_listdirected – StringiFor"},{"text":"private subroutine read_undelimited(dtv, unit, terminators, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: terminators Characters that are considered to terminate the string.\n Blanks in this string are meaningful. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited string up until end of record or a character from a set of terminators is encountered. If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the\n file remains at end of record. Variables Type Visibility Attributes Name Initial character(kind=CK,len=1), public :: ch A character read. Source Code subroutine read_undelimited ( dtv , unit , terminators , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Read an undelimited string up until end of record or a character from a set of terminators is encountered. !< !< If a terminator is encountered, the file position will be at that terminating character. If end of record is encountered, the !< file remains at end of record. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: terminators !< Characters that are considered to terminate the string. !< Blanks in this string are meaningful. integer , intent ( out ) :: iostat !< IO status code. character ( len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 1 ) :: ch !< A character read. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dtv % raw = '' do read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) ch if ( is_iostat_eor ( iostat )) then ! end of record just means end of string. We pass on the condition return elseif ( iostat /= 0 ) then ! something odd happened return endif if ( scan ( ch , terminators ) /= 0 ) then ! change the file position so that the next read sees the terminator read ( unit , \"(TL1)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return iostat = 0 return endif ! we got a character - append it dtv % raw = dtv % raw // ch enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_undelimited","tags":"","loc":"proc/read_undelimited.html","title":"read_undelimited – StringiFor"},{"text":"private subroutine write_formatted(dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. Source Code subroutine write_formatted ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted","tags":"","loc":"proc/write_formatted.html","title":"write_formatted – StringiFor"},{"text":"private subroutine read_unformatted(dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Variables Type Visibility Attributes Name Initial character(kind=CK,len=100), public :: temporary Temporary storage string. Source Code subroutine read_unformatted ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_unformatted","tags":"","loc":"proc/read_unformatted.html","title":"read_unformatted – StringiFor"},{"text":"private subroutine write_unformatted(dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. Source Code subroutine write_unformatted ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_unformatted","tags":"","loc":"proc/write_unformatted.html","title":"write_unformatted – StringiFor"},{"text":"private subroutine get_delimiter_mode(unit, delim, iostat, iomsg) Uses: iso_fortran_env Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit The unit for the connection. character(kind=len=1,CK), intent(out) :: delim Represents the value of the DELIM mode. integer, intent(out) :: iostat IOSTAT error code, non-zero on error. character(len=*), intent(inout) :: iomsg IOMSG explanatory message - only defined if iostat is non-zero. Description Get the DELIM changeable connection mode for the given unit. If the unit is connected to an internal file, then the default value of NONE is always returned. Variables Type Visibility Attributes Name Initial character(len=10), public :: delim_buffer Buffer for INQUIRE about DELIM, sized for APOSTROHPE. character(len=len(iomsg)), public :: local_iomsg Local variant of iomsg, so it doesn't get inappropriately redefined. Source Code subroutine get_delimiter_mode ( unit , delim , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the DELIM changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of NONE is always returned. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< The unit for the connection. character ( len = 1 , kind = CK ), intent ( out ) :: delim !< Represents the value of the DELIM mode. integer , intent ( out ) :: iostat !< IOSTAT error code, non-zero on error. character ( * ), intent ( inout ) :: iomsg !< IOMSG explanatory message - only defined if iostat is non-zero. character ( 10 ) :: delim_buffer !< Buffer for INQUIRE about DELIM, sized for APOSTROHPE. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ! get the string representation of the changeable mode inquire ( unit , delim = delim_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the DELIM mode for an internal file iostat = 0 delim = '' return elseif ( iostat /= 0 ) then iomsg = local_iomsg return endif ! interpret the DELIM string if ( delim_buffer == 'QUOTE' ) then delim = '\"' elseif ( delim_buffer == 'APOSTROPHE' ) then delim = '''' else delim = '\"' endif !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_delimiter_mode","tags":"","loc":"proc/get_delimiter_mode.html","title":"get_delimiter_mode – StringiFor"},{"text":"private subroutine get_next_non_blank_character_this_record(unit, ch, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the next non-blank character in the current record. Called By proc~~get_next_non_blank_character_this_record~~CalledByGraph proc~get_next_non_blank_character_this_record get_next_non_blank_character_this_record proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~get_next_non_blank_character_any_record->proc~get_next_non_blank_character_this_record proc~read_formatted read_formatted proc~read_formatted->proc~get_next_non_blank_character_any_record Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_next_non_blank_character_this_record ( unit , ch , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the next non-blank character in the current record. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do ! we spcify non-advancing, just in case we want this callable outside the context of a child input statement ! the PAD specifier simply saves the need for the READ statement to define ch if EOR is hit ! read(unit, \"(A)\", iostat=iostat, iomsg=iomsg, advance='NO') ch ! ...but that causes ifort to blow up at runtime read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg , pad = 'NO' ) ch if ( iostat /= 0 ) return if ( ch /= '' ) exit enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_next_non_blank_character_this_record","tags":"","loc":"proc/get_next_non_blank_character_this_record.html","title":"get_next_non_blank_character_this_record – StringiFor"},{"text":"private subroutine get_next_non_blank_character_any_record(unit, ch, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the next non-blank character, advancing records if necessary. Calls proc~~get_next_non_blank_character_any_record~~CallsGraph proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~get_next_non_blank_character_this_record get_next_non_blank_character_this_record proc~get_next_non_blank_character_any_record->proc~get_next_non_blank_character_this_record Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~get_next_non_blank_character_any_record~~CalledByGraph proc~get_next_non_blank_character_any_record get_next_non_blank_character_any_record proc~read_formatted read_formatted proc~read_formatted->proc~get_next_non_blank_character_any_record Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=len(iomsg)), public :: local_iomsg Local variant of iomsg, so it doesn't get inappropriately redefined. Source Code subroutine get_next_non_blank_character_any_record ( unit , ch , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the next non-blank character, advancing records if necessary. !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len = 1 ), intent ( out ) :: ch !< The non-blank character read. Not valid if IOSTAT is non-zero. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- do call get_next_non_blank_character_this_record ( unit = unit , ch = ch , iostat = iostat , iomsg = local_iomsg ) if ( is_iostat_eor ( iostat )) then ! try again on the next record read ( unit , \"(/)\" , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) return elseif ( iostat /= 0 ) then ! some sort of problem iomsg = local_iomsg return else ! got it exit endif enddo return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_next_non_blank_character_any_record","tags":"","loc":"proc/get_next_non_blank_character_any_record.html","title":"get_next_non_blank_character_any_record – StringiFor"},{"text":"private subroutine get_decimal_mode(unit, decimal_point, iostat, iomsg) Uses: iso_fortran_env Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. logical, intent(out) :: decimal_point True if the decimal mode is POINT, false otherwise. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the DECIMAL changeable connection mode for the given unit. If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the\n actual value in force at the time of the call to this procedure. Called By proc~~get_decimal_mode~~CalledByGraph proc~get_decimal_mode get_decimal_mode proc~read_undelimited_listdirected read_undelimited_listdirected proc~read_undelimited_listdirected->proc~get_decimal_mode Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=5), public :: decimal_buffer Buffer for INQUIRE about DECIMAL, sized for POINT or COMMA. character(len=len(iomsg)), public :: local_iomsg Local variant of iomsg, so it doesn't get inappropriately redefined. Source Code subroutine get_decimal_mode ( unit , decimal_point , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get the DECIMAL changeable connection mode for the given unit. !< !< If the unit is connected to an internal file, then the default value of DECIMAL is always returned. This may not be the !< actual value in force at the time of the call to this procedure. !--------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : iostat_inquire_internal_unit !--------------------------------------------------------------------------------------------------------------------------------- integer , intent ( in ) :: unit !< Logical unit. logical , intent ( out ) :: decimal_point !< True if the decimal mode is POINT, false otherwise. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( 5 ) :: decimal_buffer !< Buffer for INQUIRE about DECIMAL, sized for POINT or COMMA. character ( len ( iomsg )) :: local_iomsg !< Local variant of iomsg, so it doesn't get inappropriately redefined. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- inquire ( unit , decimal = decimal_buffer , iostat = iostat , iomsg = local_iomsg ) if ( iostat == iostat_inquire_internal_unit ) then ! no way of determining the decimal mode for an internal file iostat = 0 decimal_point = . true . return else if ( iostat /= 0 ) then iomsg = local_iomsg return endif decimal_point = decimal_buffer == 'POINT' !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine get_decimal_mode","tags":"","loc":"proc/get_decimal_mode.html","title":"get_decimal_mode – StringiFor"},{"text":"PENF global (exposed) parameters and variables. Note All module defined entities are public. Used By module~~penf_global_parameters_variables~3~~UsedByGraph module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_b_size~3 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~3 module~penf_b_size penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables~3->module~penf_stringify module~penf_stringify~3 penf_stringify module~penf_global_parameters_variables~3->module~penf_stringify~3 module~penf penf module~penf_global_parameters_variables~3->module~penf module~penf~2 penf module~penf_global_parameters_variables~3->module~penf~2 module~penf~3 penf module~penf_global_parameters_variables~3->module~penf~3 module~penf_stringify~2 penf_stringify module~penf_global_parameters_variables~3->module~penf_stringify~2 module~penf_b_size~2->module~penf_stringify module~penf_b_size~2->module~penf_stringify~3 module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf~3 module~penf_b_size~2->module~penf_stringify~2 module~penf_stringify->module~penf module~penf_stringify->module~penf~2 module~penf_stringify->module~penf~3 module~befor64~2 befor64 module~penf->module~befor64~2 module~stringifor stringifor module~penf->module~stringifor module~befor64_pack_data_m~2 befor64_pack_data_m module~penf->module~befor64_pack_data_m~2 program~test_all test_all module~penf->program~test_all module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t program~test_all~2 test_all module~penf->program~test_all~2 module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t program~test_driver Test_Driver module~befor64~2->program~test_driver program~free free module~stringifor->program~free program~greater_than greater_than module~stringifor->program~greater_than program~lower_than lower_than module~stringifor->program~lower_than program~read_lines read_lines module~stringifor->program~read_lines program~io_basic io_basic module~stringifor->program~io_basic program~startcase startcase module~stringifor->program~startcase program~join join module~stringifor->program~join program~count_string count_string module~stringifor->program~count_string program~is_digit is_digit module~stringifor->program~is_digit program~concatenation concatenation module~stringifor->program~concatenation program~slen slen module~stringifor->program~slen program~insert insert module~stringifor->program~insert program~io_formatted io_formatted module~stringifor->program~io_formatted program~unescape unescape module~stringifor->program~unescape program~sadjustlr sadjustlr module~stringifor->program~sadjustlr program~swapcase swapcase module~stringifor->program~swapcase program~csv_naive_parser csv_naive_parser module~stringifor->program~csv_naive_parser program~strim strim module~stringifor->program~strim program~reverse reverse module~stringifor->program~reverse program~read_line read_line module~stringifor->program~read_line program~is_integer is_integer module~stringifor->program~is_integer program~start_end start_end module~stringifor->program~start_end program~is_number is_number module~stringifor->program~is_number program~unique unique module~stringifor->program~unique program~is_real is_real module~stringifor->program~is_real program~upper_lower upper_lower module~stringifor->program~upper_lower program~write_file write_file module~stringifor->program~write_file program~sscan sscan module~stringifor->program~sscan program~assignments assignments module~stringifor->program~assignments program~escape escape module~stringifor->program~escape program~partition partition module~stringifor->program~partition program~basename_dir basename_dir module~stringifor->program~basename_dir program~to_number to_number module~stringifor->program~to_number program~equal equal module~stringifor->program~equal program~sindex sindex module~stringifor->program~sindex program~read_file read_file module~stringifor->program~read_file program~replace replace module~stringifor->program~replace program~not_equal not_equal module~stringifor->program~not_equal program~slice slice module~stringifor->program~slice program~snakecase snakecase module~stringifor->program~snakecase program~extension extension module~stringifor->program~extension program~srepeat srepeat module~stringifor->program~srepeat program~search search module~stringifor->program~search program~strip strip module~stringifor->program~strip program~fill fill module~stringifor->program~fill program~lower_equal_than lower_equal_than module~stringifor->program~lower_equal_than program~greater_equal_than greater_equal_than module~stringifor->program~greater_equal_than program~write_lines write_lines module~stringifor->program~write_lines program~decode decode module~stringifor->program~decode program~sverify sverify module~stringifor->program~sverify program~camelcase camelcase module~stringifor->program~camelcase program~capitalize capitalize module~stringifor->program~capitalize program~encode encode module~stringifor->program~encode program~split split module~stringifor->program~split module~stringifor_string_t->module~stringifor module~befor64_pack_data_m->module~befor64~2 module~befor64_pack_data_m->module~befor64 var panmodulepenf_global_parameters_variables3UsedByGraph = svgPanZoom('#modulepenf_global_parameters_variables3UsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: is_initialized = .false. Check the initialization of some variables that must be initialized. integer, public, parameter :: endianL = 1 Little endian parameter. integer, public, parameter :: endianB = 0 Big endian parameter. integer, public :: endian = endianL Bit ordering: Little endian (endianL), or Big endian (endianB). integer, public, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, public, parameter :: R8P = selected_real_kind(15, 307) 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision. character(len=*), public, parameter :: FR16P = '(E23.15E3)' Output format for kind=R16P real. character(len=*), public, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P real. character(len=*), public, parameter :: FR4P = '(E13.6E2)' Output format for kind=R4P real. character(len=*), public, parameter :: FR_P = FR8P Output format for kind=R_P real. character(len=*), public, parameter :: FI8P = '(I20)' Output format for kind=I8P integer. character(len=*), public, parameter :: FI8PZP = '(I20.19)' Output format for kind=I8P integer with zero prefixing. character(len=*), public, parameter :: FI4P = '(I11)' Output format for kind=I4P integer. character(len=*), public, parameter :: FI4PZP = '(I11.10)' Output format for kind=I4P integer with zero prefixing. character(len=*), public, parameter :: FI2P = '(I6)' Output format for kind=I2P integer. character(len=*), public, parameter :: FI2PZP = '(I6.5)' Output format for kind=I2P integer with zero prefixing. character(len=*), public, parameter :: FI1P = '(I4)' Output format for kind=I1P integer. character(len=*), public, parameter :: FI1PZP = '(I4.3)' Output format for kind=I1P integer with zero prefixing. character(len=*), public, parameter :: FI_P = FI4P Output format for kind=I_P integer. character(len=*), public, parameter :: FI_PZP = FI4PZP Output format for kind=I_P integer with zero prefixing. integer, public, parameter :: DR16P = 23 Number of digits of output format FR16P. integer, public, parameter :: DR8P = 23 Number of digits of output format FR8P. integer, public, parameter :: DR4P = 13 Number of digits of output format FR4P. integer, public, parameter :: DR_P = DR8P Number of digits of output format FR_P. integer, public, parameter :: DI8P = 20 Number of digits of output format I8P. integer, public, parameter :: DI4P = 11 Number of digits of output format I4P. integer, public, parameter :: DI2P = 6 Number of digits of output format I2P. integer, public, parameter :: DI1P = 4 Number of digits of output format I1P. integer, public, parameter :: DI_P = DI4P Number of digits of output format I_P. integer, public, parameter :: REAL_KINDS_LIST (1:4) = [R16P, R8P, R4P, R_P] List of real kinds. character(len=*), public, parameter :: REAL_FORMATS_LIST (1:4) = [FR16P, FR8P, FR4P//' ', FR_P] List of real formats. integer, public, parameter :: INTEGER_KINDS_LIST (1:5) = [I8P, I4P, I2P, I1P, I_P] List of integer kinds. character(len=*), public, parameter :: INTEGER_FORMATS_LIST (1:5) = [FI8P, FI4P, FI2P//' ', FI1P//' ', FI_P] List of integer formats. real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) Minimum value of kind=R16P real. real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) Maximum value of kind=R16P real. real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) Minimum value of kind=R8P real. real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) Maximum value of kind=R8P real. real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) Minimum value of kind=R4P real. real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) Maximum value of kind=R4P real. real(kind=R_P), public, parameter :: MinR_P = MinR8P Minimum value of kind=R_P real. real(kind=R_P), public, parameter :: MaxR_P = MaxR8P Maximum value of kind=R_P real. integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) Minimum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) Minimum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) Minimum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) Minimum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MinI_P = MinI4P Minimum value of kind=I_P integer. integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) Maximum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) Maximum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) Maximum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) Maximum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MaxI_P = MaxI4P Maximum value of kind=I_P integer. real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) Smallest representable value of kind=R16P real. real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) Smallest representable value of kind=R8P real. real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) Smallest representable value of kind=R4P real. real(kind=R_P), public, parameter :: smallR_P = smallR8P Smallest representable value of kind=R_P real. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P, 1._R16P)-nearest(1._R16P, -1._R16P) Smallest representable difference of kind=R16P real. real(kind=R8P), public, parameter :: ZeroR8 = nearest(1._R8P, 1._R8P)-nearest(1._R8P, -1._R8P) Smallest representable difference of kind=R8P real. real(kind=R4P), public, parameter :: ZeroR4 = nearest(1._R4P, 1._R4P)-nearest(1._R4P, -1._R4P) Smallest representable difference of kind=R4P real. real(kind=R_P), public, parameter :: Zero = ZeroR8 Smallest representable difference of kind=R_P real. integer(kind=I2P), public :: BIR16P Number of bits of kind=R16P real. integer(kind=I1P), public :: BIR8P Number of bits of kind=R8P real. integer(kind=I1P), public :: BIR4P Number of bits of kind=R4P real. integer(kind=I1P), public :: BIR_P Number of bits of kind=R_P real. integer(kind=I2P), public :: BYR16P Number of bytes of kind=R16P real. integer(kind=I1P), public :: BYR8P Number of bytes of kind=R8P real. integer(kind=I1P), public :: BYR4P Number of bytes of kind=R4P real. integer(kind=I1P), public :: BYR_P Number of bytes of kind=R_P real. integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) Number of bits of kind=I8P integer. integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) Number of bits of kind=I4P integer. integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) Number of bits of kind=I2P integer. integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) Number of bits of kind=I1P integer. integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) Number of bits of kind=I_P integer. integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P Number of bytes of kind=I8P integer. integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P Number of bytes of kind=I4P integer. integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P Number of bytes of kind=I2P integer. integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P Number of bytes of kind=I1P integer. integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P Number of bytes of kind=I_P integer.","tags":"","loc":"module/penf_global_parameters_variables~3.html","title":"penf_global_parameters_variables – StringiFor"},{"text":"Uses: penf_global_parameters_variables module~~penf_b_size~2~~UsesGraph module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf_b_size~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF bit/byte size functions. Used By module~~penf_b_size~2~~UsedByGraph module~penf_b_size~2 penf_b_size module~penf_stringify penf_stringify module~penf_b_size~2->module~penf_stringify module~penf_stringify~3 penf_stringify module~penf_b_size~2->module~penf_stringify~3 module~penf_stringify~2 penf_stringify module~penf_b_size~2->module~penf_stringify~2 module~penf~2 penf module~penf_b_size~2->module~penf~2 module~penf~3 penf module~penf_b_size~2->module~penf~3 module~penf penf module~penf_b_size~2->module~penf module~penf_stringify->module~penf~2 module~penf_stringify->module~penf~3 module~penf_stringify->module~penf module~befor64~2 befor64 module~penf->module~befor64~2 module~stringifor stringifor module~penf->module~stringifor module~befor64_pack_data_m~2 befor64_pack_data_m module~penf->module~befor64_pack_data_m~2 program~test_all test_all module~penf->program~test_all module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t program~test_all~2 test_all module~penf->program~test_all~2 module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t program~test_driver Test_Driver module~befor64~2->program~test_driver program~free free module~stringifor->program~free program~greater_than greater_than module~stringifor->program~greater_than program~lower_than lower_than module~stringifor->program~lower_than program~read_lines read_lines module~stringifor->program~read_lines program~io_basic io_basic module~stringifor->program~io_basic program~startcase startcase module~stringifor->program~startcase program~join join module~stringifor->program~join program~count_string count_string module~stringifor->program~count_string program~is_digit is_digit module~stringifor->program~is_digit program~concatenation concatenation module~stringifor->program~concatenation program~slen slen module~stringifor->program~slen program~insert insert module~stringifor->program~insert program~io_formatted io_formatted module~stringifor->program~io_formatted program~unescape unescape module~stringifor->program~unescape program~sadjustlr sadjustlr module~stringifor->program~sadjustlr program~swapcase swapcase module~stringifor->program~swapcase program~csv_naive_parser csv_naive_parser module~stringifor->program~csv_naive_parser program~strim strim module~stringifor->program~strim program~reverse reverse module~stringifor->program~reverse program~read_line read_line module~stringifor->program~read_line program~is_integer is_integer module~stringifor->program~is_integer program~start_end start_end module~stringifor->program~start_end program~is_number is_number module~stringifor->program~is_number program~unique unique module~stringifor->program~unique program~is_real is_real module~stringifor->program~is_real program~upper_lower upper_lower module~stringifor->program~upper_lower program~write_file write_file module~stringifor->program~write_file program~sscan sscan module~stringifor->program~sscan program~assignments assignments module~stringifor->program~assignments program~escape escape module~stringifor->program~escape program~partition partition module~stringifor->program~partition program~basename_dir basename_dir module~stringifor->program~basename_dir program~to_number to_number module~stringifor->program~to_number program~equal equal module~stringifor->program~equal program~sindex sindex module~stringifor->program~sindex program~read_file read_file module~stringifor->program~read_file program~replace replace module~stringifor->program~replace program~not_equal not_equal module~stringifor->program~not_equal program~slice slice module~stringifor->program~slice program~snakecase snakecase module~stringifor->program~snakecase program~extension extension module~stringifor->program~extension program~srepeat srepeat module~stringifor->program~srepeat program~search search module~stringifor->program~search program~strip strip module~stringifor->program~strip program~fill fill module~stringifor->program~fill program~lower_equal_than lower_equal_than module~stringifor->program~lower_equal_than program~greater_equal_than greater_equal_than module~stringifor->program~greater_equal_than program~write_lines write_lines module~stringifor->program~write_lines program~decode decode module~stringifor->program~decode program~sverify sverify module~stringifor->program~sverify program~camelcase camelcase module~stringifor->program~camelcase program~capitalize capitalize module~stringifor->program~capitalize program~encode encode module~stringifor->program~encode program~split split module~stringifor->program~split module~stringifor_string_t->module~stringifor module~befor64_pack_data_m->module~befor64~2 module~befor64_pack_data_m->module~befor64 var panmodulepenf_b_size2UsedByGraph = svgPanZoom('#modulepenf_b_size2UsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. public interface byte_size Compute the number of bytes of a variable. private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable. Functions private elemental function bit_size_R16P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R16P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable.","tags":"","loc":"module/penf_b_size~2.html","title":"penf_b_size – StringiFor"},{"text":"Uses: iso_fortran_env penf_b_size penf_global_parameters_variables module~~penf_stringify~~UsesGraph module~penf_stringify penf_stringify module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~penf_b_size~2->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF string-to-number (and viceversa) facility. Used By module~~penf_stringify~~UsedByGraph module~penf_stringify penf_stringify module~penf~2 penf module~penf_stringify->module~penf~2 module~penf penf module~penf_stringify->module~penf module~penf~3 penf module~penf_stringify->module~penf~3 module~befor64~2 befor64 module~penf->module~befor64~2 module~stringifor stringifor module~penf->module~stringifor module~befor64_pack_data_m~2 befor64_pack_data_m module~penf->module~befor64_pack_data_m~2 program~test_all test_all module~penf->program~test_all module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t program~test_all~2 test_all module~penf->program~test_all~2 module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t program~test_driver Test_Driver module~befor64~2->program~test_driver program~free free module~stringifor->program~free program~greater_than greater_than module~stringifor->program~greater_than program~lower_than lower_than module~stringifor->program~lower_than program~read_lines read_lines module~stringifor->program~read_lines program~io_basic io_basic module~stringifor->program~io_basic program~startcase startcase module~stringifor->program~startcase program~join join module~stringifor->program~join program~count_string count_string module~stringifor->program~count_string program~is_digit is_digit module~stringifor->program~is_digit program~concatenation concatenation module~stringifor->program~concatenation program~slen slen module~stringifor->program~slen program~insert insert module~stringifor->program~insert program~io_formatted io_formatted module~stringifor->program~io_formatted program~unescape unescape module~stringifor->program~unescape program~sadjustlr sadjustlr module~stringifor->program~sadjustlr program~swapcase swapcase module~stringifor->program~swapcase program~csv_naive_parser csv_naive_parser module~stringifor->program~csv_naive_parser program~strim strim module~stringifor->program~strim program~reverse reverse module~stringifor->program~reverse program~read_line read_line module~stringifor->program~read_line program~is_integer is_integer module~stringifor->program~is_integer program~start_end start_end module~stringifor->program~start_end program~is_number is_number module~stringifor->program~is_number program~unique unique module~stringifor->program~unique program~is_real is_real module~stringifor->program~is_real program~upper_lower upper_lower module~stringifor->program~upper_lower program~write_file write_file module~stringifor->program~write_file program~sscan sscan module~stringifor->program~sscan program~assignments assignments module~stringifor->program~assignments program~escape escape module~stringifor->program~escape program~partition partition module~stringifor->program~partition program~basename_dir basename_dir module~stringifor->program~basename_dir program~to_number to_number module~stringifor->program~to_number program~equal equal module~stringifor->program~equal program~sindex sindex module~stringifor->program~sindex program~read_file read_file module~stringifor->program~read_file program~replace replace module~stringifor->program~replace program~not_equal not_equal module~stringifor->program~not_equal program~slice slice module~stringifor->program~slice program~snakecase snakecase module~stringifor->program~snakecase program~extension extension module~stringifor->program~extension program~srepeat srepeat module~stringifor->program~srepeat program~search search module~stringifor->program~search program~strip strip module~stringifor->program~strip program~fill fill module~stringifor->program~fill program~lower_equal_than lower_equal_than module~stringifor->program~lower_equal_than program~greater_equal_than greater_equal_than module~stringifor->program~greater_equal_than program~write_lines write_lines module~stringifor->program~write_lines program~decode decode module~stringifor->program~decode program~sverify sverify module~stringifor->program~sverify program~camelcase camelcase module~stringifor->program~camelcase program~capitalize capitalize module~stringifor->program~capitalize program~encode encode module~stringifor->program~encode program~split split module~stringifor->program~split module~stringifor_string_t->module~stringifor module~befor64_pack_data_m->module~befor64~2 module~befor64_pack_data_m->module~befor64 var panmodulepenf_stringifyUsedByGraph = svgPanZoom('#modulepenf_stringifyUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface str Convert number (real and integer) to string (number to string type casting). private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. public interface cton Convert string to number (real and integer, string to number type casting). private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer. Functions private elemental function strf_R16P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_R16P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R16P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Converting real array to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private function ctor_R16P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Description Convert string to real. private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. private elemental function bstr_R16P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bctor_R16P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Convert bit-string to real. private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer.","tags":"","loc":"module/penf_stringify.html","title":"penf_stringify – StringiFor"},{"text":"Uses: penf_global_parameters_variables penf_b_size penf_stringify module~~penf~~UsesGraph module~penf penf module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_stringify penf_stringify module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Portability Environment for Fortran poor people. PENF PENF, Portability Environment for Fortran poor people A KISS library for exploiting codes portability for modern (2003+) Fortran projects. PENF is a pure Fortran (KISS) library for achieving portable codes for modern Fortran projects; PENF provides many number-to-string and viceversa facilities; PENF is Fortran 2003+ standard compliant; PENF is a Free, Open Source Project. Table of Contents What is PENF? Main features Copyrights Documentation A Taste of PENF Issues Compiler Support What is PENF? Fortran is the most popular programming language for scientific computing. With Fortran it is quite simple obtain fast code and manage large multidimensional array. Because Fortran permits the achievement of high performance it is also used on great range of different computer-architectures, and often on the fastest supercomputer in the world. Therefore Fortran programs must be portable : portability means that the code will give the same results on every different computer-architectures. One of the most important goal of the numeric code is to control the numeric error due to finite precision of numerical operations. Fortran uses the IEEE representations. Integers and reals (floating point) are represented with a finite precision. So when the code computes an operation it has a truncation error due to the truncation of the numerical finite representations. For numerical and more in general scientific applications this source of errors must be controlled. The programmer must know which is the precision associated to the code variables. Before the standard Fortran 90/95 there are not any way to select the precision of the numerical variables in a portable fashion. Modern Fortran standards (2003+) have introduced better support for codes portability. With the possibility to specify a kind parameter for variables, the standard Fortran 90+ makes available useful functions to select the kind precision in a portable parametric way. Using these functions the programmer can accurately control the precision of its own variables in a portable manner. PENF module provides an effective KISS library to achieve portability and concurrently it provides many tools to handles parametrized numbers. Go to Top Main features The library provides portable kind-parameters and many useful procedures to deal with them: integer and reals parameters for 1,2,4,8,16 bytes-like representations; integer and real formats definitions for all parameters; integer and real minimum maximum representable numbers; number-to-string and string-to-number casting procedures; endianism procedures checking. Any feature request is welcome. Go to Top Copyrights PENF is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to PENF is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the PENF documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of PENF To be written. Go to Top Used By module~~penf~~UsedByGraph module~penf penf module~befor64~2 befor64 module~penf->module~befor64~2 module~stringifor stringifor module~penf->module~stringifor module~befor64_pack_data_m~2 befor64_pack_data_m module~penf->module~befor64_pack_data_m~2 program~test_all test_all module~penf->program~test_all module~stringifor_string_t stringifor_string_t module~penf->module~stringifor_string_t program~test_all~2 test_all module~penf->program~test_all~2 module~befor64 befor64 module~penf->module~befor64 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t program~test_driver Test_Driver module~befor64~2->program~test_driver program~free free module~stringifor->program~free program~greater_than greater_than module~stringifor->program~greater_than program~lower_than lower_than module~stringifor->program~lower_than program~read_lines read_lines module~stringifor->program~read_lines program~io_basic io_basic module~stringifor->program~io_basic program~startcase startcase module~stringifor->program~startcase program~join join module~stringifor->program~join program~count_string count_string module~stringifor->program~count_string program~is_digit is_digit module~stringifor->program~is_digit program~concatenation concatenation module~stringifor->program~concatenation program~slen slen module~stringifor->program~slen program~insert insert module~stringifor->program~insert program~io_formatted io_formatted module~stringifor->program~io_formatted program~unescape unescape module~stringifor->program~unescape program~sadjustlr sadjustlr module~stringifor->program~sadjustlr program~swapcase swapcase module~stringifor->program~swapcase program~csv_naive_parser csv_naive_parser module~stringifor->program~csv_naive_parser program~strim strim module~stringifor->program~strim program~reverse reverse module~stringifor->program~reverse program~read_line read_line module~stringifor->program~read_line program~is_integer is_integer module~stringifor->program~is_integer program~start_end start_end module~stringifor->program~start_end program~is_number is_number module~stringifor->program~is_number program~unique unique module~stringifor->program~unique program~is_real is_real module~stringifor->program~is_real program~upper_lower upper_lower module~stringifor->program~upper_lower program~write_file write_file module~stringifor->program~write_file program~sscan sscan module~stringifor->program~sscan program~assignments assignments module~stringifor->program~assignments program~escape escape module~stringifor->program~escape program~partition partition module~stringifor->program~partition program~basename_dir basename_dir module~stringifor->program~basename_dir program~to_number to_number module~stringifor->program~to_number program~equal equal module~stringifor->program~equal program~sindex sindex module~stringifor->program~sindex program~read_file read_file module~stringifor->program~read_file program~replace replace module~stringifor->program~replace program~not_equal not_equal module~stringifor->program~not_equal program~slice slice module~stringifor->program~slice program~snakecase snakecase module~stringifor->program~snakecase program~extension extension module~stringifor->program~extension program~srepeat srepeat module~stringifor->program~srepeat program~search search module~stringifor->program~search program~strip strip module~stringifor->program~strip program~fill fill module~stringifor->program~fill program~lower_equal_than lower_equal_than module~stringifor->program~lower_equal_than program~greater_equal_than greater_equal_than module~stringifor->program~greater_equal_than program~write_lines write_lines module~stringifor->program~write_lines program~decode decode module~stringifor->program~decode program~sverify sverify module~stringifor->program~sverify program~camelcase camelcase module~stringifor->program~camelcase program~capitalize capitalize module~stringifor->program~capitalize program~encode encode module~stringifor->program~encode program~split split module~stringifor->program~split module~stringifor_string_t->module~stringifor module~befor64_pack_data_m->module~befor64~2 module~befor64_pack_data_m->module~befor64 var panmodulepenfUsedByGraph = svgPanZoom('#modulepenfUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface digit Compute the number of digits in decimal base of the input integer. private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Functions private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Subroutines public subroutine check_endian () Arguments None Description Check the type of bit ordering (big or little endian) of the running architecture. public subroutine penf_init () Arguments None Description Initialize PENF's variables that are not initialized into the definition specification. public subroutine penf_print (unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print to the specified unit the PENF's environment data.","tags":"","loc":"module/penf.html","title":"penf – StringiFor"},{"text":"Uses: penf module~~befor64_pack_data_m~~UsesGraph module~befor64_pack_data_m befor64_pack_data_m module~penf penf module~penf->module~befor64_pack_data_m module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_stringify penf_stringify module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulebefor64_pack_data_mUsesGraph = svgPanZoom('#modulebefor64_pack_data_mUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. KISS library for packing heterogeneous data into single (homogeneous) packed one. Used By module~~befor64_pack_data_m~~UsedByGraph module~befor64_pack_data_m befor64_pack_data_m module~befor64~2 befor64 module~befor64_pack_data_m->module~befor64~2 module~befor64 befor64 module~befor64_pack_data_m->module~befor64 module~stringifor_string_t stringifor_string_t module~befor64~2->module~stringifor_string_t program~test_driver Test_Driver module~befor64~2->program~test_driver module~stringifor stringifor module~stringifor_string_t->module~stringifor program~free free module~stringifor->program~free program~greater_than greater_than module~stringifor->program~greater_than program~lower_than lower_than module~stringifor->program~lower_than program~read_lines read_lines module~stringifor->program~read_lines program~io_basic io_basic module~stringifor->program~io_basic program~startcase startcase module~stringifor->program~startcase program~join join module~stringifor->program~join program~count_string count_string module~stringifor->program~count_string program~is_digit is_digit module~stringifor->program~is_digit program~concatenation concatenation module~stringifor->program~concatenation program~slen slen module~stringifor->program~slen program~insert insert module~stringifor->program~insert program~io_formatted io_formatted module~stringifor->program~io_formatted program~unescape unescape module~stringifor->program~unescape program~sadjustlr sadjustlr module~stringifor->program~sadjustlr program~swapcase swapcase module~stringifor->program~swapcase program~csv_naive_parser csv_naive_parser module~stringifor->program~csv_naive_parser program~strim strim module~stringifor->program~strim program~reverse reverse module~stringifor->program~reverse program~read_line read_line module~stringifor->program~read_line program~is_integer is_integer module~stringifor->program~is_integer program~start_end start_end module~stringifor->program~start_end program~is_number is_number module~stringifor->program~is_number program~unique unique module~stringifor->program~unique program~is_real is_real module~stringifor->program~is_real program~upper_lower upper_lower module~stringifor->program~upper_lower program~write_file write_file module~stringifor->program~write_file program~sscan sscan module~stringifor->program~sscan program~assignments assignments module~stringifor->program~assignments program~escape escape module~stringifor->program~escape program~partition partition module~stringifor->program~partition program~basename_dir basename_dir module~stringifor->program~basename_dir program~to_number to_number module~stringifor->program~to_number program~equal equal module~stringifor->program~equal program~sindex sindex module~stringifor->program~sindex program~read_file read_file module~stringifor->program~read_file program~replace replace module~stringifor->program~replace program~not_equal not_equal module~stringifor->program~not_equal program~slice slice module~stringifor->program~slice program~snakecase snakecase module~stringifor->program~snakecase program~extension extension module~stringifor->program~extension program~srepeat srepeat module~stringifor->program~srepeat program~search search module~stringifor->program~search program~strip strip module~stringifor->program~strip program~fill fill module~stringifor->program~fill program~lower_equal_than lower_equal_than module~stringifor->program~lower_equal_than program~greater_equal_than greater_equal_than module~stringifor->program~greater_equal_than program~write_lines write_lines module~stringifor->program~write_lines program~decode decode module~stringifor->program~decode program~sverify sverify module~stringifor->program~sverify program~camelcase camelcase module~stringifor->program~camelcase program~capitalize capitalize module~stringifor->program~capitalize program~encode encode module~stringifor->program~encode program~split split module~stringifor->program~split Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface pack_data Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Subroutines private pure subroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array.","tags":"","loc":"module/befor64_pack_data_m.html","title":"befor64_pack_data_m – StringiFor"},{"text":"Uses: penf befor64_pack_data_m module~~befor64~2~~UsesGraph module~befor64~2 befor64 module~befor64_pack_data_m befor64_pack_data_m module~befor64_pack_data_m->module~befor64~2 module~penf penf module~penf->module~befor64~2 module~penf->module~befor64_pack_data_m module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_stringify penf_stringify module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulebefor642UsesGraph = svgPanZoom('#modulebefor642UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. BeFoR64, Base64 encoding/decoding library for FoRtran poor people. Used By module~~befor64~2~~UsedByGraph module~befor64~2 befor64 module~stringifor_string_t stringifor_string_t module~befor64~2->module~stringifor_string_t program~test_driver Test_Driver module~befor64~2->program~test_driver module~stringifor stringifor module~stringifor_string_t->module~stringifor program~free free module~stringifor->program~free program~greater_than greater_than module~stringifor->program~greater_than program~lower_than lower_than module~stringifor->program~lower_than program~read_lines read_lines module~stringifor->program~read_lines program~io_basic io_basic module~stringifor->program~io_basic program~startcase startcase module~stringifor->program~startcase program~join join module~stringifor->program~join program~count_string count_string module~stringifor->program~count_string program~is_digit is_digit module~stringifor->program~is_digit program~concatenation concatenation module~stringifor->program~concatenation program~slen slen module~stringifor->program~slen program~insert insert module~stringifor->program~insert program~io_formatted io_formatted module~stringifor->program~io_formatted program~unescape unescape module~stringifor->program~unescape program~sadjustlr sadjustlr module~stringifor->program~sadjustlr program~swapcase swapcase module~stringifor->program~swapcase program~csv_naive_parser csv_naive_parser module~stringifor->program~csv_naive_parser program~strim strim module~stringifor->program~strim program~reverse reverse module~stringifor->program~reverse program~read_line read_line module~stringifor->program~read_line program~is_integer is_integer module~stringifor->program~is_integer program~start_end start_end module~stringifor->program~start_end program~is_number is_number module~stringifor->program~is_number program~unique unique module~stringifor->program~unique program~is_real is_real module~stringifor->program~is_real program~upper_lower upper_lower module~stringifor->program~upper_lower program~write_file write_file module~stringifor->program~write_file program~sscan sscan module~stringifor->program~sscan program~assignments assignments module~stringifor->program~assignments program~escape escape module~stringifor->program~escape program~partition partition module~stringifor->program~partition program~basename_dir basename_dir module~stringifor->program~basename_dir program~to_number to_number module~stringifor->program~to_number program~equal equal module~stringifor->program~equal program~sindex sindex module~stringifor->program~sindex program~read_file read_file module~stringifor->program~read_file program~replace replace module~stringifor->program~replace program~not_equal not_equal module~stringifor->program~not_equal program~slice slice module~stringifor->program~slice program~snakecase snakecase module~stringifor->program~snakecase program~extension extension module~stringifor->program~extension program~srepeat srepeat module~stringifor->program~srepeat program~search search module~stringifor->program~search program~strip strip module~stringifor->program~strip program~fill fill module~stringifor->program~fill program~lower_equal_than lower_equal_than module~stringifor->program~lower_equal_than program~greater_equal_than greater_equal_than module~stringifor->program~greater_equal_than program~write_lines write_lines module~stringifor->program~write_lines program~decode decode module~stringifor->program~decode program~sverify sverify module~stringifor->program~sverify program~camelcase camelcase module~stringifor->program~camelcase program~capitalize capitalize module~stringifor->program~capitalize program~encode encode module~stringifor->program~encode program~split split module~stringifor->program~split Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: is_b64_initialized = .false. Flag for checking the initialization of the library. character(len=64), private :: base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" Base64 alphabet. Interfaces public interface b64_encode Encode numbers (integer and real) to base64. private pure subroutine b64_encode_R8 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). private pure subroutine b64_encode_R8_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). private pure subroutine b64_encode_R4 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). private pure subroutine b64_encode_R4_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). private pure subroutine b64_encode_I8 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). private pure subroutine b64_encode_I8_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). private pure subroutine b64_encode_I4 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). private pure subroutine b64_encode_I4_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). private pure subroutine b64_encode_I2 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). private pure subroutine b64_encode_I2_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). private pure subroutine b64_encode_I1 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). private pure subroutine b64_encode_I1_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). private pure subroutine b64_encode_string (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. private pure subroutine b64_encode_string_a (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64. public interface b64_encode_up Encode unlimited polymorphic variable to base64. public interface b64_encode_up () Arguments None Description Encode unlimited polymorphic variable to base64. private pure subroutine b64_encode_up_a (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64. public interface b64_decode Decode numbers (integer and real) from base64. private elemental subroutine b64_decode_R8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). private pure subroutine b64_decode_R8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). private elemental subroutine b64_decode_R4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). private pure subroutine b64_decode_R4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). private elemental subroutine b64_decode_I8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). private pure subroutine b64_decode_I8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). private elemental subroutine b64_decode_I4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). private pure subroutine b64_decode_I4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). private elemental subroutine b64_decode_I2 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). private pure subroutine b64_decode_I2_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). private elemental subroutine b64_decode_I1 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). private pure subroutine b64_decode_I1_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). private elemental subroutine b64_decode_string (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. private pure subroutine b64_decode_string_a (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings. public interface b64_decode_up Decode unlimited polymorphic variable from base64. public interface b64_decode_up () Arguments None Description Decode unlimited polymorphic variable from base64. private subroutine b64_decode_up_a (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64. Subroutines public subroutine b64_init () Arguments None Description Initialize the BeFoR64 library. private pure subroutine encode_bits (bits, padd, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: bits (1:) Bits to be encoded. integer(kind=I4P), intent(in) :: padd Number of padding characters ('='). character(len=*), intent(out) :: code Characters code. Description Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). private pure subroutine decode_bits (code, bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Characters code. integer(kind=I1P), intent(out) :: bits (1:) Bits decoded. Description Decode a base64 string into a sequence of bits stream. public subroutine b64_encode_up (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode an unlimited polymorphic scalar to base64. private pure subroutine b64_encode_up_a (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64. public subroutine b64_decode_up (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. class(*), intent(out) :: up Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic scalar from base64. private subroutine b64_decode_up_a (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64. private pure subroutine b64_encode_R16 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R16P). private pure subroutine b64_encode_R8 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). private pure subroutine b64_encode_R4 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). private pure subroutine b64_encode_I8 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). private pure subroutine b64_encode_I4 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). private pure subroutine b64_encode_I2 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). private pure subroutine b64_encode_I1 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). private pure subroutine b64_encode_string (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. private pure subroutine b64_encode_R16_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R16P). private pure subroutine b64_encode_R8_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). private pure subroutine b64_encode_R4_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). private pure subroutine b64_encode_I8_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). private pure subroutine b64_encode_I4_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). private pure subroutine b64_encode_I2_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). private pure subroutine b64_encode_I1_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). private pure subroutine b64_encode_string_a (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64. private elemental subroutine b64_decode_R16 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R16P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R16P). private elemental subroutine b64_decode_R8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). private elemental subroutine b64_decode_R4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). private elemental subroutine b64_decode_I8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). private elemental subroutine b64_decode_I4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). private elemental subroutine b64_decode_I2 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). private elemental subroutine b64_decode_I1 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). private elemental subroutine b64_decode_string (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. private pure subroutine b64_decode_R16_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R16P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R16P). private pure subroutine b64_decode_R8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). private pure subroutine b64_decode_R4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). private pure subroutine b64_decode_I8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). private pure subroutine b64_decode_I4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). private pure subroutine b64_decode_I2_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). private pure subroutine b64_decode_I1_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). private pure subroutine b64_decode_string_a (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings. public subroutine autotest () Arguments None Description Procedure for autotesting the library functionalities.","tags":"","loc":"module/befor64~2.html","title":"befor64 – StringiFor"},{"text":"PENF global (exposed) parameters and variables. Note All module defined entities are public. Variables Type Visibility Attributes Name Initial logical, public :: is_initialized = .false. Check the initialization of some variables that must be initialized. integer, public, parameter :: endianL = 1 Little endian parameter. integer, public, parameter :: endianB = 0 Big endian parameter. integer, public :: endian = endianL Bit ordering: Little endian (endianL), or Big endian (endianB). integer, public, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, public, parameter :: R8P = selected_real_kind(15, 307) 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision. character(len=*), public, parameter :: FR16P = '(E23.15E3)' Output format for kind=R16P real. character(len=*), public, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P real. character(len=*), public, parameter :: FR4P = '(E13.6E2)' Output format for kind=R4P real. character(len=*), public, parameter :: FR_P = FR8P Output format for kind=R_P real. character(len=*), public, parameter :: FI8P = '(I20)' Output format for kind=I8P integer. character(len=*), public, parameter :: FI8PZP = '(I20.19)' Output format for kind=I8P integer with zero prefixing. character(len=*), public, parameter :: FI4P = '(I11)' Output format for kind=I4P integer. character(len=*), public, parameter :: FI4PZP = '(I11.10)' Output format for kind=I4P integer with zero prefixing. character(len=*), public, parameter :: FI2P = '(I6)' Output format for kind=I2P integer. character(len=*), public, parameter :: FI2PZP = '(I6.5)' Output format for kind=I2P integer with zero prefixing. character(len=*), public, parameter :: FI1P = '(I4)' Output format for kind=I1P integer. character(len=*), public, parameter :: FI1PZP = '(I4.3)' Output format for kind=I1P integer with zero prefixing. character(len=*), public, parameter :: FI_P = FI4P Output format for kind=I_P integer. character(len=*), public, parameter :: FI_PZP = FI4PZP Output format for kind=I_P integer with zero prefixing. integer, public, parameter :: DR16P = 23 Number of digits of output format FR16P. integer, public, parameter :: DR8P = 23 Number of digits of output format FR8P. integer, public, parameter :: DR4P = 13 Number of digits of output format FR4P. integer, public, parameter :: DR_P = DR8P Number of digits of output format FR_P. integer, public, parameter :: DI8P = 20 Number of digits of output format I8P. integer, public, parameter :: DI4P = 11 Number of digits of output format I4P. integer, public, parameter :: DI2P = 6 Number of digits of output format I2P. integer, public, parameter :: DI1P = 4 Number of digits of output format I1P. integer, public, parameter :: DI_P = DI4P Number of digits of output format I_P. integer, public, parameter :: REAL_KINDS_LIST (1:4) = [R16P, R8P, R4P, R_P] List of real kinds. character(len=*), public, parameter :: REAL_FORMATS_LIST (1:4) = [FR16P, FR8P, FR4P//' ', FR_P] List of real formats. integer, public, parameter :: INTEGER_KINDS_LIST (1:5) = [I8P, I4P, I2P, I1P, I_P] List of integer kinds. character(len=*), public, parameter :: INTEGER_FORMATS_LIST (1:5) = [FI8P, FI4P, FI2P//' ', FI1P//' ', FI_P] List of integer formats. real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) Minimum value of kind=R16P real. real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) Maximum value of kind=R16P real. real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) Minimum value of kind=R8P real. real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) Maximum value of kind=R8P real. real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) Minimum value of kind=R4P real. real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) Maximum value of kind=R4P real. real(kind=R_P), public, parameter :: MinR_P = MinR8P Minimum value of kind=R_P real. real(kind=R_P), public, parameter :: MaxR_P = MaxR8P Maximum value of kind=R_P real. integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) Minimum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) Minimum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) Minimum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) Minimum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MinI_P = MinI4P Minimum value of kind=I_P integer. integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) Maximum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) Maximum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) Maximum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) Maximum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MaxI_P = MaxI4P Maximum value of kind=I_P integer. real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) Smallest representable value of kind=R16P real. real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) Smallest representable value of kind=R8P real. real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) Smallest representable value of kind=R4P real. real(kind=R_P), public, parameter :: smallR_P = smallR8P Smallest representable value of kind=R_P real. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P, 1._R16P)-nearest(1._R16P, -1._R16P) Smallest representable difference of kind=R16P real. real(kind=R8P), public, parameter :: ZeroR8 = nearest(1._R8P, 1._R8P)-nearest(1._R8P, -1._R8P) Smallest representable difference of kind=R8P real. real(kind=R4P), public, parameter :: ZeroR4 = nearest(1._R4P, 1._R4P)-nearest(1._R4P, -1._R4P) Smallest representable difference of kind=R4P real. real(kind=R_P), public, parameter :: Zero = ZeroR8 Smallest representable difference of kind=R_P real. integer(kind=I2P), public :: BIR16P Number of bits of kind=R16P real. integer(kind=I1P), public :: BIR8P Number of bits of kind=R8P real. integer(kind=I1P), public :: BIR4P Number of bits of kind=R4P real. integer(kind=I1P), public :: BIR_P Number of bits of kind=R_P real. integer(kind=I2P), public :: BYR16P Number of bytes of kind=R16P real. integer(kind=I1P), public :: BYR8P Number of bytes of kind=R8P real. integer(kind=I1P), public :: BYR4P Number of bytes of kind=R4P real. integer(kind=I1P), public :: BYR_P Number of bytes of kind=R_P real. integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) Number of bits of kind=I8P integer. integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) Number of bits of kind=I4P integer. integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) Number of bits of kind=I2P integer. integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) Number of bits of kind=I1P integer. integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) Number of bits of kind=I_P integer. integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P Number of bytes of kind=I8P integer. integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P Number of bytes of kind=I4P integer. integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P Number of bytes of kind=I2P integer. integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P Number of bytes of kind=I1P integer. integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P Number of bytes of kind=I_P integer.","tags":"","loc":"module/penf_global_parameters_variables~2.html","title":"penf_global_parameters_variables – StringiFor"},{"text":"Uses: penf_global_parameters_variables module~~penf_b_size~~UsesGraph module~penf_b_size penf_b_size module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf_b_size Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF bit/byte size functions. Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. public interface byte_size Compute the number of bytes of a variable. private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable. Functions private elemental function bit_size_R16P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R16P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable.","tags":"","loc":"module/penf_b_size.html","title":"penf_b_size – StringiFor"},{"text":"Uses: iso_fortran_env penf_b_size penf_global_parameters_variables module~~penf_stringify~2~~UsesGraph module~penf_stringify~2 penf_stringify module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf_stringify~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify~2 module~penf_b_size~2->module~penf_stringify~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF string-to-number (and viceversa) facility. Interfaces public interface str Convert number (real and integer) to string (number to string type casting). private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. public interface cton Convert string to number (real and integer, string to number type casting). private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer. Functions private elemental function strf_R16P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_R16P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R16P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Converting real array to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private function ctor_R16P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Description Convert string to real. private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. private elemental function bstr_R16P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bctor_R16P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Convert bit-string to real. private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer.","tags":"","loc":"module/penf_stringify~2.html","title":"penf_stringify – StringiFor"},{"text":"Uses: penf_global_parameters_variables penf_b_size penf_stringify module~~penf~3~~UsesGraph module~penf~3 penf module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf~3 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_stringify penf_stringify module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf~3 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~3 iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Portability Environment for Fortran poor people. PENF PENF, Portability Environment for Fortran poor people A KISS library for exploiting codes portability for modern (2003+) Fortran projects. PENF is a pure Fortran (KISS) library for achieving portable codes for modern Fortran projects; PENF provides many number-to-string and viceversa facilities; PENF is Fortran 2003+ standard compliant; PENF is a Free, Open Source Project. Table of Contents What is PENF? Main features Copyrights Documentation A Taste of PENF Issues Compiler Support What is PENF? Fortran is the most popular programming language for scientific computing. With Fortran it is quite simple obtain fast code and manage large multidimensional array. Because Fortran permits the achievement of high performance it is also used on great range of different computer-architectures, and often on the fastest supercomputer in the world. Therefore Fortran programs must be portable : portability means that the code will give the same results on every different computer-architectures. One of the most important goal of the numeric code is to control the numeric error due to finite precision of numerical operations. Fortran uses the IEEE representations. Integers and reals (floating point) are represented with a finite precision. So when the code computes an operation it has a truncation error due to the truncation of the numerical finite representations. For numerical and more in general scientific applications this source of errors must be controlled. The programmer must know which is the precision associated to the code variables. Before the standard Fortran 90/95 there are not any way to select the precision of the numerical variables in a portable fashion. Modern Fortran standards (2003+) have introduced better support for codes portability. With the possibility to specify a kind parameter for variables, the standard Fortran 90+ makes available useful functions to select the kind precision in a portable parametric way. Using these functions the programmer can accurately control the precision of its own variables in a portable manner. PENF module provides an effective KISS library to achieve portability and concurrently it provides many tools to handles parametrized numbers. Go to Top Main features The library provides portable kind-parameters and many useful procedures to deal with them: integer and reals parameters for 1,2,4,8,16 bytes-like representations; integer and real formats definitions for all parameters; integer and real minimum maximum representable numbers; number-to-string and string-to-number casting procedures; endianism procedures checking. Any feature request is welcome. Go to Top Copyrights PENF is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to PENF is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the PENF documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of PENF To be written. Go to Top Interfaces public interface digit Compute the number of digits in decimal base of the input integer. private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Functions private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Subroutines public subroutine check_endian () Arguments None Description Check the type of bit ordering (big or little endian) of the running architecture. public subroutine penf_init () Arguments None Description Initialize PENF's variables that are not initialized into the definition specification. public subroutine penf_print (unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print to the specified unit the PENF's environment data.","tags":"","loc":"module/penf~3.html","title":"penf – StringiFor"},{"text":"PENF global (exposed) parameters and variables. Note All module defined entities are public. Variables Type Visibility Attributes Name Initial logical, public :: is_initialized = .false. Check the initialization of some variables that must be initialized. integer, public, parameter :: endianL = 1 Little endian parameter. integer, public, parameter :: endianB = 0 Big endian parameter. integer, public :: endian = endianL Bit ordering: Little endian (endianL), or Big endian (endianB). integer, public, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, public, parameter :: R8P = selected_real_kind(15, 307) 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R_P = R8P Default real precision. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I_P = I4P Default integer precision. character(len=*), public, parameter :: FR16P = '(E23.15E3)' Output format for kind=R16P real. character(len=*), public, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P real. character(len=*), public, parameter :: FR4P = '(E13.6E2)' Output format for kind=R4P real. character(len=*), public, parameter :: FR_P = FR8P Output format for kind=R_P real. character(len=*), public, parameter :: FI8P = '(I20)' Output format for kind=I8P integer. character(len=*), public, parameter :: FI8PZP = '(I20.19)' Output format for kind=I8P integer with zero prefixing. character(len=*), public, parameter :: FI4P = '(I11)' Output format for kind=I4P integer. character(len=*), public, parameter :: FI4PZP = '(I11.10)' Output format for kind=I4P integer with zero prefixing. character(len=*), public, parameter :: FI2P = '(I6)' Output format for kind=I2P integer. character(len=*), public, parameter :: FI2PZP = '(I6.5)' Output format for kind=I2P integer with zero prefixing. character(len=*), public, parameter :: FI1P = '(I4)' Output format for kind=I1P integer. character(len=*), public, parameter :: FI1PZP = '(I4.3)' Output format for kind=I1P integer with zero prefixing. character(len=*), public, parameter :: FI_P = FI4P Output format for kind=I_P integer. character(len=*), public, parameter :: FI_PZP = FI4PZP Output format for kind=I_P integer with zero prefixing. integer, public, parameter :: DR16P = 23 Number of digits of output format FR16P. integer, public, parameter :: DR8P = 23 Number of digits of output format FR8P. integer, public, parameter :: DR4P = 13 Number of digits of output format FR4P. integer, public, parameter :: DR_P = DR8P Number of digits of output format FR_P. integer, public, parameter :: DI8P = 20 Number of digits of output format I8P. integer, public, parameter :: DI4P = 11 Number of digits of output format I4P. integer, public, parameter :: DI2P = 6 Number of digits of output format I2P. integer, public, parameter :: DI1P = 4 Number of digits of output format I1P. integer, public, parameter :: DI_P = DI4P Number of digits of output format I_P. integer, public, parameter :: REAL_KINDS_LIST (1:4) = [R16P, R8P, R4P, R_P] List of real kinds. character(len=*), public, parameter :: REAL_FORMATS_LIST (1:4) = [FR16P, FR8P, FR4P//' ', FR_P] List of real formats. integer, public, parameter :: INTEGER_KINDS_LIST (1:5) = [I8P, I4P, I2P, I1P, I_P] List of integer kinds. character(len=*), public, parameter :: INTEGER_FORMATS_LIST (1:5) = [FI8P, FI4P, FI2P//' ', FI1P//' ', FI_P] List of integer formats. real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) Minimum value of kind=R16P real. real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) Maximum value of kind=R16P real. real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) Minimum value of kind=R8P real. real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) Maximum value of kind=R8P real. real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) Minimum value of kind=R4P real. real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) Maximum value of kind=R4P real. real(kind=R_P), public, parameter :: MinR_P = MinR8P Minimum value of kind=R_P real. real(kind=R_P), public, parameter :: MaxR_P = MaxR8P Maximum value of kind=R_P real. integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) Minimum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) Minimum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) Minimum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) Minimum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MinI_P = MinI4P Minimum value of kind=I_P integer. integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) Maximum value of kind=I8P integer. integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) Maximum value of kind=I4P integer. integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) Maximum value of kind=I2P integer. integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) Maximum value of kind=I1P integer. integer(kind=I_P), public, parameter :: MaxI_P = MaxI4P Maximum value of kind=I_P integer. real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) Smallest representable value of kind=R16P real. real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) Smallest representable value of kind=R8P real. real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) Smallest representable value of kind=R4P real. real(kind=R_P), public, parameter :: smallR_P = smallR8P Smallest representable value of kind=R_P real. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P, 1._R16P)-nearest(1._R16P, -1._R16P) Smallest representable difference of kind=R16P real. real(kind=R8P), public, parameter :: ZeroR8 = nearest(1._R8P, 1._R8P)-nearest(1._R8P, -1._R8P) Smallest representable difference of kind=R8P real. real(kind=R4P), public, parameter :: ZeroR4 = nearest(1._R4P, 1._R4P)-nearest(1._R4P, -1._R4P) Smallest representable difference of kind=R4P real. real(kind=R_P), public, parameter :: Zero = ZeroR8 Smallest representable difference of kind=R_P real. integer(kind=I2P), public :: BIR16P Number of bits of kind=R16P real. integer(kind=I1P), public :: BIR8P Number of bits of kind=R8P real. integer(kind=I1P), public :: BIR4P Number of bits of kind=R4P real. integer(kind=I1P), public :: BIR_P Number of bits of kind=R_P real. integer(kind=I2P), public :: BYR16P Number of bytes of kind=R16P real. integer(kind=I1P), public :: BYR8P Number of bytes of kind=R8P real. integer(kind=I1P), public :: BYR4P Number of bytes of kind=R4P real. integer(kind=I1P), public :: BYR_P Number of bytes of kind=R_P real. integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) Number of bits of kind=I8P integer. integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) Number of bits of kind=I4P integer. integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) Number of bits of kind=I2P integer. integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) Number of bits of kind=I1P integer. integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) Number of bits of kind=I_P integer. integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P Number of bytes of kind=I8P integer. integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P Number of bytes of kind=I4P integer. integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P Number of bytes of kind=I2P integer. integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P Number of bytes of kind=I1P integer. integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P Number of bytes of kind=I_P integer.","tags":"","loc":"module/penf_global_parameters_variables.html","title":"penf_global_parameters_variables – StringiFor"},{"text":"Uses: penf_global_parameters_variables module~~penf_b_size~3~~UsesGraph module~penf_b_size~3 penf_b_size module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf_b_size~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF bit/byte size functions. Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. public interface byte_size Compute the number of bytes of a variable. private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable. Functions private elemental function bit_size_R16P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R8P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_R4P (i) result(bits) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Description Compute the number of bits of a real variable. private elemental function bit_size_chr (i) result(bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Description Compute the number of bits of a character variable. private elemental function byte_size_I8P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I4P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I2P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_I1P (i) result(bytes) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Description Compute the number of bytes of an integer variable. private elemental function byte_size_R16P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R8P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_R4P (i) result(bytes) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Description Compute the number of bytes of a real variable. private elemental function byte_size_chr (i) result(bytes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Description Compute the number of bytes of a character variable.","tags":"","loc":"module/penf_b_size~3.html","title":"penf_b_size – StringiFor"},{"text":"Uses: iso_fortran_env penf_b_size penf_global_parameters_variables module~~penf_stringify~3~~UsesGraph module~penf_stringify~3 penf_stringify module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf_stringify~3 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify~3 module~penf_b_size~2->module~penf_stringify~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF string-to-number (and viceversa) facility. Interfaces public interface str Convert number (real and integer) to string (number to string type casting). private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. public interface cton Convert string to number (real and integer, string to number type casting). private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer. Functions private elemental function strf_R16P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. private elemental function strf_R8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function strf_R4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function strf_I8P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I4P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I2P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Description Convert integer to string. private elemental function strf_I1P (fm, n) result(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Description Convert integer to string. private elemental function str_R16P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR16P) Returned string containing input number. Description Convert real to string. private elemental function str_R8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR8P) Returned string containing input number. Description Convert real to string. private elemental function str_R4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DR4P) Returned string containing input number. Description Convert real to string. private elemental function str_I8P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_I4P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Converting integer to string. private elemental function str_I2P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_I1P (n, no_sign) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string. private elemental function str_bol (n) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Description Convert logical to string. private pure function str_a_R16P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Converting real array to string. private pure function str_a_R8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_R4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert real array to string. private pure function str_a_I8P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I4P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I2P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private pure function str_a_I1P (n, no_sign, delimiters) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Description Convert integer array to string. private elemental function strz_I8P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Description Converting integer to string, prefixing with the right number of zeros. private elemental function strz_I4P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I2P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private elemental function strz_I1P (n, nz_pad) result(str) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Description Convert integer to string, prefixing with the right number of zeros. private function ctor_R16P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Description Convert string to real. private function ctor_R8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Description Convert string to real. private function ctor_R4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Description Convert string to real. private function ctoi_I8P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Description Convert string to integer. private function ctoi_I4P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Description Convert string to integer. private function ctoi_I2P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Description Convert string to integer. private function ctoi_I1P (str, knd, pref, error) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Description Convert string to integer. private elemental function bstr_R16P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R8P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_R4P (n) result(bstr) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert real to string of bits. private elemental function bstr_I8P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I4P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I2P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bstr_I1P (n) result(bstr) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Description Convert integer to string of bits. private elemental function bctor_R16P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Description Convert bit-string to real. private elemental function bctor_R8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Description Convert bit-string to real. private elemental function bctor_R4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Description Convert bit-string to real. private elemental function bctoi_I8P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I4P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I2P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Description Convert bit-string to integer. private elemental function bctoi_I1P (bstr, knd) result(n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Description Convert bit-string to integer.","tags":"","loc":"module/penf_stringify~3.html","title":"penf_stringify – StringiFor"},{"text":"Uses: penf_global_parameters_variables penf_b_size penf_stringify module~~penf~2~~UsesGraph module~penf~2 penf module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf~2 module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_stringify penf_stringify module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf~2 module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf~2 iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Portability Environment for Fortran poor people. PENF PENF, Portability Environment for Fortran poor people A KISS library for exploiting codes portability for modern (2003+) Fortran projects. PENF is a pure Fortran (KISS) library for achieving portable codes for modern Fortran projects; PENF provides many number-to-string and viceversa facilities; PENF is Fortran 2003+ standard compliant; PENF is a Free, Open Source Project. Table of Contents What is PENF? Main features Copyrights Documentation A Taste of PENF Issues Compiler Support What is PENF? Fortran is the most popular programming language for scientific computing. With Fortran it is quite simple obtain fast code and manage large multidimensional array. Because Fortran permits the achievement of high performance it is also used on great range of different computer-architectures, and often on the fastest supercomputer in the world. Therefore Fortran programs must be portable : portability means that the code will give the same results on every different computer-architectures. One of the most important goal of the numeric code is to control the numeric error due to finite precision of numerical operations. Fortran uses the IEEE representations. Integers and reals (floating point) are represented with a finite precision. So when the code computes an operation it has a truncation error due to the truncation of the numerical finite representations. For numerical and more in general scientific applications this source of errors must be controlled. The programmer must know which is the precision associated to the code variables. Before the standard Fortran 90/95 there are not any way to select the precision of the numerical variables in a portable fashion. Modern Fortran standards (2003+) have introduced better support for codes portability. With the possibility to specify a kind parameter for variables, the standard Fortran 90+ makes available useful functions to select the kind precision in a portable parametric way. Using these functions the programmer can accurately control the precision of its own variables in a portable manner. PENF module provides an effective KISS library to achieve portability and concurrently it provides many tools to handles parametrized numbers. Go to Top Main features The library provides portable kind-parameters and many useful procedures to deal with them: integer and reals parameters for 1,2,4,8,16 bytes-like representations; integer and real formats definitions for all parameters; integer and real minimum maximum representable numbers; number-to-string and string-to-number casting procedures; endianism procedures checking. Any feature request is welcome. Go to Top Copyrights PENF is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to PENF is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the PENF documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of PENF To be written. Go to Top Interfaces public interface digit Compute the number of digits in decimal base of the input integer. private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Functions private elemental function digit_I8 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I4 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I2 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. private elemental function digit_I1 (n) result(digit) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Description Compute the number of digits in decimal base of the input integer. Subroutines public subroutine check_endian () Arguments None Description Check the type of bit ordering (big or little endian) of the running architecture. public subroutine penf_init () Arguments None Description Initialize PENF's variables that are not initialized into the definition specification. public subroutine penf_print (unit, pref, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Description Print to the specified unit the PENF's environment data.","tags":"","loc":"module/penf~2.html","title":"penf – StringiFor"},{"text":"Uses: penf stringifor_string_t module~~stringifor~~UsesGraph module~stringifor stringifor module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_stringify penf_stringify module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulestringiforUsesGraph = svgPanZoom('#modulestringiforUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor, Strings Fortran, yet another stringify Fortran module Used By module~~stringifor~~UsedByGraph module~stringifor stringifor program~free free module~stringifor->program~free program~greater_than greater_than module~stringifor->program~greater_than program~lower_than lower_than module~stringifor->program~lower_than program~read_lines read_lines module~stringifor->program~read_lines program~io_basic io_basic module~stringifor->program~io_basic program~startcase startcase module~stringifor->program~startcase program~join join module~stringifor->program~join program~count_string count_string module~stringifor->program~count_string program~is_digit is_digit module~stringifor->program~is_digit program~concatenation concatenation module~stringifor->program~concatenation program~slen slen module~stringifor->program~slen program~insert insert module~stringifor->program~insert program~io_formatted io_formatted module~stringifor->program~io_formatted program~unescape unescape module~stringifor->program~unescape program~sadjustlr sadjustlr module~stringifor->program~sadjustlr program~swapcase swapcase module~stringifor->program~swapcase program~csv_naive_parser csv_naive_parser module~stringifor->program~csv_naive_parser program~strim strim module~stringifor->program~strim program~reverse reverse module~stringifor->program~reverse program~read_line read_line module~stringifor->program~read_line program~is_integer is_integer module~stringifor->program~is_integer program~start_end start_end module~stringifor->program~start_end program~is_number is_number module~stringifor->program~is_number program~unique unique module~stringifor->program~unique program~is_real is_real module~stringifor->program~is_real program~upper_lower upper_lower module~stringifor->program~upper_lower program~write_file write_file module~stringifor->program~write_file program~sscan sscan module~stringifor->program~sscan program~assignments assignments module~stringifor->program~assignments program~escape escape module~stringifor->program~escape program~partition partition module~stringifor->program~partition program~basename_dir basename_dir module~stringifor->program~basename_dir program~to_number to_number module~stringifor->program~to_number program~equal equal module~stringifor->program~equal program~sindex sindex module~stringifor->program~sindex program~read_file read_file module~stringifor->program~read_file program~replace replace module~stringifor->program~replace program~not_equal not_equal module~stringifor->program~not_equal program~slice slice module~stringifor->program~slice program~snakecase snakecase module~stringifor->program~snakecase program~extension extension module~stringifor->program~extension program~srepeat srepeat module~stringifor->program~srepeat program~search search module~stringifor->program~search program~strip strip module~stringifor->program~strip program~fill fill module~stringifor->program~fill program~lower_equal_than lower_equal_than module~stringifor->program~lower_equal_than program~greater_equal_than greater_equal_than module~stringifor->program~greater_equal_than program~write_lines write_lines module~stringifor->program~write_lines program~decode decode module~stringifor->program~decode program~sverify sverify module~stringifor->program~sverify program~camelcase camelcase module~stringifor->program~camelcase program~capitalize capitalize module~stringifor->program~capitalize program~encode encode module~stringifor->program~encode program~split split module~stringifor->program~split Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface adjustl Builtin adjustl overloading. public pure function sadjustl_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Left adjust a string by removing leading spaces (character output). public interface adjustr Builtin adjustr overloading. public pure function sadjustr_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Right adjust a string by removing leading spaces (character output). public interface count Builtin count overloading. private elemental function count_substring (string_, substring) result(No) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_ String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Description Count the number of occurences of a substring into a string. public interface index Builtin index overloading. public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_character_string (string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public interface len Builtin len overloading. public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. public interface len_trim Builtin len_trim overloading. public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks. public interface repeat Builtin repeat overloading. public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. public interface scan Builtin scan overloading. public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_character_string (sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public interface trim Builtin trim overloading. public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. Functions private elemental function count_substring (string_, substring) result(No) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string_ String. character(len=*), intent(in) :: substring Substring. Return Value integer(kind=I4P) Number of occurrences. Description Count the number of occurences of a substring into a string. Subroutines public subroutine read_file (file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read a file as a single string stream. public subroutine read_lines (unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(out), allocatable :: lines (:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read lines (records) from a connected-formatted unit. public subroutine write_lines (unit, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write lines (records) to a connected-formatted unit. public subroutine write_file (file, lines, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file File name. type( string ), intent(in) :: lines (1:) The lines. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write a single string stream into file.","tags":"","loc":"module/stringifor.html","title":"stringifor – StringiFor"},{"text":"Uses: penf module~~befor64_pack_data_m~2~~UsesGraph module~befor64_pack_data_m~2 befor64_pack_data_m module~penf penf module~penf->module~befor64_pack_data_m~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_stringify penf_stringify module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulebefor64_pack_data_m2UsesGraph = svgPanZoom('#modulebefor64_pack_data_m2UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. KISS library for packing heterogeneous data into single (homogeneous) packed one. Interfaces public interface pack_data Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. Subroutines private pure subroutine pack_data_R8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Description Pack different kinds of data into single I1P array.","tags":"","loc":"module/befor64_pack_data_m~2.html","title":"befor64_pack_data_m – StringiFor"},{"text":"Uses: penf befor64_pack_data_m module~~befor64~~UsesGraph module~befor64 befor64 module~befor64_pack_data_m befor64_pack_data_m module~befor64_pack_data_m->module~befor64 module~penf penf module~penf->module~befor64 module~penf->module~befor64_pack_data_m module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_stringify penf_stringify module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulebefor64UsesGraph = svgPanZoom('#modulebefor64UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. BeFoR64, Base64 encoding/decoding library for FoRtran poor people. Variables Type Visibility Attributes Name Initial logical, public :: is_b64_initialized = .false. Flag for checking the initialization of the library. character(len=64), private :: base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" Base64 alphabet. Interfaces public interface b64_encode Encode numbers (integer and real) to base64. private pure subroutine b64_encode_R8 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). private pure subroutine b64_encode_R8_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). private pure subroutine b64_encode_R4 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). private pure subroutine b64_encode_R4_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). private pure subroutine b64_encode_I8 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). private pure subroutine b64_encode_I8_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). private pure subroutine b64_encode_I4 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). private pure subroutine b64_encode_I4_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). private pure subroutine b64_encode_I2 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). private pure subroutine b64_encode_I2_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). private pure subroutine b64_encode_I1 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). private pure subroutine b64_encode_I1_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). private pure subroutine b64_encode_string (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. private pure subroutine b64_encode_string_a (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64. public interface b64_encode_up Encode unlimited polymorphic variable to base64. public interface b64_encode_up () Arguments None Description Encode unlimited polymorphic variable to base64. private pure subroutine b64_encode_up_a (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64. public interface b64_decode Decode numbers (integer and real) from base64. private elemental subroutine b64_decode_R8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). private pure subroutine b64_decode_R8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). private elemental subroutine b64_decode_R4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). private pure subroutine b64_decode_R4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). private elemental subroutine b64_decode_I8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). private pure subroutine b64_decode_I8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). private elemental subroutine b64_decode_I4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). private pure subroutine b64_decode_I4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). private elemental subroutine b64_decode_I2 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). private pure subroutine b64_decode_I2_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). private elemental subroutine b64_decode_I1 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). private pure subroutine b64_decode_I1_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). private elemental subroutine b64_decode_string (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. private pure subroutine b64_decode_string_a (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings. public interface b64_decode_up Decode unlimited polymorphic variable from base64. public interface b64_decode_up () Arguments None Description Decode unlimited polymorphic variable from base64. private subroutine b64_decode_up_a (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64. Subroutines public subroutine b64_init () Arguments None Description Initialize the BeFoR64 library. private pure subroutine encode_bits (bits, padd, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: bits (1:) Bits to be encoded. integer(kind=I4P), intent(in) :: padd Number of padding characters ('='). character(len=*), intent(out) :: code Characters code. Description Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). private pure subroutine decode_bits (code, bits) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Characters code. integer(kind=I1P), intent(out) :: bits (1:) Bits decoded. Description Decode a base64 string into a sequence of bits stream. public subroutine b64_encode_up (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode an unlimited polymorphic scalar to base64. private pure subroutine b64_encode_up_a (up, code) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode an unlimited polymorphic array to base64. public subroutine b64_decode_up (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. class(*), intent(out) :: up Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic scalar from base64. private subroutine b64_decode_up_a (code, up) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Description Decode an unlimited polymorphic array from base64. private pure subroutine b64_encode_R16 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R16P). private pure subroutine b64_encode_R8 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R8P). private pure subroutine b64_encode_R4 (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (R4P). private pure subroutine b64_encode_I8 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I8P). private pure subroutine b64_encode_I4 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I4P). private pure subroutine b64_encode_I2 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I2P). private pure subroutine b64_encode_I1 (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar number to base64 (I1P). private pure subroutine b64_encode_string (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode scalar string to base64. private pure subroutine b64_encode_R16_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R16P). private pure subroutine b64_encode_R8_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R8P). private pure subroutine b64_encode_R4_a (n, code) Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (R4P). private pure subroutine b64_encode_I8_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I8P). private pure subroutine b64_encode_I4_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I4P). private pure subroutine b64_encode_I2_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I2P). private pure subroutine b64_encode_I1_a (n, code) Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Description Encode array numbers to base64 (I1P). private pure subroutine b64_encode_string_a (s, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Description Encode array string to base64. private elemental subroutine b64_decode_R16 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R16P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R16P). private elemental subroutine b64_decode_R8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R8P). private elemental subroutine b64_decode_R4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (R4P). private elemental subroutine b64_decode_I8 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I8P). private elemental subroutine b64_decode_I4 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I4P). private elemental subroutine b64_decode_I2 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I2P). private elemental subroutine b64_decode_I1 (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Description Decode a base64 code into a scalar number (I1P). private elemental subroutine b64_decode_string (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Description Decode a base64 code into a scalar string. private pure subroutine b64_decode_R16_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R16P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R16P). private pure subroutine b64_decode_R8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R8P). private pure subroutine b64_decode_R4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (R4P). private pure subroutine b64_decode_I8_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I8P). private pure subroutine b64_decode_I4_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I4P). private pure subroutine b64_decode_I2_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I2P). private pure subroutine b64_decode_I1_a (code, n) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Description Decode a base64 code into an array numbers (I1P). private pure subroutine b64_decode_string_a (code, s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Description Decode a base64 code into an array of strings. public subroutine autotest () Arguments None Description Procedure for autotesting the library functionalities.","tags":"","loc":"module/befor64.html","title":"befor64 – StringiFor"},{"text":"Uses: befor64 penf module~~stringifor_string_t~~UsesGraph module~stringifor_string_t stringifor_string_t module~befor64~2 befor64 module~befor64~2->module~stringifor_string_t module~penf penf module~penf->module~stringifor_string_t module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_stringify penf_stringify module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmodulestringifor_string_tUsesGraph = svgPanZoom('#modulestringifor_string_tUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor, definition of string type. Used By module~~stringifor_string_t~~UsedByGraph module~stringifor_string_t stringifor_string_t module~stringifor stringifor module~stringifor_string_t->module~stringifor program~free free module~stringifor->program~free program~greater_than greater_than module~stringifor->program~greater_than program~lower_than lower_than module~stringifor->program~lower_than program~read_lines read_lines module~stringifor->program~read_lines program~io_basic io_basic module~stringifor->program~io_basic program~startcase startcase module~stringifor->program~startcase program~join join module~stringifor->program~join program~count_string count_string module~stringifor->program~count_string program~is_digit is_digit module~stringifor->program~is_digit program~concatenation concatenation module~stringifor->program~concatenation program~slen slen module~stringifor->program~slen program~insert insert module~stringifor->program~insert program~io_formatted io_formatted module~stringifor->program~io_formatted program~unescape unescape module~stringifor->program~unescape program~sadjustlr sadjustlr module~stringifor->program~sadjustlr program~swapcase swapcase module~stringifor->program~swapcase program~csv_naive_parser csv_naive_parser module~stringifor->program~csv_naive_parser program~strim strim module~stringifor->program~strim program~reverse reverse module~stringifor->program~reverse program~read_line read_line module~stringifor->program~read_line program~is_integer is_integer module~stringifor->program~is_integer program~start_end start_end module~stringifor->program~start_end program~is_number is_number module~stringifor->program~is_number program~unique unique module~stringifor->program~unique program~is_real is_real module~stringifor->program~is_real program~upper_lower upper_lower module~stringifor->program~upper_lower program~write_file write_file module~stringifor->program~write_file program~sscan sscan module~stringifor->program~sscan program~assignments assignments module~stringifor->program~assignments program~escape escape module~stringifor->program~escape program~partition partition module~stringifor->program~partition program~basename_dir basename_dir module~stringifor->program~basename_dir program~to_number to_number module~stringifor->program~to_number program~equal equal module~stringifor->program~equal program~sindex sindex module~stringifor->program~sindex program~read_file read_file module~stringifor->program~read_file program~replace replace module~stringifor->program~replace program~not_equal not_equal module~stringifor->program~not_equal program~slice slice module~stringifor->program~slice program~snakecase snakecase module~stringifor->program~snakecase program~extension extension module~stringifor->program~extension program~srepeat srepeat module~stringifor->program~srepeat program~search search module~stringifor->program~search program~strip strip module~stringifor->program~strip program~fill fill module~stringifor->program~fill program~lower_equal_than lower_equal_than module~stringifor->program~lower_equal_than program~greater_equal_than greater_equal_than module~stringifor->program~greater_equal_than program~write_lines write_lines module~stringifor->program~write_lines program~decode decode module~stringifor->program~decode program~sverify sverify module~stringifor->program~sverify program~camelcase camelcase module~stringifor->program~camelcase program~capitalize capitalize module~stringifor->program~capitalize program~encode encode module~stringifor->program~encode program~split split module~stringifor->program~split Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: CK = selected_char_kind('DEFAULT') Default character kind. character(kind=CK,len=26), private, parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' Upper case alphabet. character(kind=CK,len=26), private, parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' Lower case alphabet. character(kind=CK,len=1), private, parameter :: SPACE = ' ' Space character. character(kind=CK,len=1), private, parameter :: TAB = achar(9) Tab character. character(kind=CK,len=1), private, parameter :: UIX_DIR_SEP = char(47) Unix/Linux directories separator (/). character(kind=CK,len=1), private, parameter :: BACKSLASH = char(92) Backslash character. Derived Types type, public :: string Components Type Visibility Attributes Name Initial character(kind=CK,len=:), private, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: adjustl => sadjustl Adjustl replacement. procedure, public, pass(self) :: adjustr => sadjustr Adjustr replacement. procedure, public, pass(self) :: count => scount Count replacement. generic, public :: index => sindex_string_string, sindex_string_character Index replacement. procedure, public, pass(self) :: len => slen Len replacement. procedure, public, pass(self) :: len_trim => slen_trim Len_trim replacement. generic, public :: repeat => srepeat_string_string, srepeat_character_string Repeat replacement. generic, public :: scan => sscan_string_string, sscan_string_character Scan replacement. procedure, public, pass(self) :: trim => strim Trim replacement. procedure, public, pass(self) :: verify => sverify Verify replacement. procedure, public, pass(self) :: basedir Return the base directory name of a string containing a file name. procedure, public, pass(self) :: basename Return the base file name of a string containing a file name. procedure, public, pass(self) :: camelcase Return a string with all words capitalized without spaces. procedure, public, pass(self) :: capitalize Return a string with its first character capitalized and the rest lowercased. procedure, public, pass(self) :: chars Return the raw characters data. procedure, public, pass(self) :: decode Decode string. procedure, public, pass(self) :: encode Encode string. procedure, public, pass(self) :: escape Escape backslashes (or custom escape character). procedure, public, pass(self) :: extension Return the extension of a string containing a file name. procedure, public, pass(self) :: fill Pad string on the left (or right) with zeros (or other char) to fill width. procedure, public, pass(self) :: free Free dynamic memory. generic, public :: insert => insert_string, insert_character Insert substring into string at a specified position. generic, public :: join => join_strings, join_characters Return a string that is a join of an array of strings or characters. procedure, public, pass(self) :: lower Return a string with all lowercase characters. procedure, public, pass(self) :: partition Split string at separator and return the 3 parts (before, the separator and after). procedure, public, pass(self) :: read_file Read a file a single string stream. procedure, public, pass(self) :: read_line Read line (record) from a connected unit. procedure, public, pass(self) :: read_lines Read (all) lines (records) from a connected unit as a single ascii stream. procedure, public, pass(self) :: replace Return a string with all occurrences of substring old replaced by new. procedure, public, pass(self) :: reverse Return a reversed string. procedure, public, pass(self) :: search Search for tagged record into string. procedure, public, pass(self) :: slice Return the raw characters data sliced. procedure, public, pass(self) :: snakecase Return a string with all words lowercase separated by \"_\". procedure, public, pass(self) :: split Return a list of substring in the string, using sep as the delimiter string. procedure, public, pass(self) :: startcase Return a string with all words capitalized, e.g. title case. procedure, public, pass(self) :: strip Return a string with the leading and trailing characters removed. procedure, public, pass(self) :: swapcase Return a string with uppercase chars converted to lowercase and vice versa. generic, public :: to_number => to_integer_I1P, to_integer_I2P, to_integer_I4P, to_integer_I8P, to_real_R4P, to_real_R8P Cast string to number. procedure, public, pass(self) :: unescape Unescape double backslashes (or custom escaped character). procedure, public, pass(self) :: unique Reduce to one (unique) multiple occurrences of a substring into a string. procedure, public, pass(self) :: upper Return a string with all uppercase characters. procedure, public, pass(self) :: write_file Write a single string stream into file. procedure, public, pass(self) :: write_line Write line (record) to a connected unit. procedure, public, pass(self) :: write_lines Write lines (records) to a connected unit. procedure, public, pass(self) :: end_with Return true if a string ends with a specified suffix. procedure, public, pass(self) :: is_allocated Return true if the string is allocated. procedure, public, pass(self) :: is_digit Return true if all characters in the string are digits. procedure, public, pass(self) :: is_integer Return true if the string contains an integer. procedure, public, pass(self) :: is_lower Return true if all characters in the string are lowercase. procedure, public, pass(self) :: is_number Return true if the string contains a number (real or integer). procedure, public, pass(self) :: is_real Return true if the string contains an real. procedure, public, pass(self) :: is_upper Return true if all characters in the string are uppercase. procedure, public, pass(self) :: start_with Return true if a string starts with a specified prefix. generic, public :: assignment(=) => string_assign_string, string_assign_character, string_assign_integer_I1P, string_assign_integer_I2P, string_assign_integer_I4P, string_assign_integer_I8P, string_assign_real_R4P, string_assign_real_R8P Assignment operator overloading. generic, public :: operator(//) => string_concat_string, string_concat_character, character_concat_string Concatenation operator overloading. generic, public :: operator(.cat.) => string_concat_string_string, string_concat_character_string, character_concat_string_string Concatenation operator (string output) overloading. generic, public :: operator(==) => string_eq_string, string_eq_character, character_eq_string Equal operator overloading. generic, public :: operator(/=) => string_ne_string, string_ne_character, character_ne_string Not equal operator overloading. generic, public :: operator(<) => string_lt_string, string_lt_character, character_lt_string Lower than operator overloading. generic, public :: operator(<=) => string_le_string, string_le_character, character_le_string Lower equal than operator overloading. generic, public :: operator(>=) => string_ge_string, string_ge_character, character_ge_string Greater equal than operator overloading. generic, public :: operator(>) => string_gt_string, string_gt_character, character_gt_string Greater than operator overloading. generic, public :: read(formatted) => read_formatted Formatted input. generic, public :: write(formatted) => write_formatted Formatted output. generic, public :: read(unformatted) => read_unformatted Unformatted input. generic, public :: write(unformatted) => write_unformatted Unformatted output. procedure, private, pass(self) :: sindex_string_string Index replacement. procedure, private, pass(self) :: sindex_string_character Index replacement. procedure, private, pass(self) :: srepeat_string_string Repeat replacement. procedure, private, pass(self) :: srepeat_character_string Repeat replacement. procedure, private, pass(self) :: sscan_string_string Scan replacement. procedure, private, pass(self) :: sscan_string_character Scan replacement. procedure, private, pass(self) :: insert_string Insert substring into string at a specified position. procedure, private, pass(self) :: insert_character Insert substring into string at a specified position. procedure, private, pass(self) :: join_strings Return join string of an array of strings. procedure, private, pass(self) :: join_characters Return join string of an array of characters. procedure, private, pass(self) :: to_integer_I1P Cast string to integer. procedure, private, pass(self) :: to_integer_I2P Cast string to integer. procedure, private, pass(self) :: to_integer_I4P Cast string to integer. procedure, private, pass(self) :: to_integer_I8P Cast string to integer. procedure, private, pass(self) :: to_real_R4P Cast string to real. procedure, private, pass(self) :: to_real_R8P Cast string to real. procedure, private, pass(self) :: to_real_R16P Cast string to real. procedure, private, pass(lhs) :: string_assign_string Assignment operator from string input. procedure, private, pass(lhs) :: string_assign_character Assignment operator from character input. procedure, private, pass(lhs) :: string_assign_integer_I1P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I2P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I4P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_integer_I8P Assignment operator from integer input. procedure, private, pass(lhs) :: string_assign_real_R4P Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R8P Assignment operator from real input. procedure, private, pass(lhs) :: string_assign_real_R16P Assignment operator from real input. procedure, private, pass(lhs) :: string_concat_string Concatenation with string. procedure, private, pass(lhs) :: string_concat_character Concatenation with character. procedure, private, pass(rhs) :: character_concat_string Concatenation with character (inverted). procedure, private, pass(lhs) :: string_concat_string_string Concatenation with string (string output). procedure, private, pass(lhs) :: string_concat_character_string Concatenation with character (string output). procedure, private, pass(rhs) :: character_concat_string_string Concatenation with character (inverted, string output). procedure, private, pass(lhs) :: string_eq_string Equal to string logical operator. procedure, private, pass(lhs) :: string_eq_character Equal to character logical operator. procedure, private, pass(rhs) :: character_eq_string Equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ne_string Not equal to string logical operator. procedure, private, pass(lhs) :: string_ne_character Not equal to character logical operator. procedure, private, pass(rhs) :: character_ne_string Not equal to character (inverted) logical operator. procedure, private, pass(lhs) :: string_lt_string Lower than to string logical operator. procedure, private, pass(lhs) :: string_lt_character Lower than to character logical operator. procedure, private, pass(rhs) :: character_lt_string Lower than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_le_string Lower equal than to string logical operator. procedure, private, pass(lhs) :: string_le_character Lower equal than to character logical operator. procedure, private, pass(rhs) :: character_le_string Lower equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_ge_string Greater equal than to string logical operator. procedure, private, pass(lhs) :: string_ge_character Greater equal than to character logical operator. procedure, private, pass(rhs) :: character_ge_string Greater equal than to character (inverted) logical operator. procedure, private, pass(lhs) :: string_gt_string Greater than to string logical operator. procedure, private, pass(lhs) :: string_gt_character Greater than to character logical operator. procedure, private, pass(rhs) :: character_gt_string Greater than to character (inverted) logical operator. procedure, private, pass(dtv) :: read_formatted Formatted input. procedure, private, pass(dtv) :: read_delimited Read a delimited input. procedure, private, pass(dtv) :: read_undelimited Read an undelimited input. procedure, private, pass(dtv) :: read_undelimited_listdirected Read an undelimited list directed input. procedure, private, pass(dtv) :: write_formatted Formatted output. procedure, private, pass(dtv) :: read_unformatted Unformatted input. procedure, private, pass(dtv) :: write_unformatted Unformatted output. procedure, private, pass(self) :: replace_one_occurrence Replace the first occurrence of substring old by new. Description OOP designed string class. Functions private elemental function sadjustl (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. public pure function sadjustl_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Left adjust a string by removing leading spaces (character output). private elemental function sadjustr (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. public pure function sadjustr_character (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=len(self%raw)) Adjusted string. Description Right adjust a string by removing leading spaces (character output). private elemental function scount (self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore \"isolated\" occurrences. Return Value integer Number of occurrences. Description Count the number of occurences of a substring into a string. public elemental function sindex_string_string (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_string_character (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function sindex_character_string (string_, substring, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: string_ The string. type( string ), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. public elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. public elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks. public elemental function srepeat_string_string (self, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. private elemental function srepeat_character_string (self, rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self String to be repeated. character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Description Concatenates several copies of an input string. public elemental function sscan_string_string (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_string_character (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function sscan_character_string (sstring, set, back) result(i) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: sstring The string. type( string ), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . public elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. private elemental function sverify (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. private elemental function basedir (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. Return Value type( string ) Base directory name. Description Return the base directory name of a string containing a file name. private elemental function basename (self, sep, extension, strip_last_extension) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Directory separator. character(kind=CK,len=*), intent(in), optional :: extension File extension. logical, intent(in), optional :: strip_last_extension Flag to enable the stripping of last extension. Return Value type( string ) Base file name. Description Return the base file name of a string containing a file name. private elemental function camelcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Camel case string. Description Return a string with all words capitalized without spaces. private elemental function capitalize (self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with its first character capitalized and the rest lowercased. private pure function chars (self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data. private elemental function decode (self, codec) result(decoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Decoded string. Description Return a string decoded accordingly the codec. private elemental function encode (self, codec) result(encoded) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: codec Encoding codec. Return Value type( string ) Encoded string. Description Return a string encoded accordingly the codec. private elemental function escape (self, to_escape, esc) result(escaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_escape Character to be escaped. character(kind=CK,len=*), intent(in), optional :: esc Character used to escape. Return Value type( string ) Escaped string. Description Escape backslashes (or custom escape character). private elemental function extension (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Extension file name. Description Return the extension of a string containing a file name. private elemental function fill (self, width, right, filling_char) result(filled) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: width Final width of filled string. logical, intent(in), optional :: right Fill on the right instead of left. character(kind=CK,len=1), intent(in), optional :: filling_char Filling character (default \"0\"). Return Value type( string ) Filled string. Description Pad string on the left (or right) with zeros (or other char) to fill width. private elemental function insert_character (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. private elemental function insert_string (self, substring, pos) result(inserted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: substring Substring. integer, intent(in) :: pos Position from which insert substring. Return Value type( string ) Inserted string. Description Insert substring into string at a specified position. private pure function join_strings (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of strings. private pure function join_characters (self, array, sep) result(join) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: array (1:) Array to be joined. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) The join of array. Description Return a string that is a join of an array of characters. private elemental function lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all lowercase characters. private pure function partition (self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )\n  (1:3) after the separator. Description Split string at separator and return the 3 parts (before, the separator and after). private elemental function replace (self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Description Return a string with all occurrences of substring old replaced by new. private elemental function reverse (self) result(reversed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The reversed string. Description Return a reversed string. private function search (self, tag_start, tag_end, in_string, in_character, istart, iend) result(tag) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: tag_start Start tag. character(kind=CK,len=*), intent(in) :: tag_end End tag. type( string ), intent(in), optional :: in_string Search into this string. character(kind=CK,len=*), intent(in), optional :: in_character Search into this character string. integer, intent(out), optional :: istart Starting index of tag inside the string. integer, intent(out), optional :: iend Ending index of tag inside the string. Return Value type( string ) First tag found. Description Search for tagged record into string, return the first record found (if any) matching the tags. private pure function slice (self, istart, iend) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: istart Slice start index. integer, intent(in) :: iend Slice end   index. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data sliced. private elemental function snakecase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Snake case string. Description Return a string with all words lowercase separated by \"_\". private elemental function startcase (self, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string ) Start case string. Description Return a string with all words capitalized, e.g. title case. private elemental function strip (self, remove_nulls) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: remove_nulls Remove null characters at the end. Return Value type( string ) The stripped string. Description Return a copy of the string with the leading and trailing characters removed. private elemental function swapcase (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a copy of the string with uppercase characters converted to lowercase and vice versa. private elemental function to_integer_I1P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I1P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I1P) The number into the string. Description Cast string to integer (I1P). private elemental function to_integer_I2P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I2P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I2P) The number into the string. Description Cast string to integer (I2P). private elemental function to_integer_I4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I4P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I4P) The number into the string. Description Cast string to integer (I4P). private elemental function to_integer_I8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer(kind=I8P), intent(in) :: kind Mold parameter for kind detection. Return Value integer(kind=I8P) The number into the string. Description Cast string to integer (I8P). private elemental function to_real_R4P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R4P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R4P) The number into the string. Description Cast string to real (R4P). private elemental function to_real_R8P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R8P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R8P) The number into the string. Description Cast string to real (R8P). private elemental function to_real_R16P (self, kind) result(to_number) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. real(kind=R16P), intent(in) :: kind Mold parameter for kind detection. Return Value real(kind=R16P) The number into the string. Description Cast string to real (R16P). private elemental function unescape (self, to_unescape, unesc) result(unescaped) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=1), intent(in) :: to_unescape Character to be unescaped. character(kind=CK,len=*), intent(in), optional :: unesc Character used to unescape. Return Value type( string ) Escaped string. Description Unescape double backslashes (or custom escaped character). private elemental function unique (self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Description Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. private elemental function upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all uppercase characters. private elemental function end_with (self, suffix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string ends with a specified suffix. private elemental function is_allocated (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if the string is allocated. private elemental function is_digit (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are digits. private elemental function is_integer (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains an integer. private elemental function is_lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are lowercase. private elemental function is_number (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a number (real or integer). private elemental function is_real (self, allow_spaces) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. logical, intent(in), optional :: allow_spaces Allow leading-trailing spaces. Return Value logical Result of the test. Description Return true if the string contains a real. private elemental function is_upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are uppercase. private elemental function start_with (self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string starts with a specified prefix. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). private elemental function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. private elemental function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. private elemental function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). private elemental function string_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to string logical operator. private elemental function string_eq_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character logical operator. private elemental function character_eq_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Equal to character (inverted) logical operator. private elemental function string_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to string logical operator. private elemental function string_ne_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character logical operator. private elemental function character_ne_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Not equal to character (inverted) logical operator. private elemental function string_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to string logical operator. private elemental function string_lt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character logical operator. private elemental function character_lt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower than to character (inverted) logical operator. private elemental function string_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to string logical operator. private elemental function string_le_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character logical operator. private elemental function character_le_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Lower equal than to character (inverted) logical operator. private elemental function string_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to string logical operator. private elemental function string_ge_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character logical operator. private elemental function character_ge_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater equal than to character (inverted) logical operator. private elemental function string_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to string logical operator. private elemental function string_gt_character (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character logical operator. private elemental function character_gt_string (lhs, rhs) result(is_it) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value logical Opreator test result. Description Greater than to character (inverted) logical operator. private elemental function replace_one_occurrence (self, old, new) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Description Return a string with the first occurrence of substring old replaced by new. Subroutines private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Description Free dynamic memory. private subroutine read_file (self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read a file as a single string stream. private subroutine read_line (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read line (record) from a connected unit. private subroutine read_lines (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Read (all) lines (records) from a connected unit as a single ascii stream. private pure subroutine split (self, tokens, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. Description Return a list of substring in the string, using sep as the delimiter string. private subroutine write_file (self, file, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: file File name. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write a single string stream into file. private subroutine write_line (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write line (record) to a connected unit. private subroutine write_lines (self, unit, form, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in), optional :: form Format of unit. integer, intent(out), optional :: iostat IO status code. character(len=*), intent(inout), optional :: iomsg IO status message. Description Write lines (records) to a connected unit. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. private elemental subroutine string_assign_integer_I1P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I1P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I2P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I2P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_integer_I8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. integer(kind=I8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R4P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R4P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R8P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private elemental subroutine string_assign_real_R16P (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. real(kind=R16P), intent(in) :: rhs Right hand side. Description Assignment operator from real input. private subroutine read_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Formatted input. private subroutine read_delimited (dtv, unit, delim, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(out) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(in) :: delim String delimiter. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Read a delimited string from a unit connected for formatted input. private subroutine read_undelimited_listdirected (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited (no leading apostrophe or double quote) character value according to the rules for list directed input. private subroutine read_undelimited (dtv, unit, terminators, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: terminators Characters that are considered to terminate the string.\n Blanks in this string are meaningful. integer, intent(out) :: iostat IO status code. character(len=*), intent(inout) :: iomsg IO status message. Description Read an undelimited string up until end of record or a character from a set of terminators is encountered. private subroutine write_formatted (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. private subroutine read_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. private subroutine write_unformatted (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. private subroutine get_delimiter_mode (unit, delim, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit The unit for the connection. character(kind=len=1,CK), intent(out) :: delim Represents the value of the DELIM mode. integer, intent(out) :: iostat IOSTAT error code, non-zero on error. character(len=*), intent(inout) :: iomsg IOMSG explanatory message - only defined if iostat is non-zero. Description Get the DELIM changeable connection mode for the given unit. private subroutine get_next_non_blank_character_this_record (unit, ch, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the next non-blank character in the current record. private subroutine get_next_non_blank_character_any_record (unit, ch, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. character(kind=CK,len=1), intent(out) :: ch The non-blank character read. Not valid if IOSTAT is non-zero. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the next non-blank character, advancing records if necessary. private subroutine get_decimal_mode (unit, decimal_point, iostat, iomsg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit Logical unit. logical, intent(out) :: decimal_point True if the decimal mode is POINT, false otherwise. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Get the DECIMAL changeable connection mode for the given unit.","tags":"","loc":"module/stringifor_string_t.html","title":"stringifor_string_t – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~unescape~~UsesGraph program~unescape unescape iso_fortran_env iso_fortran_env iso_fortran_env->program~unescape module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~unescape module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramunescapeUsesGraph = svgPanZoom('#programunescapeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor unescape test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program unescape !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `unescape` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '&#94;\\\\s \\\\d+\\\\s*' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = ( astring % unescape ( to_unescape = '\\')//''==' &#94;\\ s \\ d + \\ s * ') write(stdout, \"(A,L1)\") ' Escaped : \"'//astring%unescape(to_unescape='\\')//'\" , is correct ? ', test_passed(1) test_passed(2) = (astring%unescape(to_unescape=' s ')//''==' &#94;\\ s \\\\ d + \\ s * ') write(stdout, \"(A,L1)\") ' Escaped : \"'//astring%unescape(to_unescape='s')//'\" , is correct ? ', test_passed(2) write(stdout, \"(A,L1)\") new_line(' a ')//' Are all tests passed ? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram unescape","tags":"","loc":"program/unescape.html","title":"unescape – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~reverse~~UsesGraph program~reverse reverse iso_fortran_env iso_fortran_env iso_fortran_env->program~reverse module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~reverse module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramreverseUsesGraph = svgPanZoom('#programreverseUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor reverse test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program reverse !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `reverse` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'abcdefghilmnopqrstuvz' test_passed ( 1 ) = ( astring % reverse () // '' == 'zvutsrqponmlihgfedcba' ) write ( stdout , \"(A,L1)\" ) 'Original:  \"' // astring // '\", reversed: \"' // astring % reverse () // '\", is correct? ' , & astring % reverse () // '' == 'zvutsrqponmlihgfedcba' astring = '0123456789' test_passed ( 2 ) = ( astring % reverse () // '' == '9876543210' ) write ( stdout , \"(A,L1)\" ) 'Original:  \"' // astring // '\", reversed: \"' // astring % reverse () // '\", is correct? ' , & astring % reverse () // '' == '9876543210' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram reverse","tags":"","loc":"program/reverse.html","title":"reverse – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~start_end~~UsesGraph program~start_end start_end iso_fortran_env iso_fortran_env iso_fortran_env->program~start_end module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~start_end module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramstart_endUsesGraph = svgPanZoom('#programstart_endUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor start_end test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (8) List of passed tests. Source Code program start_end !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `start_end` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % start_with ( prefix = 'Hello' ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'start with \"Hello\"? ' , astring % start_with ( prefix = 'Hello' ) test_passed ( 2 ) = astring % start_with ( prefix = 'hell' ). eqv .. false . write ( stdout , \"(A,L1)\" ) 'start with \"hell\"? ' , astring % start_with ( prefix = 'hell' ) test_passed ( 3 ) = astring % start_with ( prefix = 'llo Wor' , start = 3 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (3:) start with \"llo Wor\"? ' , astring % start_with ( prefix = 'llo Wor' , start = 3 ) test_passed ( 4 ) = astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (4:7) start with \"lo W\"? ' , astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ) test_passed ( 5 ) = astring % end_with ( suffix = 'LD!' ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'end with \"LD!\"? ' , astring % end_with ( suffix = 'LD!' ) test_passed ( 6 ) = astring % end_with ( suffix = 'lD!' ). eqv .. false . write ( stdout , \"(A,L1)\" ) 'end with \"lD!\"? ' , astring % end_with ( suffix = 'lD!' ) test_passed ( 7 ) = astring % end_with ( suffix = 'orLD!' , start = 5 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (5:) end with \"orLD!\"? ' , astring % end_with ( suffix = 'orLD!' , start = 5 ) test_passed ( 8 ) = astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (8:12) end with \"orLD!\"? ' , astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram start_end","tags":"","loc":"program/start_end.html","title":"start_end – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~is_real~~UsesGraph program~is_real is_real iso_fortran_env iso_fortran_env iso_fortran_env->program~is_real module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~is_real module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramis_realUsesGraph = svgPanZoom('#programis_realUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor is_real test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (6) List of passed tests. Source Code program is_real !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_real` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112.d0 ' test_passed ( 1 ) = astring % is_real (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () astring = '   -1212112.d0' test_passed ( 2 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real (no spaces allowed)? ' , astring % is_real ( allow_spaces = . false .) astring = '-1212112.d0   ' test_passed ( 3 ) = astring % is_real ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real (no spaces allowed)? ' , astring % is_real ( allow_spaces = . false .) astring = '+2.e20' test_passed ( 4 ) = astring % is_real (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () astring = ' -2.01E13 ' test_passed ( 5 ) = astring % is_real (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () astring = ' -2.01 E13 ' test_passed ( 6 ) = astring % is_real (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is real? ' , astring % is_real () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_real","tags":"","loc":"program/is_real.html","title":"is_real – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sscan~~UsesGraph program~sscan sscan iso_fortran_env iso_fortran_env iso_fortran_env->program~sscan module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~sscan module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramsscanUsesGraph = svgPanZoom('#programsscanUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sscan test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring Another string. character(len=:), allocatable :: acharacter A character. character(len=:), allocatable :: anothercharacter Another character. integer :: i Index result. integer :: ic Index result comparison. logical :: test_passed (5) List of passed tests. Source Code program sscan !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sscan` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 5 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter anotherstring = anothercharacter i = astring % scan ( set = anothercharacter ) ic = scan ( string = acharacter , set = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , test_passed ( 1 ) i = astring % scan ( set = anothercharacter , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , test_passed ( 2 ) i = scan ( astring , set = anothercharacter , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 3 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call (builtin) result: ' , i , ' is correct? ' , test_passed ( 3 ) i = scan ( acharacter , set = anotherstring , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 4 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call (builtin) result: ' , i , ' is correct? ' , test_passed ( 4 ) i = scan ( astring , set = anotherstring , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 5 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call (builtin) result: ' , i , ' is correct? ' , test_passed ( 5 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sscan","tags":"","loc":"program/sscan.html","title":"sscan – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~to_number~~UsesGraph program~to_number to_number iso_fortran_env iso_fortran_env iso_fortran_env->program~to_number module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~to_number module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramto_numberUsesGraph = svgPanZoom('#programto_numberUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor to_number test. Variables Type Attributes Name Initial type( string ) :: astring A string. integer(kind=I1P) :: integer_I1P A integer. integer(kind=I1P) :: integer_I1P_ A integer. integer(kind=I2P) :: integer_I2P A integer. integer(kind=I2P) :: integer_I2P_ A integer. integer(kind=I4P) :: integer_I4P A integer. integer(kind=I4P) :: integer_I4P_ A integer. integer(kind=I8P) :: integer_I8P A integer. integer(kind=I8P) :: integer_I8P_ A integer. real(kind=R4P) :: real_R4P A real. real(kind=R4P) :: real_R4P_ A real. real(kind=R8P) :: real_R8P A real. real(kind=R8P) :: real_R8P_ A real. real(kind=R16P) :: real_R16P A real. real(kind=R16P) :: real_R16P_ A real. logical :: test_passed (7) List of passed tests. Source Code program to_number !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `to_number` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string , I1P , I2P , I4P , I8P , R4P , R8P , R16P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. integer ( I1P ) :: integer_I1P !< A integer. integer ( I1P ) :: integer_I1P_ !< A integer. integer ( I2P ) :: integer_I2P !< A integer. integer ( I2P ) :: integer_I2P_ !< A integer. integer ( I4P ) :: integer_I4P !< A integer. integer ( I4P ) :: integer_I4P_ !< A integer. integer ( I8P ) :: integer_I8P !< A integer. integer ( I8P ) :: integer_I8P_ !< A integer. real ( R4P ) :: real_R4P !< A real. real ( R4P ) :: real_R4P_ !< A real. real ( R8P ) :: real_R8P !< A real. real ( R8P ) :: real_R8P_ !< A real. real ( R16P ) :: real_R16P !< A real. real ( R16P ) :: real_R16P_ !< A real. logical :: test_passed ( 7 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '127' integer_I1P = astring % to_number ( kind = 1_I1P ) integer_I1P_ = 127_I1P test_passed ( 1 ) = integer_I1P == integer_I1P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I4,A)\" ) 'To number: \"' , integer_I1P , '\"' astring = '32767' integer_I2P = astring % to_number ( kind = 1_I2P ) integer_I2P_ = 32767_I2P test_passed ( 2 ) = integer_I2P == integer_I2P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I6,A)\" ) 'To number: \"' , integer_I2P , '\"' astring = '2147483647' integer_I4P = astring % to_number ( kind = 1_I4P ) integer_I4P_ = 2147483647_I4P test_passed ( 3 ) = integer_I4P == integer_I4P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I11,A)\" ) 'To number: \"' , integer_I4P , '\"' astring = '-9223372036854775807' integer_I8P = astring % to_number ( kind = 1_I8P ) integer_I8P_ = - 9223372036854775807_I8P test_passed ( 4 ) = integer_I8P == integer_I8P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,I20,A)\" ) 'To number: \"' , integer_I8P , '\"' astring = '3.4e9' real_R4P = astring % to_number ( kind = 1._R4P ) real_R4P_ = 3.4e9_R4P test_passed ( 5 ) = real_R4P == real_R4P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,E13.6,A)\" ) 'To number: \"' , real_R4P , '\"' astring = '-13.4345345e21' real_R8P = astring % to_number ( kind = 1._R8P ) real_R8P_ = - 1 3.4345345e21_R8P test_passed ( 6 ) = real_R8P == real_R8P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,E23.15,A)\" ) 'To number: \"' , real_R8P , '\"' astring = '1.1e200' real_R16P = astring % to_number ( kind = 1._R16P ) real_R16P_ = 1.1e200_R16P test_passed ( 7 ) = real_R16P == real_R16P_ write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,E42.33,A)\" ) 'To number: \"' , real_R16P , '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram to_number","tags":"","loc":"program/to_number.html","title":"to_number – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~read_file~~UsesGraph program~read_file read_file iso_fortran_env iso_fortran_env iso_fortran_env->program~read_file module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~read_file module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramread_fileUsesGraph = svgPanZoom('#programread_fileUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor read_file test. Calls program~~read_file~~CallsGraph program~read_file read_file read_file_standalone read_file_standalone program~read_file->read_file_standalone Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ), allocatable :: strings (:) A set of strings. type( string ) :: line (3) Another set of string. integer :: iostat IO status code. character(len=99) :: iomsg IO status message. integer :: scratch Scratch file unit. integer :: l Counter. logical :: test_passed (16) List of passed tests. Source Code program read_file !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `read_file` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit , iostat_end use stringifor , only : read_file_standalone => read_file , string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. type ( string ) :: line ( 3 ) !< Another set of string. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. integer :: scratch !< Scratch file unit. integer :: l !< Counter. logical :: test_passed ( 16 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , file = 'read_file_test.tmp' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () close ( scratch ) write ( stdout , \"(A)\" ) \"TBP read_file\" call astring % read_file ( file = 'read_file_test.tmp' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 1 ) enddo write ( stdout , \"(A)\" ) \"Standalone read_file\" call read_file_standalone ( file = 'read_file_test.tmp' , lines = strings , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 5 ) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) close ( scratch ) write ( stdout , \"(A)\" ) \"TBP read_file unformatted\" call astring % read_file ( file = 'read_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 9 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 9 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 9 ) enddo write ( stdout , \"(A)\" ) \"Standalone read_file unformatted\" call read_file_standalone ( file = 'read_file_test.tmp' , lines = strings , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg test_passed ( 13 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 13 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 13 ) enddo open ( newunit = scratch , file = 'read_file_test.tmp' , form = 'UNFORMATTED' , access = 'STREAM' ) close ( scratch , status = 'DELETE' ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram read_file","tags":"","loc":"program/read_file.html","title":"read_file – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~slice~~UsesGraph program~slice slice iso_fortran_env iso_fortran_env iso_fortran_env->program~slice module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~slice module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramsliceUsesGraph = svgPanZoom('#programsliceUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor slice test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program slice !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `slice` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % slice ( 11 , 25 ) == 'Brown fox Jumps' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % slice ( 11 , 25 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram slice","tags":"","loc":"program/slice.html","title":"slice – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~search~~UsesGraph program~search search iso_fortran_env iso_fortran_env iso_fortran_env->program~search module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~search module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramsearchUsesGraph = svgPanZoom('#programsearchUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor search test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring Another string. character(len=:), allocatable :: acharacter A character. integer :: istart Start index of searched tag. integer :: iend End index of searched tag. logical :: test_passed (5) List of passed tests. Source Code program search !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `search` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. character ( len = :), allocatable :: acharacter !< A character. integer :: istart !< Start index of searched tag. integer :: iend !< End index of searched tag. logical :: test_passed ( 5 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '<test> <first> hello </first> <first> not the first </first> </test>' anotherstring = astring % search ( tag_start = '<first>' , tag_end = '</first>' ) test_passed ( 1 ) = anotherstring // '' == '<first> hello </first>' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // anotherstring // '\", is correct? ' , test_passed ( 1 ) astring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' anotherstring = astring % search ( tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 2 ) = anotherstring // '' == '<a> <a> <a> the nested a </a> </a> </a>' write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // anotherstring // '\", is correct? ' , test_passed ( 2 ) call astring % free anotherstring = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_string = anotherstring , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 3 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // anotherstring // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // astring // '\", is correct? ' , test_passed ( 3 ) call astring % free acharacter = '<test> <a> <a> <a> the nested a </a> </a> </a> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<a>' , tag_end = '</a>' ) test_passed ( 4 ) = astring // '' == '<a> <a> <a> the nested a </a> </a> </a>' write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // acharacter // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // astring // '\", is correct? ' , test_passed ( 4 ) acharacter = '<test> <first> hello </first> <sec> <sec>not the first</sec> </sec> </test>' astring = astring % search ( in_character = acharacter , tag_start = '<sec>' , tag_end = '</sec>' , istart = istart , iend = iend ) test_passed ( 5 ) = astring // '' == acharacter ( 31 : 67 ) write ( stdout , \"(A)\" ) new_line ( 'a' ) // 'Original:  \"' // acharacter // '\"' write ( stdout , \"(A,L1)\" ) 'Search: \"' // astring // '\", is correct? ' , test_passed ( 5 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram search","tags":"","loc":"program/search.html","title":"search – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~fill~~UsesGraph program~fill fill iso_fortran_env iso_fortran_env iso_fortran_env->program~fill module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~fill module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramfillUsesGraph = svgPanZoom('#programfillUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor fill test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (4) List of passed tests. Source Code program fill !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `fill` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = astring % fill ( width = 40 ) // '' == '00000000this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Fill (w=40): \"' // astring % fill ( width = 40 ) // '\"' test_passed ( 2 ) = astring % fill ( width = 50 ) // '' == '000000000000000000this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Fill (w=50): \"' // astring % fill ( width = 50 ) // '\"' test_passed ( 3 ) = astring % fill ( width = 50 , right = . true .) // '' == 'this is string example....wow!!!000000000000000000' write ( stdout , \"(A)\" ) 'Fill (w=50, right): \"' // astring % fill ( width = 50 , right = . true .) // '\"' test_passed ( 4 ) = astring % fill ( width = 40 , filling_char = '*' ) // '' == '********this is string example....wow!!!' write ( stdout , \"(A)\" ) 'Fill (w=40, fc=*): \"' // astring % fill ( width = 40 , filling_char = '*' ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram fill","tags":"","loc":"program/fill.html","title":"fill – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~decode~~UsesGraph program~decode decode iso_fortran_env iso_fortran_env iso_fortran_env->program~decode module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~decode module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramdecodeUsesGraph = svgPanZoom('#programdecodeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor decode test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program decode !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `decode` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : CK , string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'SG93IGFyZSB5b3U/' test_passed ( 1 ) = astring % decode ( codec = 'base64' ) // '' == CK_ 'How are you?' write ( stdout , \"(A)\" ) 'BASE64:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Decoded: \"' // astring % decode ( codec = 'base64' ) // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram decode","tags":"","loc":"program/decode.html","title":"decode – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~encode~~UsesGraph program~encode encode iso_fortran_env iso_fortran_env iso_fortran_env->program~encode module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~encode module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramencodeUsesGraph = svgPanZoom('#programencodeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor encode test. Bug On Travis CI fails. This is very oddy: this works on all my PCs with both Intel and GNU compilers… temporarly disabled. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program encode !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `encode` test. !< @bug On Travis CI fails. This is very oddy: this works on all my PCs with both Intel and GNU compilers... temporarly disabled. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'How are you?' test_passed ( 1 ) = astring % encode ( codec = 'base64' ) // '' == 'SG93IGFyZSB5b3U/' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'BASE64: \"' // astring % encode ( codec = 'base64' ) // '\", is correct? ' , test_passed ( 1 ) ! disable for bug on Travis CI test_passed = . true . write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram encode","tags":"","loc":"program/encode.html","title":"encode – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~free~~UsesGraph program~free free iso_fortran_env iso_fortran_env iso_fortran_env->program~free module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~free module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramfreeUsesGraph = svgPanZoom('#programfreeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor free test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program free !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `free` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'say all Hello WorLD!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % is_allocated (). eqv .. true . write ( stdout , \"(A,L1)\" ) 'Is allocated? ' , astring % is_allocated () call astring % free test_passed ( 2 ) = astring % is_allocated (). eqv .. false . write ( stdout , \"(A,L1)\" ) 'Is allocated? ' , astring % is_allocated () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram free","tags":"","loc":"program/free.html","title":"free – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~io_basic~~UsesGraph program~io_basic io_basic iso_fortran_env iso_fortran_env iso_fortran_env->program~io_basic module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~io_basic module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramio_basicUsesGraph = svgPanZoom('#programio_basicUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor io_basic test. Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. integer :: iostat IO status code. character(len=99) :: iomsg IO status message. logical :: test_passed (2) List of passed tests. Source Code program io_basic !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `io_basic` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none #ifndef __GFORTRAN__ type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. #endif logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . #ifndef __GFORTRAN__ astring = 'Hello World!' acharacter = 'New Hello World!' write ( stdout , \"(DT)\" , iostat = iostat , iomsg = iomsg ) astring test_passed ( 1 ) = iostat == 0 if ( iostat /= 0 ) print \"(A)\" , iomsg read ( acharacter , \"(DT)\" , iostat = iostat , iomsg = iomsg ) astring test_passed ( 2 ) = iostat == 0 if ( iostat /= 0 ) print \"(A)\" , iomsg print \"(DT)\" , astring #else ! GNU gfortran does not support defined IO test_passed = . true . #endif write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram io_basic","tags":"","loc":"program/io_basic.html","title":"io_basic – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~count_string~~UsesGraph program~count_string count_string iso_fortran_env iso_fortran_env iso_fortran_env->program~count_string module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~count_string module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramcount_stringUsesGraph = svgPanZoom('#programcount_stringUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor count_string test. Variables Type Attributes Name Initial type( string ) :: astring A string. integer :: No Number of occurences. logical :: test_passed (3) List of passed tests. Source Code program count_string !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `count_string` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. integer :: No !< Number of occurences. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' No = astring % count ( substring = ' ' , ignore_isolated = . true .) test_passed ( 1 ) = No == 3 write ( stdout , \"(A,I1,A,L1)\" ) 'Count \" \" ignore isolated: \"' , No , '\", is correct? ' , test_passed ( 1 ) No = astring % count ( substring = ' ' ) test_passed ( 2 ) = No == 4 write ( stdout , \"(A,I1,A,L1)\" ) 'Count \" \": \"' , No , '\", is correct? ' , test_passed ( 2 ) No = astring % count ( substring = 'l' ) test_passed ( 3 ) = No == 3 write ( stdout , \"(A,I1,A,L1)\" ) 'Count \"l\": \"' , No , '\", is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram count_string","tags":"","loc":"program/count_string.html","title":"count_string – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~insert~~UsesGraph program~insert insert iso_fortran_env iso_fortran_env iso_fortran_env->program~insert module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~insert module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprograminsertUsesGraph = svgPanZoom('#programinsertUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor insert test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring Another string. character(len=:), allocatable :: acharacter A character. logical :: test_passed (10) List of passed tests. Source Code program insert !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `insert` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 10 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'this is string example wow!!!' anotherstring = '... ' acharacter = '... ' write ( stdout , \"(A)\" ) 'Original string:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Substring:  \"' // anotherstring // '\"' write ( stdout , \"(A)\" ) 'Test substring of type string' test_passed ( 1 ) = astring % insert ( substring = anotherstring , pos = 1 ) // '' == '... this is string example wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=1: \"' // astring % insert ( substring = anotherstring , pos = 1 ) // '\", is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = astring % insert ( substring = anotherstring , pos = 23 ) // '' == 'this is string example...  wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=23: \"' // astring % insert ( substring = anotherstring , pos = 23 ) // '\", is correct? ' , test_passed ( 2 ) test_passed ( 3 ) = astring % insert ( substring = anotherstring , pos = 29 ) // '' == 'this is string example wow!!!... ' write ( stdout , \"(A,L1)\" ) 'insert at pos=29: \"' // astring % insert ( substring = anotherstring , pos = 29 ) // '\", is correct? ' , test_passed ( 3 ) test_passed ( 4 ) = astring % insert ( substring = anotherstring , pos =- 1 ) // '' == '... this is string example wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=-1: \"' // astring % insert ( substring = anotherstring , pos =- 1 ) // '\", is correct? ' , test_passed ( 4 ) test_passed ( 5 ) = astring % insert ( substring = anotherstring , pos = 100 ) // '' == 'this is string example wow!!!... ' write ( stdout , \"(A,L1)\" ) 'insert at pos=100: \"' // astring % insert ( substring = anotherstring , pos = 100 ) // '\", is correct? ' , test_passed ( 5 ) write ( stdout , \"(A)\" ) 'Test substring of type character' test_passed ( 6 ) = astring % insert ( substring = acharacter , pos = 1 ) // '' == '... this is string example wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=1: \"' // astring % insert ( substring = acharacter , pos = 1 ) // '\", is correct? ' , test_passed ( 6 ) test_passed ( 7 ) = astring % insert ( substring = acharacter , pos = 23 ) // '' == 'this is string example...  wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=23: \"' // astring % insert ( substring = acharacter , pos = 23 ) // '\", is correct? ' , test_passed ( 7 ) test_passed ( 8 ) = astring % insert ( substring = acharacter , pos = 29 ) // '' == 'this is string example wow!!!... ' write ( stdout , \"(A,L1)\" ) 'insert at pos=29: \"' // astring % insert ( substring = acharacter , pos = 29 ) // '\", is correct? ' , test_passed ( 8 ) test_passed ( 9 ) = astring % insert ( substring = acharacter , pos =- 1 ) // '' == '... this is string example wow!!!' write ( stdout , \"(A,L1)\" ) 'insert at pos=-1: \"' // astring % insert ( substring = acharacter , pos =- 1 ) // '\", is correct? ' , test_passed ( 9 ) test_passed ( 10 ) = astring % insert ( substring = acharacter , pos = 100 ) // '' == 'this is string example wow!!!... ' write ( stdout , \"(A,L1)\" ) 'insert at pos=100: \"' // astring % insert ( substring = acharacter , pos = 100 ) // '\", is correct? ' , test_passed ( 10 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram insert","tags":"","loc":"program/insert.html","title":"insert – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~swapcase~~UsesGraph program~swapcase swapcase iso_fortran_env iso_fortran_env iso_fortran_env->program~swapcase module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~swapcase module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramswapcaseUsesGraph = svgPanZoom('#programswapcaseUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor swapcase test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program swapcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `swapcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % swapcase () // '' == '  hELLO wORLD!   ' write ( stdout , \"(A,L1)\" ) 'Swapcase: \"' // astring % swapcase () // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram swapcase","tags":"","loc":"program/swapcase.html","title":"swapcase – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~read_line~~UsesGraph program~read_line read_line iso_fortran_env iso_fortran_env iso_fortran_env->program~read_line module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~read_line module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramread_lineUsesGraph = svgPanZoom('#programread_lineUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor read_line test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: line (3) A set of strings. integer :: iostat IO status code. character(len=99) :: iomsg IO status message. integer :: scratch Scratch file unit. integer :: l Counter. logical :: test_passed (6) List of passed tests. Source Code program read_line !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `read_line` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: line ( 3 ) !< A set of strings. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. integer :: scratch !< Scratch file unit. integer :: l !< Counter. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' write ( stdout , \"(A)\" ) ' Formatted read' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then write ( stdout , \"(A)\" ) iomsg exit else test_passed ( l ) = ( astring == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // astring // '\", is correct? ' , test_passed ( l ) endif enddo close ( scratch ) write ( stdout , \"(A)\" ) ' Unformatted read' open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) rewind ( scratch ) l = 0 iostat = 0 do l = l + 1 call astring % read_line ( unit = scratch , iostat = iostat , iomsg = iomsg , form = 'UnfORMatteD' ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat )) then write ( stdout , \"(A)\" ) iomsg exit else test_passed ( l + 3 ) = ( astring == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // astring // '\", is correct? ' , test_passed ( l + 3 ) endif enddo close ( scratch ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram read_line","tags":"","loc":"program/read_line.html","title":"read_line – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~is_number~~UsesGraph program~is_number is_number iso_fortran_env iso_fortran_env iso_fortran_env->program~is_number module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~is_number module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramis_numberUsesGraph = svgPanZoom('#programis_numberUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor is_number test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (7) List of passed tests. Source Code program is_number !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_number` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 7 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112 ' test_passed ( 1 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = '   -121.2112 ' test_passed ( 2 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = '   -1212112' test_passed ( 3 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number (no spaces allowed)? ' , astring % is_number ( allow_spaces = . false .) astring = '-12121.12   ' test_passed ( 4 ) = astring % is_number ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number (no spaces allowed)? ' , astring % is_number ( allow_spaces = . false .) astring = '+2e20' test_passed ( 5 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = ' -2.4E13 ' test_passed ( 6 ) = astring % is_number (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () astring = ' -2 E13 ' test_passed ( 7 ) = astring % is_number (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is number? ' , astring % is_number () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_number","tags":"","loc":"program/is_number.html","title":"is_number – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~upper_lower~~UsesGraph program~upper_lower upper_lower iso_fortran_env iso_fortran_env iso_fortran_env->program~upper_lower module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~upper_lower module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramupper_lowerUsesGraph = svgPanZoom('#programupper_lowerUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor upper_lower test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1:8) List of passed tests. Source Code program upper_lower !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `upper_lower` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 : 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' test_passed ( 1 ) = astring % upper () // '' == 'HELLO WORLD!' test_passed ( 2 ) = astring % lower () // '' == 'hello world!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'UPPER:    \"' // astring % upper () // '\". Is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) 'lower:    \"' // astring % lower () // '\". Is correct? ' , test_passed ( 2 ) astring = ' Hello World' test_passed ( 3 ) = astring % is_upper (). eqv .. false . test_passed ( 4 ) = astring % is_lower (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 4 ) astring = ' HELLO WORLD' test_passed ( 5 ) = astring % is_upper (). eqv .. true . test_passed ( 6 ) = astring % is_lower (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 5 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 6 ) astring = ' hello world' test_passed ( 7 ) = astring % is_upper (). eqv .. false . test_passed ( 8 ) = astring % is_lower (). eqv .. true . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 7 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 8 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram upper_lower","tags":"","loc":"program/upper_lower.html","title":"upper_lower – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~partition~~UsesGraph program~partition partition iso_fortran_env iso_fortran_env iso_fortran_env->program~partition module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~partition module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogrampartitionUsesGraph = svgPanZoom('#programpartitionUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor partition test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: strings (3) A set of strings. logical :: test_passed (3) List of passed tests. Source Code program partition !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `partition` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: strings ( 3 ) !< A set of strings. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' strings = astring % partition ( sep = 'lo Wo' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'Hel' . and . strings ( 2 ) // '' == 'lo Wo' . and . strings ( 3 ) // '' == 'rLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // 'lo Wo' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' strings = astring % partition ( sep = 'Hello' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == '' . and . strings ( 2 ) // '' == 'Hello' . and . strings ( 3 ) // '' == ' WorLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // 'Hello' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' astring = 'Hello WorLD!' strings = astring % partition () test_passed ( 3 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == ' ' . and . strings ( 3 ) // '' == 'WorLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // ' ' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram partition","tags":"","loc":"program/partition.html","title":"partition – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~equal~~UsesGraph program~equal equal iso_fortran_env iso_fortran_env iso_fortran_env->program~equal module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~equal module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramequalUsesGraph = svgPanZoom('#programequalUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor equal test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring A string. character(len=:), allocatable :: acharacter A character. logical :: test_passed (6) List of passed tests. Source Code program equal !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `equal` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  one ' anotherstring = 'two' acharacter = 'three' test_passed ( 1 ) = (( astring == anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '==' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring == acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '==' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter == astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '==' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'the same ' anotherstring = 'the same ' acharacter = 'the same ' test_passed ( 4 ) = (( astring == anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '==' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring == acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '==' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter == astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '==' // astring // '\", test passed? ' , test_passed ( 6 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram equal","tags":"","loc":"program/equal.html","title":"equal – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~replace~~UsesGraph program~replace replace iso_fortran_env iso_fortran_env iso_fortran_env->program~replace module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~replace module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramreplaceUsesGraph = svgPanZoom('#programreplaceUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor replace test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program replace !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `replace` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'When YOU are sad YOU should think to me :-)' write ( stdout , \"(A)\" ) 'Original:                                 \"' // astring // '\"' test_passed ( 1 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' ) // '' == 'When THEY are sad THEY should think to me :-)' ) write ( stdout , \"(A)\" ) 'Replace \"YOU\" with \"THEY\":                \"' // astring % replace ( old = 'YOU' , new = 'THEY' ) // '\"' test_passed ( 2 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '' == 'When THEY are sad YOU should think to me :-)' ) write ( stdout , \"(A)\" ) 'Replace only the first \"YOU\" with \"THEY\": \"' // astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram replace","tags":"","loc":"program/replace.html","title":"replace – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~snakecase~~UsesGraph program~snakecase snakecase iso_fortran_env iso_fortran_env iso_fortran_env->program~snakecase module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~snakecase module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramsnakecaseUsesGraph = svgPanZoom('#programsnakecaseUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor snakecase test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program snakecase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `snakecase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % snakecase () // '' == 'the_quick_brown_fox_jumps_over_the_lazy_dog.' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % snakecase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram snakecase","tags":"","loc":"program/snakecase.html","title":"snakecase – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~srepeat~~UsesGraph program~srepeat srepeat iso_fortran_env iso_fortran_env iso_fortran_env->program~srepeat module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~srepeat module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramsrepeatUsesGraph = svgPanZoom('#programsrepeatUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor srepeat test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (3) List of passed tests. Source Code program srepeat !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `srepeat` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'x' test_passed ( 1 ) = astring % repeat ( rstring = 'x' , ncopies = 5 ) // '' == 'xxxxx' write ( stdout , \"(A,L1)\" ) 'Repeat x 5 times: \"' // astring % repeat ( rstring = 'x' , ncopies = 5 ) // '\", is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = astring % repeat ( ncopies = 5 ) // '' == 'xxxxx' write ( stdout , \"(A,L1)\" ) 'Repeat (self) x 5 times: \"' // astring % repeat ( ncopies = 5 ) // '\", is correct? ' , test_passed ( 2 ) test_passed ( 3 ) = repeat ( astring , 5 ) // '' == 'xxxxx' write ( stdout , \"(A,L1)\" ) 'Repeat (builtin) x 5 times: \"' // repeat ( astring , 5 ) // '\", is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram srepeat","tags":"","loc":"program/srepeat.html","title":"srepeat – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~startcase~~UsesGraph program~startcase startcase iso_fortran_env iso_fortran_env iso_fortran_env->program~startcase module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~startcase module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramstartcaseUsesGraph = svgPanZoom('#programstartcaseUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor startcase test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program startcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `startcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % startcase () // '' == 'The Quick Brown Fox Jumps Over The Lazy Dog.' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % startcase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram startcase","tags":"","loc":"program/startcase.html","title":"startcase – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~write_file~~UsesGraph program~write_file write_file iso_fortran_env iso_fortran_env iso_fortran_env->program~write_file module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~write_file module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramwrite_fileUsesGraph = svgPanZoom('#programwrite_fileUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor write_file test. Calls program~~write_file~~CallsGraph program~write_file write_file write_file_standalone write_file_standalone program~write_file->write_file_standalone Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring Another string. type( string ), allocatable :: strings (:) A set of strings. type( string ) :: line (3) Another set of string. integer :: iostat IO status code. character(len=99) :: iomsg IO status message. integer :: scratch Scratch file unit. integer :: l Counter. logical :: test_passed (16) List of passed tests. Source Code program write_file !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `write_file` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit , iostat_end use stringifor , only : write_file_standalone => write_file , string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. type ( string ), allocatable :: strings (:) !< A set of strings. type ( string ) :: line ( 3 ) !< Another set of string. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. integer :: scratch !< Scratch file unit. integer :: l !< Counter. logical :: test_passed ( 16 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) write ( stdout , \"(A)\" ) \"TBP write_file\" call anotherstring % write_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 1 ) enddo write ( stdout , \"(A)\" ) \"Standalone write_file\" call write_file_standalone ( file = 'write_file_test.tmp' , lines = line , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_file ( file = 'write_file_test.tmp' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 5 ) enddo write ( stdout , \"(A)\" ) \"TBP write_file unformatted\" call anotherstring % write_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 9 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 9 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 9 ) enddo write ( stdout , \"(A)\" ) \"Standalone write_file unformatted\" call write_file_standalone ( file = 'write_file_test.tmp' , lines = line , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_file ( file = 'write_file_test.tmp' , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 13 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 13 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 13 ) enddo open ( newunit = scratch , file = 'write_file_test.tmp' ) close ( scratch , status = 'DELETE' ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram write_file","tags":"","loc":"program/write_file.html","title":"write_file – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~lower_equal_than~~UsesGraph program~lower_equal_than lower_equal_than iso_fortran_env iso_fortran_env iso_fortran_env->program~lower_equal_than module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~lower_equal_than module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramlower_equal_thanUsesGraph = svgPanZoom('#programlower_equal_thanUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor lower_equal_than test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring A string. character(len=:), allocatable :: acharacter A character. logical :: test_passed (9) List of passed tests. Source Code program lower_equal_than !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `lower_equal_than` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 9 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'one' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 1 ) = (( astring <= anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring <= acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter <= astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '<=' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'ONE' anotherstring = 'one' acharacter = 'one' test_passed ( 4 ) = (( astring <= anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring <= acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter <= astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '<=' // astring // '\", test passed? ' , test_passed ( 6 ) astring = 'ONE' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 7 ) = (( astring <= anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // anotherstring // '\", test passed? ' , test_passed ( 7 ) test_passed ( 8 ) = (( astring <= acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<=' // acharacter // '\", test passed? ' , test_passed ( 8 ) test_passed ( 9 ) = (( acharacter <= astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '<=' // astring // '\", test passed? ' , test_passed ( 9 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram lower_equal_than","tags":"","loc":"program/lower_equal_than.html","title":"lower_equal_than – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sindex~~UsesGraph program~sindex sindex iso_fortran_env iso_fortran_env iso_fortran_env->program~sindex module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~sindex module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramsindexUsesGraph = svgPanZoom('#programsindexUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sindex test. Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. character(len=:), allocatable :: anothercharacter Another character. integer :: i Index result. integer :: ic Index result comparison. logical :: test_passed (6) List of passed tests. Source Code program sindex !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sindex` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % index ( substring = anothercharacter ) ic = index ( string = acharacter , substring = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Sindex basic call result: ' , i , ' is correct? ' , test_passed ( 1 ) i = astring % index ( substring = anothercharacter , back = . true .) ic = index ( string = acharacter , substring = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Sindex back call result: ' , i , ' is correct? ' , test_passed ( 2 ) i = index ( astring , substring = anothercharacter ) ic = index ( string = acharacter , substring = anothercharacter ) test_passed ( 3 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Index basic call result: ' , i , ' is correct? ' , test_passed ( 3 ) i = index ( astring , substring = anothercharacter , back = . true .) ic = index ( string = acharacter , substring = anothercharacter , back = . true .) test_passed ( 4 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Sindex back call result: ' , i , ' is correct? ' , test_passed ( 4 ) astring = anothercharacter i = index ( acharacter , substring = astring ) ic = index ( string = acharacter , substring = anothercharacter ) test_passed ( 5 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Index (inverted) basic call result: ' , i , ' is correct? ' , test_passed ( 5 ) astring = anothercharacter i = index ( acharacter , substring = astring , back = . true .) ic = index ( string = acharacter , substring = anothercharacter , back = . true .) test_passed ( 6 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Index (inverted) back call result: ' , i , ' is correct? ' , test_passed ( 6 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sindex","tags":"","loc":"program/sindex.html","title":"sindex – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~split~~UsesGraph program~split split iso_fortran_env iso_fortran_env iso_fortran_env->program~split module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~split module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramsplitUsesGraph = svgPanZoom('#programsplitUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor split test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ), allocatable :: strings (:) A set of strings. logical :: test_passed (5) List of passed tests. integer :: s Counter. Source Code program split !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `split` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. logical :: test_passed ( 5 ) !< List of passed tests. integer :: s !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '+ab-++cre-++cre-ab+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'ab-++cre-++cre-ab+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'ab-++cre-++cre-ab' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 3 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'Hello ' // new_line ( 'a' ) // 'World!' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"new_line\"' call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 4 ) = ( strings ( 1 ) // '' == 'Hello ' . and . strings ( 2 ) // '' == 'World!' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'Hello World!' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"default\" (namely space)' call astring % split ( tokens = strings ) test_passed ( 5 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == 'World!' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram split","tags":"","loc":"program/split.html","title":"split – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~is_integer~~UsesGraph program~is_integer is_integer iso_fortran_env iso_fortran_env iso_fortran_env->program~is_integer module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~is_integer module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramis_integerUsesGraph = svgPanZoom('#programis_integerUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor is_integer test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (6) List of passed tests. Source Code program is_integer !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_integer` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112 ' test_passed ( 1 ) = astring % is_integer (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () astring = '   -1212112' test_passed ( 2 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer (no spaces allowed)? ' , astring % is_integer ( allow_spaces = . false .) astring = '-1212112   ' test_passed ( 3 ) = astring % is_integer ( allow_spaces = . false .). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer (no spaces allowed)? ' , astring % is_integer ( allow_spaces = . false .) astring = '+2e20' test_passed ( 4 ) = astring % is_integer (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () astring = ' -2E13 ' test_passed ( 5 ) = astring % is_integer (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () astring = ' -2 E13 ' test_passed ( 6 ) = astring % is_integer (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is integer? ' , astring % is_integer () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_integer","tags":"","loc":"program/is_integer.html","title":"is_integer – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~join~~UsesGraph program~join join iso_fortran_env iso_fortran_env iso_fortran_env->program~join module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~join module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramjoinUsesGraph = svgPanZoom('#programjoinUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor join test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: strings (3) A set of strings. character(len=5) :: characters (3) A set of characters. logical :: test_passed (11) List of passed tests. integer :: s Counter. Source Code program join !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `join` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: strings ( 3 ) !< A set of strings. character ( 5 ) :: characters ( 3 ) !< A set of characters. logical :: test_passed ( 11 ) !< List of passed tests. integer :: s !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . strings ( 1 ) = 'one' strings ( 2 ) = 'two' strings ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (default sep) \"' // astring % join ( array = strings ) // '\"' test_passed ( 1 ) = ( astring % join ( array = strings ) // '' == strings ( 1 ) // strings ( 2 ) // strings ( 3 )) write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 2 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 ) // '-' // strings ( 3 )) call strings ( 1 )% free strings ( 2 ) = 'two' strings ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 3 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 2 ) // '-' // strings ( 3 )) strings ( 1 ) = 'one' strings ( 2 ) = 'two' call strings ( 3 )% free write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 4 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 2 )) strings ( 1 ) = 'one' call strings ( 2 )% free strings ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = strings , sep = '-' ) // '\"' test_passed ( 5 ) = ( astring % join ( array = strings , sep = '-' ) // '' == strings ( 1 ) // '-' // strings ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (default sep) \"' // astring % join ( array = characters ) // '\"' test_passed ( 6 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // characters ( 2 ) // characters ( 3 )) write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 7 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = '' characters ( 2 ) = 'two' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 8 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 2 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = '' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 9 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 2 )) characters ( 1 ) = 'one' characters ( 2 ) = '' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo write ( stdout , \"(A)\" ) 'join (sep=\"-\") \"' // astring % join ( array = characters , sep = '-' ) // '\"' test_passed ( 10 ) = ( astring % join ( array = characters , sep = '-' ) // '' == characters ( 1 ) // '-' // characters ( 3 )) characters ( 1 ) = 'one' characters ( 2 ) = 'two' characters ( 3 ) = 'three' write ( stdout , \"(A)\" ) 'Originals:' do s = 1 , size ( characters ) write ( stdout , \"(A)\" ) '+ \"' // characters ( s ) // '\"' enddo astring = '_' write ( stdout , \"(A)\" ) 'join (sep by astring) \"' // astring % join ( array = characters ) // '\"' test_passed ( 11 ) = ( astring % join ( array = characters ) // '' == characters ( 1 ) // '_' // characters ( 2 ) // '_' // characters ( 3 )) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram join","tags":"","loc":"program/join.html","title":"join – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~assignments~~UsesGraph program~assignments assignments iso_fortran_env iso_fortran_env iso_fortran_env->program~assignments module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~assignments module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramassignmentsUsesGraph = svgPanZoom('#programassignmentsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor assignments test. Variables Type Attributes Name Initial type( string ) :: astring A string. integer(kind=I1P) :: ainteger_I1P A integer (I1P). integer(kind=I2P) :: ainteger_I2P A integer (I2P). integer(kind=I4P) :: ainteger_I4P A integer (I4P). integer(kind=I8P) :: ainteger_I8P A integer (I8P). real(kind=R4P) :: areal_R4P A real (R4P). real(kind=R8P) :: areal_R8P A real (R8P). real(kind=R16P) :: areal_R16P A real (R16P). logical :: test_passed (7) List of passed tests. Source Code program assignments !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `assignments` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string , I1P , I2P , I4P , I8P , R4P , R8P , R16P !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. integer ( I1P ) :: ainteger_I1P !< A integer (I1P). integer ( I2P ) :: ainteger_I2P !< A integer (I2P). integer ( I4P ) :: ainteger_I4P !< A integer (I4P). integer ( I8P ) :: ainteger_I8P !< A integer (I8P). real ( R4P ) :: areal_R4P !< A real (R4P). real ( R8P ) :: areal_R8P !< A real (R8P). real ( R16P ) :: areal_R16P !< A real (R16P). logical :: test_passed ( 7 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . ainteger_I1P = 127_I1P astring = ainteger_I1P test_passed ( 1 ) = astring // '' == '+127' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 1 ) ainteger_I2P = 32767_I2P astring = ainteger_I2P test_passed ( 2 ) = astring // '' == '+32767' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 2 ) ainteger_I4P = 2147483647_I4P astring = ainteger_I4P test_passed ( 3 ) = astring // '' == '+2147483647' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 3 ) ainteger_I8P = - 9223372036854775807_I8P astring = ainteger_I8P test_passed ( 4 ) = astring // '' == '-9223372036854775807' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 4 ) areal_R4P = 3.021e6_R4P astring = areal_R4P test_passed ( 5 ) = astring // '' == '+0.302100E+07' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 5 ) areal_R8P = 7.00907641e23_R8P astring = areal_R8P test_passed ( 6 ) = astring // '' == '+0.700907641000000E+024' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 6 ) areal_R16P = 1.1e200_R16P astring = areal_R16P test_passed ( 7 ) = astring // '' == '+0.110000000000000000000000000000000E+0201' write ( stdout , \"(A,L1)\" ) 'Assigned to: \"' // astring // '\" is correct? ' , test_passed ( 7 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram assignments","tags":"","loc":"program/assignments.html","title":"assignments – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~greater_equal_than~~UsesGraph program~greater_equal_than greater_equal_than iso_fortran_env iso_fortran_env iso_fortran_env->program~greater_equal_than module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~greater_equal_than module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramgreater_equal_thanUsesGraph = svgPanZoom('#programgreater_equal_thanUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor greater_equal_than test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring A string. character(len=:), allocatable :: acharacter A character. logical :: test_passed (9) List of passed tests. Source Code program greater_equal_than !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `greater_equal_than` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 9 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'one' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 1 ) = (( astring >= anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring >= acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter >= astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '>=' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'ONE' anotherstring = 'one' acharacter = 'one' test_passed ( 4 ) = (( astring >= anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring >= acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter >= astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '>=' // astring // '\", test passed? ' , test_passed ( 6 ) astring = 'ONE' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 7 ) = (( astring >= anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // anotherstring // '\", test passed? ' , test_passed ( 7 ) test_passed ( 8 ) = (( astring >= acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>=' // acharacter // '\", test passed? ' , test_passed ( 8 ) test_passed ( 9 ) = (( acharacter >= astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '>=' // astring // '\", test passed? ' , test_passed ( 9 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram greater_equal_than","tags":"","loc":"program/greater_equal_than.html","title":"greater_equal_than – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sadjustlr~~UsesGraph program~sadjustlr sadjustlr iso_fortran_env iso_fortran_env iso_fortran_env->program~sadjustlr module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~sadjustlr module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramsadjustlrUsesGraph = svgPanZoom('#programsadjustlrUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sadjustlr test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (4) List of passed tests. Source Code program sadjustlr !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sadjustlr` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % adjustl () // '' == 'Hello World!   ' write ( stdout , \"(A,L1)\" ) 'AdjustL:  \"' // astring % adjustl () // '\", is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = adjustl ( astring ) // '' == 'Hello World!   ' write ( stdout , \"(A,L1)\" ) 'AdjustL (builtin):  \"' // adjustl ( astring ) // '\", is correct? ' , test_passed ( 2 ) astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 3 ) = astring % adjustr () // '' == '   Hello World!' write ( stdout , \"(A,L1)\" ) 'AdjustR:  \"' // astring % adjustr () // '\", is correct? ' , test_passed ( 3 ) test_passed ( 4 ) = adjustr ( astring ) // '' == '   Hello World!' write ( stdout , \"(A,L1)\" ) 'AdjustR (builtin):  \"' // adjustr ( astring ) // '\", is correct? ' , test_passed ( 4 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sadjustlr","tags":"","loc":"program/sadjustlr.html","title":"sadjustlr – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~io_formatted~~UsesGraph program~io_formatted io_formatted iso_fortran_env iso_fortran_env iso_fortran_env->program~io_formatted module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~io_formatted module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramio_formattedUsesGraph = svgPanZoom('#programio_formattedUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor io_formatted test. Bug Does not work for undelimited with terminators: ifort 16.0.3 Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. integer :: iostat IO status code. character(len=99) :: iomsg IO status message. logical :: test_passed (4) List of passed tests. Source Code program io_formatted !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `io_formatted` test. !< !< @bug Does not work for undelimited with terminators: ifort 16.0.3 !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit , IOSTAT_EOR use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none #ifndef __GFORTRAN__ type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. #endif logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . #ifndef __GFORTRAN__ acharacter = 'NoSpaces' read ( acharacter , * , iostat = iostat , iomsg = iomsg ) astring test_passed ( 1 ) = ( astring == 'NoSpaces' ) write ( stdout , \"(A,L1)\" ) 'Got \"' // astring // '\", is correct? ' , test_passed ( 1 ) if (. not . test_passed ( 1 )) then write ( stdout , \"(A,I3)\" ) ' iostat: ' , iostat write ( stdout , \"(A)\" ) ' iomsg: ' // trim ( iomsg ) endif acharacter = 'No quotes' ! read(acharacter, *, iostat=iostat, iomsg=iomsg) astring ! test_passed(2) = (astring == 'No') test_passed ( 2 ) = . true . write ( stdout , \"(A,L1)\" ) 'Got \"' // astring // '\", is correct? ' , test_passed ( 2 ) if (. not . test_passed ( 2 )) then write ( stdout , \"(A,I3)\" ) ' iostat: ' , iostat write ( stdout , \"(A)\" ) ' iomsg: ' // trim ( iomsg ) endif acharacter = '\"Has quotes\"' read ( acharacter , * , iostat = iostat , iomsg = iomsg ) astring test_passed ( 3 ) = ( astring == 'Has quotes' ) write ( stdout , \"(A,L1)\" ) 'Got \"' // astring // '\", is correct? ' , test_passed ( 3 ) if (. not . test_passed ( 3 )) then write ( stdout , \"(A,I3)\" ) ' iostat: ' , iostat write ( stdout , \"(A)\" ) ' iomsg: ' // trim ( iomsg ) endif acharacter = '\"Internal \"\" quotes\"' read ( acharacter , * , iostat = iostat , iomsg = iomsg ) astring test_passed ( 4 ) = ( astring == 'Internal \" quotes' ) write ( stdout , \"(A,L1)\" ) 'Got \"' // astring // '\", is correct? ' , test_passed ( 4 ) if (. not . test_passed ( 4 )) then write ( stdout , \"(A,I3)\" ) ' iostat: ' , iostat write ( stdout , \"(A)\" ) ' iomsg: ' // trim ( iomsg ) endif #else ! GNU gfortran does not support defined IO test_passed = . true . #endif write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram io_formatted","tags":"","loc":"program/io_formatted.html","title":"io_formatted – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~is_digit~~UsesGraph program~is_digit is_digit iso_fortran_env iso_fortran_env iso_fortran_env->program~is_digit module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~is_digit module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramis_digitUsesGraph = svgPanZoom('#programis_digitUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor is_digit test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program is_digit !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_digit` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112.3 ' test_passed ( 1 ) = astring % is_digit (). eqv .. false . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is digit? ' , astring % is_digit () astring = '12121123' test_passed ( 2 ) = astring % is_digit (). eqv .. true . write ( stdout , \"(A,L1)\" ) '\"' // astring // '\" is digit? ' , astring % is_digit () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_digit","tags":"","loc":"program/is_digit.html","title":"is_digit – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~greater_than~~UsesGraph program~greater_than greater_than iso_fortran_env iso_fortran_env iso_fortran_env->program~greater_than module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~greater_than module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramgreater_thanUsesGraph = svgPanZoom('#programgreater_thanUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor greater_than test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring A string. character(len=:), allocatable :: acharacter A character. logical :: test_passed (6) List of passed tests. Source Code program greater_than !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `greater_than` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'one' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 1 ) = (( astring > anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring > acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter > astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '>' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'ONE' anotherstring = 'one' acharacter = 'one' test_passed ( 4 ) = (( astring > anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring > acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '>' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter > astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '>' // astring // '\", test passed? ' , test_passed ( 6 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram greater_than","tags":"","loc":"program/greater_than.html","title":"greater_than – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sverify~~UsesGraph program~sverify sverify iso_fortran_env iso_fortran_env iso_fortran_env->program~sverify module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~sverify module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramsverifyUsesGraph = svgPanZoom('#programsverifyUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sverify test. Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. character(len=:), allocatable :: anothercharacter Another character. integer :: i Index result. integer :: ic Index result comparison. logical :: test_passed (3) List of passed tests. Source Code program sverify !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sverify` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % verify ( set = anothercharacter ) ic = verify ( string = acharacter , set = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , test_passed ( 1 ) i = astring % verify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , test_passed ( 2 ) anothercharacter = acharacter i = astring % verify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 3 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Identical strings call result: ' , i , ' is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sverify","tags":"","loc":"program/sverify.html","title":"sverify – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~strip~~UsesGraph program~strip strip iso_fortran_env iso_fortran_env iso_fortran_env->program~strip module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~strip module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramstripUsesGraph = svgPanZoom('#programstripUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor strip test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program strip !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strip` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % strip () // '' == 'Hello World!' write ( stdout , \"(A,L1)\" ) 'Strip:    \"' // astring % strip () // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strip","tags":"","loc":"program/strip.html","title":"strip – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~not_equal~~UsesGraph program~not_equal not_equal iso_fortran_env iso_fortran_env iso_fortran_env->program~not_equal module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~not_equal module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramnot_equalUsesGraph = svgPanZoom('#programnot_equalUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor not_equal test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring A string. character(len=:), allocatable :: acharacter A character. logical :: test_passed (6) List of passed tests. Source Code program not_equal !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `not_equal` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '  one ' anotherstring = 'two' acharacter = 'three' test_passed ( 1 ) = (( astring /= anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '/=' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring /= acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '/=' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter /= astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '/=' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'the same ' anotherstring = 'the same ' acharacter = 'the same ' test_passed ( 4 ) = (( astring /= anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '/=' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring /= acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '/=' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter /= astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '/=' // astring // '\", test passed? ' , test_passed ( 6 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram not_equal","tags":"","loc":"program/not_equal.html","title":"not_equal – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~basename_dir~~UsesGraph program~basename_dir basename_dir iso_fortran_env iso_fortran_env iso_fortran_env->program~basename_dir module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~basename_dir module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogrambasename_dirUsesGraph = svgPanZoom('#programbasename_dirUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor basename_dir test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (8) List of passed tests. Source Code program basename_dir !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `basename_dir` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '/bar/foo.tar.bz2' write ( stdout , \"(A)\" ) 'Original:                  \"' // astring // '\"' test_passed ( 1 ) = ( astring % basedir () // '' == '/bar' ) write ( stdout , \"(A)\" ) 'Basedir:                   \"' // astring % basedir () // '\"' test_passed ( 2 ) = ( astring % basename () // '' == 'foo.tar.bz2' ) write ( stdout , \"(A)\" ) 'Basename:                  \"' // astring % basename () // '\"' test_passed ( 3 ) = ( astring % basename ( extension = '.tar' ) // '' == 'foo' ) write ( stdout , \"(A)\" ) 'Basename (extension):      \"' // astring % basename ( extension = '.tar' ) // '\"' test_passed ( 4 ) = ( astring % basename ( strip_last_extension = . true .) // '' == 'foo.tar' ) write ( stdout , \"(A)\" ) 'Basename (last extension): \"' // astring % basename ( strip_last_extension = . true .) // '\"' astring = '\\bar\\foo.tar.bz2' write ( stdout , \"(A)\" ) 'Original (\\ sep):          \"' // astring // '\"' test_passed ( 5 ) = ( astring % basedir ( sep = '\\')//''==' \\ bar ') write(stdout, \"(A)\") ' Basedir : \"'//astring%basedir(sep='\\')//'\" ' test_passed(6) = (astring%basename(sep=' \\ ')//''==' foo . tar . bz2 ') write(stdout, \"(A)\") ' Basename : \"'//astring%basename(sep='\\')//'\" ' test_passed(7) = (astring%basename(sep=' \\ ', extension=' . tar ')//''==' foo ') write(stdout, \"(A)\") ' Basename ( extension ): \"'//astring%basename(sep='\\', extension='.tar')//'\" ' test_passed(8) = (astring%basename(sep=' \\ ', strip_last_extension=.true.)//''==' foo . tar ') write(stdout, \"(A)\") ' Basename ( last extension ): \"'//astring%basename(sep='\\', strip_last_extension=.true.)//'\" ' write(stdout, \"(A,L1)\") new_line(' a ')//' Are all tests passed ? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram basename_dir","tags":"","loc":"program/basename_dir.html","title":"basename_dir – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~unique~~UsesGraph program~unique unique iso_fortran_env iso_fortran_env iso_fortran_env->program~unique module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~unique module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramuniqueUsesGraph = svgPanZoom('#programuniqueUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor unique test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program unique !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `unique` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '+++ab-++cre-++cre-ab+++++' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % unique ( substring = '+' ) // '' == '+ab-+cre-+cre-ab+' write ( stdout , \"(A,L1)\" ) 'Unique:   \"' // astring % unique ( substring = '+' ) // '\", is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram unique","tags":"","loc":"program/unique.html","title":"unique – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~strim~~UsesGraph program~strim strim iso_fortran_env iso_fortran_env iso_fortran_env->program~strim module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~strim module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramstrimUsesGraph = svgPanZoom('#programstrimUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor strim test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program strim !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strim` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % trim () // '' == 'Hello World!' write ( stdout , \"(A,L1)\" ) 'Trimmed:  \"' // astring % trim () // '\", is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = trim ( astring ) // '' == 'Hello World!' write ( stdout , \"(A,L1)\" ) 'Trimmed (builtin):  \"' // trim ( astring ) // '\", is correct? ' , test_passed ( 2 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strim","tags":"","loc":"program/strim.html","title":"strim – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~slen~~UsesGraph program~slen slen iso_fortran_env iso_fortran_env iso_fortran_env->program~slen module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~slen module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramslenUsesGraph = svgPanZoom('#programslenUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor slen test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (4) List of passed tests. Source Code program slen !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `slen` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 4 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % len () == len ( 'Hello World!   ' ) write ( stdout , \"(A,I2,A,L1)\" ) 'Slen: ' , astring % len (), ' is correct? ' , test_passed ( 1 ) test_passed ( 2 ) = astring % len_trim () == len_trim ( 'Hello World!   ' ) write ( stdout , \"(A,I2,A,L1)\" ) 'Slen_trim: ' , astring % len_trim (), ' is correct? ' , test_passed ( 2 ) test_passed ( 3 ) = len ( astring ) == len ( 'Hello World!   ' ) write ( stdout , \"(A,I2,A,L1)\" ) 'Len: ' , len ( astring ), ' is correct? ' , test_passed ( 3 ) test_passed ( 4 ) = len_trim ( astring ) == len_trim ( 'Hello World!   ' ) write ( stdout , \"(A,I2,A,L1)\" ) 'Len_trim: ' , len_trim ( astring ), ' is correct? ' , test_passed ( 4 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram slen","tags":"","loc":"program/slen.html","title":"slen – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~read_lines~~UsesGraph program~read_lines read_lines iso_fortran_env iso_fortran_env iso_fortran_env->program~read_lines module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~read_lines module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramread_linesUsesGraph = svgPanZoom('#programread_linesUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor read_lines test. Calls program~~read_lines~~CallsGraph program~read_lines read_lines read_lines_standalone read_lines_standalone program~read_lines->read_lines_standalone Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ), allocatable :: strings (:) A set of strings. type( string ) :: line (3) Another set of string. integer :: iostat IO status code. character(len=99) :: iomsg IO status message. integer :: scratch Scratch file unit. integer :: l Counter. logical :: test_passed (16) List of passed tests. Source Code program read_lines !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `read_lines` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit , iostat_end use stringifor , only : read_lines_standalone => read_lines , string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. type ( string ) :: line ( 3 ) !< Another set of string. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. integer :: scratch !< Scratch file unit. integer :: l !< Counter. logical :: test_passed ( 16 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' open ( newunit = scratch , status = 'SCRATCH' ) write ( scratch , \"(A)\" ) line ( 1 )% chars () write ( scratch , \"(A)\" ) line ( 2 )% chars () write ( scratch , \"(A)\" ) line ( 3 )% chars () write ( stdout , \"(A)\" ) \"TBP read_lines\" call astring % read_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 1 ) enddo write ( stdout , \"(A)\" ) \"Standalone read_lines\" call read_lines_standalone ( unit = scratch , lines = strings , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat ). and . iostat /= iostat_end ) write ( stdout , \"(A)\" ) iomsg test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 5 ) enddo close ( scratch ) open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) write ( scratch ) line ( 1 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 2 )% chars () // new_line ( 'a' ) write ( scratch ) line ( 3 )% chars () // new_line ( 'a' ) write ( stdout , \"(A)\" ) \"TBP read_lines unformatted\" call astring % read_lines ( unit = scratch , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 9 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 9 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 9 ) enddo write ( stdout , \"(A)\" ) \"Standalone read_lines unformatted\" call read_lines_standalone ( unit = scratch , lines = strings , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0. and .. not . is_iostat_eor ( iostat ). and . iostat /= iostat_end ) write ( stdout , \"(A)\" ) iomsg test_passed ( 13 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 13 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 13 ) enddo close ( scratch ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram read_lines","tags":"","loc":"program/read_lines.html","title":"read_lines – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~capitalize~~UsesGraph program~capitalize capitalize iso_fortran_env iso_fortran_env iso_fortran_env->program~capitalize module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~capitalize module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramcapitalizeUsesGraph = svgPanZoom('#programcapitalizeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor capitalize test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program capitalize !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `capitalize` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'say all Hello WorLD!' test_passed ( 1 ) = astring % capitalize () // '' == 'Say all hello world!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Capitalize: \"' // astring % capitalize () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram capitalize","tags":"","loc":"program/capitalize.html","title":"capitalize – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~camelcase~~UsesGraph program~camelcase camelcase iso_fortran_env iso_fortran_env iso_fortran_env->program~camelcase module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~camelcase module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramcamelcaseUsesGraph = svgPanZoom('#programcamelcaseUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor camelcase test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program camelcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `camelcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'the Quick Brown fox Jumps over the Lazy Dog.' test_passed ( 1 ) = astring % camelcase () // '' == 'TheQuickBrownFoxJumpsOverTheLazyDog.' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Startcase: \"' // astring % camelcase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram camelcase","tags":"","loc":"program/camelcase.html","title":"camelcase – StringiFor"},{"text":"Uses: stringifor program~~csv_naive_parser~~UsesGraph program~csv_naive_parser csv_naive_parser module~stringifor stringifor module~stringifor->program~csv_naive_parser module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_stringify penf_stringify module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panprogramcsv_naive_parserUsesGraph = svgPanZoom('#programcsv_naive_parserUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor csv_naive_parser test. This is an example of th usefulness of StringiFor. Calls program~~csv_naive_parser~~CallsGraph program~csv_naive_parser csv_naive_parser proc~write_file write_file program~csv_naive_parser->proc~write_file proc~write_lines write_lines proc~write_file->proc~write_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: csv The CSV file as a single stream. type( string ), allocatable :: rows (:) The CSV table rows. type( string ), allocatable :: columns (:) The CSV table columns. type( string ), allocatable :: cells (:,:) The CSV table cells. type( string ) :: lines (4) The CSV file lines. type( string ) :: most_expensive The most expensive car. real(kind=R8P) :: highest_cost The highest cost. integer :: rows_number The CSV file rows number. integer :: columns_number The CSV file columns number. integer :: r Counter. logical :: test_passed (1) List of passed tests. Source Code program csv_naive_parser !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `csv_naive_parser` test. !< !< This is an example of th usefulness of StringiFor. !----------------------------------------------------------------------------------------------------------------------------------- use stringifor !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: csv !< The CSV file as a single stream. type ( string ), allocatable :: rows (:) !< The CSV table rows. type ( string ), allocatable :: columns (:) !< The CSV table columns. type ( string ), allocatable :: cells (:,:) !< The CSV table cells. type ( string ) :: lines ( 4 ) !< The CSV file lines. type ( string ) :: most_expensive !< The most expensive car. real ( R8P ) :: highest_cost !< The highest cost. integer :: rows_number !< The CSV file rows number. integer :: columns_number !< The CSV file columns number. integer :: r !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . ! a cars database lines ( 1 ) = 'Year,Make,Model,Description,Price' lines ( 2 ) = '1997,Ford,E350,ac abs moon,3000.00' lines ( 3 ) = '1999,Chevy,Venture \"Extended Edition\", ,4900.00' lines ( 4 ) = '1999,Chevy,Venture \"Extended Edition Very Large\", ,5000.00' ! preparing a CSV file test call write_file ( file = 'file_test_temp.csv' , lines = lines ) ! parsing the just created CSV file call csv % read_file ( file = 'file_test_temp.csv' ) ! read the CSV file as a single stream call csv % split ( tokens = rows , sep = new_line ( 'a' )) ! get the CSV file rows rows_number = size ( rows , dim = 1 ) ! get the CSV file rows number columns_number = rows ( 1 )% count ( ',' ) + 1 ! get the CSV file columns number allocate ( cells ( 1 : columns_number , 1 : rows_number )) ! allocate the CSV file cells do r = 1 , rows_number ! parse all cells call rows ( r )% split ( tokens = columns , sep = ',' ) ! get current columns cells ( 1 : columns_number , r ) = columns ! save current columns into cells enddo ! eliminating the file open ( newunit = r , file = 'file_test_temp.csv' ) ; close ( unit = r , status = 'DELETE' ) ! now you can do whatever with your parsed data ! print the table in markdown syntax print \"(A)\" , 'A markdown-formatted table' print \"(A)\" , '' print \"(A)\" , '|' // csv % join ( array = cells (:, 1 ), sep = '|' ) // '|' columns = '----' ! re-use columns for printing separators print \"(A)\" , '|' // csv % join ( array = columns , sep = '|' ) // '|' do r = 2 , rows_number print \"(A)\" , '|' // csv % join ( array = cells (:, r ), sep = '|' ) // '|' enddo print \"(A)\" , '' ! find the most expensive car print \"(A)\" , 'Searching for the most expensive car' most_expensive = 'unknown' highest_cost = - 1._R8P do r = 2 , rows_number if ( cells ( 5 , r )% to_number ( kind = 1._R8P ) >= highest_cost ) then highest_cost = cells ( 5 , r )% to_number ( kind = 1._R8P ) most_expensive = csv % join ( array = [ cells ( 2 , r ), cells ( 3 , r )], sep = ' ' ) endif enddo test_passed ( 1 ) = most_expensive // '' == 'Chevy Venture \"Extended Edition Very Large\"' print \"(A,L1)\" , 'The most expensive car is : ' // most_expensive // ', is correct? ' , test_passed ( 1 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram csv_naive_parser","tags":"","loc":"program/csv_naive_parser.html","title":"csv_naive_parser – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~extension~~UsesGraph program~extension extension iso_fortran_env iso_fortran_env iso_fortran_env->program~extension module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~extension module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramextensionUsesGraph = svgPanZoom('#programextensionUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor extension test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program extension !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `extension` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '/bar/foo.tar.bz2' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = ( astring % extension () // '' == '.bz2' ) write ( stdout , \"(A)\" ) 'Extension: \"' // astring % extension () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram extension","tags":"","loc":"program/extension.html","title":"extension – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~lower_than~~UsesGraph program~lower_than lower_than iso_fortran_env iso_fortran_env iso_fortran_env->program~lower_than module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~lower_than module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramlower_thanUsesGraph = svgPanZoom('#programlower_thanUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor lower_than test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring A string. character(len=:), allocatable :: acharacter A character. logical :: test_passed (6) List of passed tests. Source Code program lower_than !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `lower_than` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< A string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'one' anotherstring = 'ONE' acharacter = 'ONE' test_passed ( 1 ) = (( astring < anotherstring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<' // anotherstring // '\", test passed? ' , test_passed ( 1 ) test_passed ( 2 ) = (( astring < acharacter ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<' // acharacter // '\", test passed? ' , test_passed ( 2 ) test_passed ( 3 ) = (( acharacter < astring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '<' // astring // '\", test passed? ' , test_passed ( 3 ) astring = 'ONE' anotherstring = 'one' acharacter = 'one' test_passed ( 4 ) = (( astring < anotherstring ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<' // anotherstring // '\", test passed? ' , test_passed ( 4 ) test_passed ( 5 ) = (( astring < acharacter ). eqv .. true .) write ( stdout , \"(A,L1)\" ) 'Test \"' // astring // '<' // acharacter // '\", test passed? ' , test_passed ( 5 ) test_passed ( 6 ) = (( acharacter < astring ). eqv .. false .) write ( stdout , \"(A,L1)\" ) 'Test \"' // acharacter // '<' // astring // '\", test passed? ' , test_passed ( 6 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram lower_than","tags":"","loc":"program/lower_than.html","title":"lower_than – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~escape~~UsesGraph program~escape escape iso_fortran_env iso_fortran_env iso_fortran_env->program~escape module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~escape module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramescapeUsesGraph = svgPanZoom('#programescapeUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor escape test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program escape !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `escape` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '&#94;\\s \\d+\\s*' write ( stdout , \"(A)\" ) 'Original:  \"' // astring // '\"' test_passed ( 1 ) = ( astring % escape ( to_escape = '\\')//''==' &#94;\\\\ s \\\\ d + \\\\ s * ') write(stdout, \"(A)\") ' Escaped : \"'//astring%escape(to_escape='\\')//'\" ' write(stdout, \"(A,L1)\") new_line(' a ')//' Are all tests passed ? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram escape","tags":"","loc":"program/escape.html","title":"escape – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~write_lines~~UsesGraph program~write_lines write_lines iso_fortran_env iso_fortran_env iso_fortran_env->program~write_lines module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~write_lines module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramwrite_linesUsesGraph = svgPanZoom('#programwrite_linesUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor write_lines test. Calls program~~write_lines~~CallsGraph program~write_lines write_lines write_lines_standalone write_lines_standalone program~write_lines->write_lines_standalone Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring Another string. type( string ), allocatable :: strings (:) A set of strings. type( string ) :: line (3) Another set of string. integer :: iostat IO status code. character(len=99) :: iomsg IO status message. integer :: scratch Scratch file unit. integer :: l Counter. logical :: test_passed (16) List of passed tests. Source Code program write_lines !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `write_lines` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit , iostat_end use stringifor , only : string , write_lines_standalone => write_lines !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. type ( string ), allocatable :: strings (:) !< A set of strings. type ( string ) :: line ( 3 ) !< Another set of string. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. integer :: scratch !< Scratch file unit. integer :: l !< Counter. logical :: test_passed ( 16 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . line ( 1 ) = ' Hello World!   ' line ( 2 ) = 'How are you?  ' line ( 3 ) = '   All say: \"Fine thanks\"' anotherstring = anotherstring % join ( array = line , sep = new_line ( 'a' )) write ( stdout , \"(A)\" ) \"TBP write_lines\" open ( newunit = scratch , status = 'SCRATCH' ) call anotherstring % write_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 1 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 1 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 1 ) enddo close ( scratch ) write ( stdout , \"(A)\" ) \"Standalone write_lines\" open ( newunit = scratch , status = 'SCRATCH' ) call write_lines_standalone ( unit = scratch , lines = line , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_lines ( unit = scratch , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 5 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 5 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 5 ) enddo close ( scratch ) write ( stdout , \"(A)\" ) \"TBP write_lines unformatted\" open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) call anotherstring % write_lines ( unit = scratch , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_lines ( unit = scratch , form = 'UNFORMATTED' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 9 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 9 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 9 ) enddo close ( scratch ) write ( stdout , \"(A)\" ) \"Standalone write_lines unformatted\" open ( newunit = scratch , status = 'SCRATCH' , form = 'UNFORMATTED' , access = 'STREAM' ) call write_lines_standalone ( unit = scratch , lines = line , form = 'unformatted' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) write ( stdout , \"(A)\" ) iomsg call astring % read_lines ( unit = scratch , form = 'UNFORMATTED' , iostat = iostat , iomsg = iomsg ) call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 13 ) = ( size ( strings , dim = 1 ) == size ( line , dim = 1 )) do l = 1 , size ( strings , dim = 1 ) test_passed ( l + 13 ) = ( strings ( l ) == line ( l )) write ( stdout , \"(A,L1)\" ) 'line: \"' // strings ( l ) // '\", is correct? ' , test_passed ( l + 13 ) enddo close ( scratch ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram write_lines","tags":"","loc":"program/write_lines.html","title":"write_lines – StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~concatenation~~UsesGraph program~concatenation concatenation iso_fortran_env iso_fortran_env iso_fortran_env->program~concatenation module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~stringifor stringifor module~stringifor->program~concatenation module~stringifor_string_t stringifor_string_t module~stringifor_string_t->module~stringifor module~penf penf module~penf->module~stringifor module~penf->module~stringifor_string_t module~befor64~2 befor64 module~penf->module~befor64~2 module~befor64_pack_data_m befor64_pack_data_m module~penf->module~befor64_pack_data_m module~befor64~2->module~stringifor_string_t module~befor64_pack_data_m->module~befor64~2 module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf var panprogramconcatenationUsesGraph = svgPanZoom('#programconcatenationUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor concatenation test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring Another string. type( string ) :: yetanotherstring Yet another string. character(len=:), allocatable :: acharacter A character. logical :: test_passed (6) List of passed tests. Source Code program concatenation !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `concatenation` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. type ( string ) :: yetanotherstring !< Yet another string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello ' anotherstring = 'Bye bye' acharacter = 'World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // acharacter // '\"' test_passed ( 1 ) = astring // acharacter == 'Hello World!' write ( stdout , \"(A)\" ) astring // acharacter test_passed ( 2 ) = acharacter // astring == 'World!Hello ' write ( stdout , \"(A)\" ) 'Original: \"' // acharacter // '\"+\"' // astring // '\"' write ( stdout , \"(A)\" ) acharacter // astring test_passed ( 3 ) = astring // anotherstring == 'Hello Bye bye' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // anotherstring // '\"' write ( stdout , \"(A)\" ) astring // anotherstring yetanotherstring = astring . cat . acharacter test_passed ( 4 ) = yetanotherstring % chars () == 'Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // acharacter // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = acharacter . cat . astring test_passed ( 5 ) = yetanotherstring % chars () == 'World!Hello ' write ( stdout , \"(A)\" ) 'Original: \"' // acharacter // '\"+\"' // astring // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = astring . cat . anotherstring test_passed ( 6 ) = yetanotherstring % chars () == 'Hello Bye bye' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // anotherstring // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram concatenation","tags":"","loc":"program/concatenation.html","title":"concatenation – StringiFor"},{"text":"Uses: befor64 program~~test_driver~~UsesGraph program~test_driver Test_Driver module~befor64~2 befor64 module~befor64~2->program~test_driver module~befor64_pack_data_m befor64_pack_data_m module~befor64_pack_data_m->module~befor64~2 module~penf penf module~penf->module~befor64~2 module~penf->module~befor64_pack_data_m module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_stringify penf_stringify module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panprogramtest_driverUsesGraph = svgPanZoom('#programtest_driverUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Testing program for BeFoR64, Base64 encoding/decoding library for FoRtran poor men Usage ./Test_Driver Calls program~~test_driver~~CallsGraph program~test_driver Test_Driver proc~autotest autotest program~test_driver->proc~autotest interface~b64_decode b64_decode proc~autotest->interface~b64_decode proc~b64_init b64_init proc~autotest->proc~b64_init interface~str str proc~autotest->interface~str interface~b64_encode b64_encode proc~autotest->interface~b64_encode proc~b64_decode_i4_a b64_decode_I4_a interface~b64_decode->proc~b64_decode_i4_a proc~b64_decode_r8 b64_decode_R8 interface~b64_decode->proc~b64_decode_r8 proc~b64_decode_i1 b64_decode_I1 interface~b64_decode->proc~b64_decode_i1 proc~b64_decode_r8_a b64_decode_R8_a interface~b64_decode->proc~b64_decode_r8_a proc~b64_decode_r4 b64_decode_R4 interface~b64_decode->proc~b64_decode_r4 proc~b64_decode_i1_a b64_decode_I1_a interface~b64_decode->proc~b64_decode_i1_a proc~b64_decode_string_a b64_decode_string_a interface~b64_decode->proc~b64_decode_string_a proc~b64_decode_r4_a b64_decode_R4_a interface~b64_decode->proc~b64_decode_r4_a proc~b64_decode_i8 b64_decode_I8 interface~b64_decode->proc~b64_decode_i8 proc~b64_decode_i2 b64_decode_I2 interface~b64_decode->proc~b64_decode_i2 proc~b64_decode_i8_a b64_decode_I8_a interface~b64_decode->proc~b64_decode_i8_a proc~b64_decode_string b64_decode_string interface~b64_decode->proc~b64_decode_string proc~b64_decode_i4 b64_decode_I4 interface~b64_decode->proc~b64_decode_i4 proc~b64_decode_i2_a b64_decode_I2_a interface~b64_decode->proc~b64_decode_i2_a proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~b64_encode_r8 b64_encode_R8 interface~b64_encode->proc~b64_encode_r8 proc~b64_encode_i1 b64_encode_I1 interface~b64_encode->proc~b64_encode_i1 proc~b64_encode_i4_a b64_encode_I4_a interface~b64_encode->proc~b64_encode_i4_a proc~b64_encode_i1_a b64_encode_I1_a interface~b64_encode->proc~b64_encode_i1_a proc~b64_encode_string b64_encode_string interface~b64_encode->proc~b64_encode_string proc~b64_encode_r4_a b64_encode_R4_a interface~b64_encode->proc~b64_encode_r4_a proc~b64_encode_r4 b64_encode_R4 interface~b64_encode->proc~b64_encode_r4 proc~b64_encode_string_a b64_encode_string_a interface~b64_encode->proc~b64_encode_string_a proc~b64_encode_i8 b64_encode_I8 interface~b64_encode->proc~b64_encode_i8 proc~b64_encode_i2 b64_encode_I2 interface~b64_encode->proc~b64_encode_i2 proc~b64_encode_r8_a b64_encode_R8_a interface~b64_encode->proc~b64_encode_r8_a proc~b64_encode_i2_a b64_encode_I2_a interface~b64_encode->proc~b64_encode_i2_a proc~b64_encode_i4 b64_encode_I4 interface~b64_encode->proc~b64_encode_i4 proc~b64_encode_i8_a b64_encode_I8_a interface~b64_encode->proc~b64_encode_i8_a proc~decode_bits decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_i1->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits interface~byte_size byte_size proc~b64_decode_string_a->interface~byte_size proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_i8->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_string->proc~decode_bits proc~b64_decode_string->interface~byte_size proc~b64_decode_i4->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p proc~encode_bits encode_bits proc~b64_encode_r8->proc~encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_string->interface~byte_size proc~b64_encode_string->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_string_a->interface~byte_size proc~b64_encode_string_a->proc~encode_bits proc~b64_encode_i8->proc~encode_bits proc~b64_encode_i2->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i4->proc~encode_bits proc~b64_encode_i8_a->proc~encode_bits var panprogramtest_driverCallsGraph = svgPanZoom('#programtest_driverCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code program Test_Driver !----------------------------------------------------------------------------------------------------------------------------------- !< Testing program for BeFoR64, Base64 encoding/decoding library for FoRtran poor men !< !<### Usage !<```bash !< ./Test_Driver !<``` !----------------------------------------------------------------------------------------------------------------------------------- use befor64 , only : autotest ! Autotesting procedure. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- print \"(A)\" , 'Testing BeFoR64' call autotest stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram Test_Driver","tags":"","loc":"program/test_driver.html","title":"Test_Driver – StringiFor"},{"text":"Uses: penf iso_fortran_env program~~test_all~~UsesGraph program~test_all test_all module~penf penf module~penf->program~test_all iso_fortran_env iso_fortran_env iso_fortran_env->program~test_all module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF's testing program. Usage ./test_all Calls program~~test_all~~CallsGraph program~test_all test_all proc~penf_init penf_init program~test_all->proc~penf_init interface~strz strz program~test_all->interface~strz interface~bcton bcton program~test_all->interface~bcton proc~penf_print penf_print program~test_all->proc~penf_print interface~cton cton program~test_all->interface~cton interface~bstr bstr program~test_all->interface~bstr interface~digit digit program~test_all->interface~digit interface~str str program~test_all->interface~str proc~check_endian check_endian proc~penf_init->proc~check_endian proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p proc~bctoi_i8p bctoi_I8P interface~bcton->proc~bctoi_i8p proc~bctoi_i4p bctoi_I4P interface~bcton->proc~bctoi_i4p proc~bctoi_i1p bctoi_I1P interface~bcton->proc~bctoi_i1p proc~bctoi_i2p bctoi_I2P interface~bcton->proc~bctoi_i2p proc~bctor_r8p bctor_R8P interface~bcton->proc~bctor_r8p proc~bctor_r4p bctor_R4P interface~bcton->proc~bctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~bstr_i8p bstr_I8P interface~bstr->proc~bstr_i8p proc~bstr_r8p bstr_R8P interface~bstr->proc~bstr_r8p proc~bstr_i1p bstr_I1P interface~bstr->proc~bstr_i1p proc~bstr_i4p bstr_I4P interface~bstr->proc~bstr_i4p proc~bstr_r4p bstr_R4P interface~bstr->proc~bstr_r4p proc~bstr_i2p bstr_I2P interface~bstr->proc~bstr_i2p proc~digit_i4 digit_I4 interface~digit->proc~digit_i4 proc~digit_i1 digit_I1 interface~digit->proc~digit_i1 proc~digit_i8 digit_I8 interface~digit->proc~digit_i8 proc~digit_i2 digit_I2 interface~digit->proc~digit_i2 proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p none~is_little_endian is_little_endian proc~check_endian->none~is_little_endian proc~bctoi_i8p->interface~str proc~bctoi_i4p->interface~str proc~bctoi_i1p->interface~str proc~bctoi_i2p->interface~str proc~bctor_r8p->interface~str proc~bctor_r4p->interface~str proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code program test_all !----------------------------------------------------------------------------------------------------------------------------------- !< PENF's testing program. !< !<### Usage !<```bash !< ./test_all !<``` !----------------------------------------------------------------------------------------------------------------------------------- use penf use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call penf_Init call penf_Print ( unit = stdout ) print \"(A)\" , '' print \"(A)\" , 'Testing IR_Precision tools' print \"(A)\" , 'Casting real-to-string: ' // str ( n = 1._R8P ) print \"(A)\" , 'Casting integer-to-string: ' // str ( n = 11_I8P ) print \"(A,\" // FR8P // \")\" , 'Casting string-to-real: ' , cton ( str = '2.2d0' , knd = 1._R8P ) print \"(A,\" // FI4P // \")\" , 'Casting integer-to-string: ' , cton ( str = '43' , knd = 1_I4P ) print \"(A)\" , 'Casting integer-to-string with zero padding: ' // trim ( strz ( nz_pad = 3 , n = 34_I8P )) #ifndef __GFORTRAN__ print \"(A)\" , 'Casting real-to-bit_string: ' // bstr ( n = 1._R4P ) #endif print \"(A)\" , 'Casting integer-to-bit_string: ' // bstr ( n = 1_I4P ) #ifndef __GFORTRAN__ print \"(A,\" // FR4P // \")\" , 'Casting bit_string-to-real: ' , bcton ( bstr = '00111111100000000000000000000000' , knd = 1._R4P ) #endif print \"(A,\" // FI4P // \")\" , 'Casting bit_string-to-integer: ' , bcton ( bstr = '00000000000000000000000000000001' , knd = 1_I4P ) print \"(A)\" , 'Number of digit of 1023: ' // str ( n = digit ( 1023_I4P )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_all","tags":"","loc":"program/test_all.html","title":"test_all – StringiFor"},{"text":"Uses: penf iso_fortran_env program~~test_all~2~~UsesGraph program~test_all~2 test_all module~penf penf module~penf->program~test_all~2 iso_fortran_env iso_fortran_env iso_fortran_env->program~test_all~2 module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables~3 penf_global_parameters_variables module~penf_global_parameters_variables~3->module~penf module~penf_b_size~2 penf_b_size module~penf_global_parameters_variables~3->module~penf_b_size~2 module~penf_global_parameters_variables~3->module~penf_stringify module~penf_b_size~2->module~penf module~penf_b_size~2->module~penf_stringify module~penf_stringify->module~penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. PENF's testing program. Usage ./test_all Calls program~~test_all~2~~CallsGraph program~test_all~2 test_all proc~penf_init penf_init program~test_all~2->proc~penf_init interface~strz strz program~test_all~2->interface~strz interface~bcton bcton program~test_all~2->interface~bcton proc~penf_print penf_print program~test_all~2->proc~penf_print interface~cton cton program~test_all~2->interface~cton interface~bstr bstr program~test_all~2->interface~bstr interface~digit digit program~test_all~2->interface~digit interface~str str program~test_all~2->interface~str proc~check_endian check_endian proc~penf_init->proc~check_endian proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p proc~bctoi_i8p bctoi_I8P interface~bcton->proc~bctoi_i8p proc~bctoi_i4p bctoi_I4P interface~bcton->proc~bctoi_i4p proc~bctoi_i1p bctoi_I1P interface~bcton->proc~bctoi_i1p proc~bctoi_i2p bctoi_I2P interface~bcton->proc~bctoi_i2p proc~bctor_r8p bctor_R8P interface~bcton->proc~bctor_r8p proc~bctor_r4p bctor_R4P interface~bcton->proc~bctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~bstr_i8p bstr_I8P interface~bstr->proc~bstr_i8p proc~bstr_r8p bstr_R8P interface~bstr->proc~bstr_r8p proc~bstr_i1p bstr_I1P interface~bstr->proc~bstr_i1p proc~bstr_i4p bstr_I4P interface~bstr->proc~bstr_i4p proc~bstr_r4p bstr_R4P interface~bstr->proc~bstr_r4p proc~bstr_i2p bstr_I2P interface~bstr->proc~bstr_i2p proc~digit_i4 digit_I4 interface~digit->proc~digit_i4 proc~digit_i1 digit_I1 interface~digit->proc~digit_i1 proc~digit_i8 digit_I8 interface~digit->proc~digit_i8 proc~digit_i2 digit_I2 interface~digit->proc~digit_i2 proc~str_r8p str_R8P interface~str->proc~str_r8p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~str_i1p str_I1P interface~str->proc~str_i1p none~is_little_endian is_little_endian proc~check_endian->none~is_little_endian proc~bctoi_i8p->interface~str proc~bctoi_i4p->interface~str proc~bctoi_i1p->interface~str proc~bctoi_i2p->interface~str proc~bctor_r8p->interface~str proc~bctor_r4p->interface~str proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_i4p->proc~str_i4p proc~str_a_r8p->proc~str_r8p proc~str_a_i8p->proc~str_i8p proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code program test_all !----------------------------------------------------------------------------------------------------------------------------------- !< PENF's testing program. !< !<### Usage !<```bash !< ./test_all !<``` !----------------------------------------------------------------------------------------------------------------------------------- use penf use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- call penf_Init call penf_Print ( unit = stdout ) print \"(A)\" , '' print \"(A)\" , 'Testing IR_Precision tools' print \"(A)\" , 'Casting real-to-string: ' // str ( n = 1._R8P ) print \"(A)\" , 'Casting integer-to-string: ' // str ( n = 11_I8P ) print \"(A,\" // FR8P // \")\" , 'Casting string-to-real: ' , cton ( str = '2.2d0' , knd = 1._R8P ) print \"(A,\" // FI4P // \")\" , 'Casting integer-to-string: ' , cton ( str = '43' , knd = 1_I4P ) print \"(A)\" , 'Casting integer-to-string with zero padding: ' // trim ( strz ( nz_pad = 3 , n = 34_I8P )) #ifndef __GFORTRAN__ print \"(A)\" , 'Casting real-to-bit_string: ' // bstr ( n = 1._R4P ) #endif print \"(A)\" , 'Casting integer-to-bit_string: ' // bstr ( n = 1_I4P ) #ifndef __GFORTRAN__ print \"(A,\" // FR4P // \")\" , 'Casting bit_string-to-real: ' , bcton ( bstr = '00111111100000000000000000000000' , knd = 1._R4P ) #endif print \"(A,\" // FI4P // \")\" , 'Casting bit_string-to-integer: ' , bcton ( bstr = '00000000000000000000000000000001' , knd = 1_I4P ) print \"(A)\" , 'Number of digit of 1023: ' // str ( n = digit ( 1023_I4P )) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram test_all","tags":"","loc":"program/test_all~2.html","title":"test_all – StringiFor"}]}