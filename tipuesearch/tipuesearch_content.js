var tipuesearch = {"pages":[{"text":"StringiFor StringiFor StringiFor, Strings Fortran Manipulator, yet another strings Fortran module A KISS pure Fortran library providing  astrings (class) manipulator for modern (2003+) Fortran projects. StringiFor is a pure Fortran (KISS) library providing a strings manipulator for modern Fortran projects; StringiFor is Fortran 2003+ standard compliant; StringiFor is OOP designed; StringiFor is TDD designed; StringiFor is a Free, Open Source Project. Table of Contents What is StringiFor? Main features Copyrights Documentation A Taste of StringiFor Issues Compiler Support GNU partial support GNU gfortran does not support user-defined-type-IO, thus some class features are disabled if GNU is used. What is StringiFor? Modern Fortran standards (2003+) have introduced a better support for characters variables, but Fortraners still do not have the power on dealing with strings of other more-rich-programmers, e.g. Pythoners. Allocatable deferred length character variables are now quantum-leap with respect the old inflexible Fortran characters, but it is still not enough for many Fortraners. Moreover, Fortran does not provide builtin methods for widely used strings manipulations offered by other languages, e.g. UPPER/lowercase transformation, tokenization, etcâ€¦ StringiFor attempts to fill this lack. Go to Top Main features StringiFor exposes only one class (OO-designed), the string type, that should be used as a more powerful string variable with respect a standard Fortran character variable. The main features of this class are: seamless interchangeability with standard character variables, i.e.: I/O operation (disabled if GNU gfortran is used); string/character concatenation; string/character assignment; handy builtin methods: UPPER/lower case transformartion; tokenization; number-to-string (and viceversa) casting; Any feature request is welcome. Go to Top Copyrights StringiFor is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to StringiFor is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the StringiFor documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of StringiFor To be written. Go to Top Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" StringiFor "},{"text":"StringiFor, Strings Fortran, yet another stringify Fortran module Source Code !< StringiFor, Strings Fortran, yet another stringify Fortran module module stringifor !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor, Strings Fortran, yet another stringify Fortran module !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: string , CK !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- integer , parameter :: CK = selected_char_kind ( 'DEFAULT' ) !< Default character kind. type :: string !< OOP designed string class. private character ( kind = CK , len = :), allocatable :: raw !< Raw data. contains ! public methods procedure , pass ( self ) :: free !< Free dynamic memory. procedure , pass ( self ) :: chars !< Return the raw characters data. procedure , pass ( self ) :: upper !< Return a string with all uppercase characters. procedure , pass ( self ) :: lower !< Return a string with all lowercase characters. procedure , pass ( self ) :: capitalize !< Return a string with its first character capitalized and the rest lowercased. procedure , pass ( self ) :: partition !< Split string at separator and return the 3 parts (before, the separator and after). procedure , pass ( self ) :: replace !< Return a string with all occurrences of substring old replaced by new. procedure , pass ( self ) :: split !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: strip !< Return a copy of the string with the leading and trailing characters removed. procedure , pass ( self ) :: swapcase !< Return a copy of the string with uppercase chars converted to lowercase and vice versa. procedure , pass ( self ) :: unique !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. ! inquire procedure , pass ( self ) :: is_allocated !< Return true if the string is allocated. procedure , pass ( self ) :: is_upper !< Return true if all characters in the string are uppercase. procedure , pass ( self ) :: is_lower !< Return true if all characters in the string are lowercase. procedure , pass ( self ) :: is_digit !< Return true if all characters in the string are digits. procedure , pass ( self ) :: end_with !< Return true if a string ends with a specified suffix. procedure , pass ( self ) :: start_with !< Return true if a string starts with a specified prefix. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character !< Assignment operator overloading. generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. ! builtins replacements procedure , pass ( self ) :: sadjustl !< Adjustl replacement. procedure , pass ( self ) :: sadjustr !< Adjustr replacement. procedure , pass ( self ) :: scount !< Count replacement. procedure , pass ( self ) :: sindex !< Index replacement. procedure , pass ( self ) :: slen !< Len replacement. procedure , pass ( self ) :: slen_trim !< Len_trim replacement. procedure , nopass :: srepeat !< Repeat replacement. procedure , pass ( self ) :: sscan !< Scan replacement. procedure , pass ( self ) :: strim !< Trim replacement. procedure , pass ( self ) :: sverify !< Verify replacement. ! IO #ifndef __GFORTRAN__ generic :: read ( formatted ) => read_formatted_ !< Formatted input. generic :: write ( formatted ) => write_formatted_ !< Formatted output. generic :: read ( unformatted ) => read_unformatted_ !< Unformatted input. generic :: write ( unformatted ) => write_unformatted_ !< Unformatted output. #else procedure , pass ( dtv ) :: read_formatted => read_formatted_ !< Formatted input. procedure , pass ( dtv ) :: read_formatted_internal !< Formatted input from internal. procedure , pass ( dtv ) :: write_formatted => write_formatted_ !< Formatted output. procedure , pass ( dtv ) :: write_formatted_internal !< Formatted output to internal. #endif ! private methods procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). procedure , private , pass ( dtv ) :: read_formatted_ !< Formatted input. procedure , private , pass ( dtv ) :: write_formatted_ !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted_ !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted_ !< Unformatted output. procedure , private , pass ( self ) :: replace_one_occurrence !< Replace the first occurrence of substring old by new. endtype string character ( kind = CK , len = 26 ), parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !< Upper case alphabet. character ( kind = CK , len = 26 ), parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' !< Lower case alphabet. character ( kind = CK , len =* ), parameter :: SPACE = ' ' !< Space character. !----------------------------------------------------------------------------------------------------------------------------------- contains ! public methods elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) deallocate ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars elemental function upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all uppercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then upper = self do n1 = 1 , len ( self % raw ) n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) upper % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper elemental function lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all lowercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: lower !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then lower = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) lower % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lower elemental function capitalize ( self ) result ( capitalized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with its first character capitalized and the rest lowercased. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction capitalize pure function partition ( self , sep ) result ( partitions ) !--------------------------------------------------------------------------------------------------------------------------------- !< Split string at separator and return the 3 parts (before, the separator and after). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: partitions ( 1 : 3 ) !< Partions: before the separator, the separator itsels and !< after the separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: c !< Character counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep partitions ( 1 ) = self partitions ( 2 ) = sep_ partitions ( 3 ) = '' if ( len ( sep_ ) >= len ( self % raw )) return c = index ( self % raw , sep_ ) if ( c > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw partitions ( 1 )% raw = temporary ( 1 : c - 1 ) partitions ( 2 )% raw = temporary ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = temporary ( c + len ( sep_ ):) #else partitions ( 1 )% raw = self % raw ( 1 : c - 1 ) partitions ( 2 )% raw = self % raw ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = self % raw ( c + len ( sep_ ):) #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction partition elemental function replace ( self , old , new , count ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all occurrences of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. integer , intent ( in ), optional :: count !< Number of old occurences to be replaced. type ( string ) :: replaced !< The string with old replaced by new. integer :: r !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self r = 0 do if ( index ( replaced % raw , old ) > 0 ) then replaced = replaced % replace_one_occurrence ( old = old , new = new ) r = r + 1 if ( present ( count )) then if ( r >= count ) exit endif else exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace pure subroutine split ( self , tokens , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a list of substring in the string, using sep as the delimiter string. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: No !< Number of occurrences of sep. integer :: t !< Character counter. type ( string ) :: temporary !< Temporary storage. type ( string ), allocatable :: temp_toks (:,:) !< Temporary tokens substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep temporary = self % unique ( sep_ ) No = temporary % scount ( sep_ ) allocate ( temp_toks ( 3 , No )) temp_toks (:, 1 ) = temporary % partition ( sep_ ) if ( No > 1 ) then do t = 2 , No temp_toks (:, t ) = temp_toks ( 3 , t - 1 )% partition ( sep_ ) enddo endif if ( temp_toks ( 1 , 1 )% raw /= '' . and . temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No + 1 )) do t = 1 , No if ( t == No ) then tokens ( t ) = temp_toks ( 1 , t ) tokens ( t + 1 ) = temp_toks ( 3 , t ) else tokens ( t ) = temp_toks ( 1 , t ) endif enddo elseif ( temp_toks ( 1 , 1 )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No tokens ( t ) = temp_toks ( 1 , t ) enddo elseif ( temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No )) do t = 2 , No if ( t == No ) then tokens ( t - 1 ) = temp_toks ( 1 , t ) tokens ( t ) = temp_toks ( 3 , t ) else tokens ( t - 1 ) = temp_toks ( 1 , t ) endif enddo else allocate ( tokens ( No - 1 )) do t = 2 , No tokens ( t - 1 ) = temp_toks ( 1 , t ) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine split elemental function strip ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with the leading and trailing characters removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: strip !< The stripped string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then strip = self % sadjustl () strip = strip % strim () endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strip elemental function swapcase ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with uppercase characters converted to lowercase and vice versa. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: swapcase !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then swapcase = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) then swapcase % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) else n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) swapcase % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction swapcase elemental function unique ( self , substring ) result ( uniq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: substring !< Substring which multiple occurences must be reduced to one. character ( kind = CK , len = :), allocatable :: substring_ !< Substring, default value. type ( string ) :: uniq !< String parsed. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then substring_ = SPACE ; if ( present ( substring )) substring_ = substring uniq = self do if (. not . uniq % sindex ( repeat ( substring_ , 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( substring_ , 2 ), new = substring_ ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unique ! inquire elemental function is_allocated ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string is allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_allocated !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_allocated = allocated ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_allocated elemental function is_digit ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are digits. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_digit !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_digit = . false . if ( allocated ( self % raw )) then do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( '0' : '9' ) is_digit = . true . case default is_digit = . false . exit end select enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_digit elemental function is_upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are uppercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_upper !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_upper = . false . if ( allocated ( self % raw )) then is_upper = . true . do c = 1 , len ( self % raw ) if ( index ( LOWER_ALPHABET , self % raw ( c : c )) > 0 ) then is_upper = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_upper elemental function is_lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are lowercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_lower !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_lower = . false . if ( allocated ( self % raw )) then is_lower = . true . do c = 1 , len ( self % raw ) if ( index ( UPPER_ALPHABET , self % raw ( c : c )) > 0 ) then is_lower = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_lower elemental function end_with ( self , suffix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string ends with a specified suffix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: suffix !< Searched suffix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: end_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- end_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( suffix ) <= len ( self % raw ( start_ : end_ ))) then end_with = index ( self % raw ( start_ : end_ ), suffix ) == ( len ( self % raw ( start_ : end_ )) - len ( suffix ) + 1 ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction end_with elemental function start_with ( self , prefix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string starts with a specified prefix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: prefix !< Searched prefix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: start_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- start_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( prefix ) <= len ( self % raw ( start_ : end_ ))) then start_with = index ( self % raw ( start_ : end_ ), prefix ) == 1 endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction start_with ! builtins replacements elemental function sadjustl ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl elemental function sadjustr ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr elemental function scount ( self , substring , ignore_isolated ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !< !< @note If `ignore_isolated` is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those !< occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a !< right companion). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: substring !< Substring. logical , intent ( in ), optional :: ignore_isolated !< Ignore \"isolated\" occurrences. integer :: No !< Number of occurrences. logical :: ignore_isolated_ !< Ignore \"isolated\" occurrences, local variable. integer :: c1 !< Counter. integer :: c2 !< Counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( allocated ( self % raw )) then if ( len ( substring ) > len ( self % raw )) return ignore_isolated_ = . false . ; if ( present ( ignore_isolated )) ignore_isolated_ = ignore_isolated #ifdef __GFORTRAN__ temporary = self % raw #endif c1 = 1 do #ifdef __GFORTRAN__ c2 = index ( string = temporary ( c1 :), substring = substring ) #else c2 = index ( string = self % raw ( c1 :), substring = substring ) #endif if ( c2 == 0 ) return if (. not .( ignore_isolated_ . and .( c1 == 1. or . c1 + c2 - 1 == len ( self % raw ) - len ( substring ) + 1 ))) then No = No + 1 endif c1 = c1 + c2 - 1 + len ( substring ) enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction scount elemental function sindex ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex elemental function slen ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen elemental function slen_trim ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string, ignoring any trailing blanks. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen_trim elemental function srepeat ( rstring , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = rstring , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat elemental function sscan ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan elemental function strim ( self ) result ( trimmed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Remove leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strim elemental function sverify ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sverify ! private methods elemental subroutine string_assign_string ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from string input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) lhs % raw = rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_string elemental subroutine string_assign_character ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from character input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_character pure function string_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string pure function string_concat_character ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character pure function character_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string elemental function string_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( kind = CK , len = :), allocatable :: temporary !< Temporary concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string_string elemental function string_concat_character_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character_string elemental function character_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string_string subroutine read_formatted_ ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted_ subroutine read_formatted_internal ( dtv , iunit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input from internal. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. character ( kind = CK , len =* ), intent ( in ) :: iunit !< Internal unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted_internal subroutine write_formatted_ ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted_ subroutine write_formatted_internal ( dtv , iunit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output to internal. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. character ( kind = CK , len =* ), intent ( inout ) :: iunit !< Interanl unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted_internal subroutine read_unformatted_ ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_unformatted_ subroutine write_unformatted_ ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_unformatted_ elemental function replace_one_occurrence ( self , old , new ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with the first occurrence of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. type ( string ) :: replaced !< The string with old replaced by new. integer :: pos !< Position from which replace old. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self pos = index ( string = self % raw , substring = old ) if ( pos > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw if ( pos == 1 ) then replaced % raw = new // temporary ( len ( old ) + 1 :) else replaced % raw = temporary ( 1 : pos - 1 ) // new // temporary ( pos + len ( old ):) endif #else if ( pos == 1 ) then replaced % raw = new // self % raw ( len ( old ) + 1 :) else replaced % raw = self % raw ( 1 : pos - 1 ) // new // self % raw ( pos + len ( old ):) endif #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace_one_occurrence endmodule stringifor","tags":"","loc":"sourcefile/stringifor.f90.html","title":"stringifor.F90 â€“ StringiFor"},{"text":"StringiFor capitalize test. Source Code !< StringiFor `capitalize` test. program capitalize !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `capitalize` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'say all Hello WorLD!' test_passed ( 1 ) = astring % capitalize () // '' == 'Say all hello world!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Capitalize: \"' // astring % capitalize () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram capitalize","tags":"","loc":"sourcefile/capitalize.f90.html","title":"capitalize.f90 â€“ StringiFor"},{"text":"StringiFor concatenation test. Source Code !< StringiFor `concatenation` test. program concatenation !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `concatenation` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. type ( string ) :: yetanotherstring !< Yet another string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello ' anotherstring = 'Bye bye' acharacter = 'World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // acharacter // '\"' test_passed ( 1 ) = astring // acharacter == 'Hello World!' write ( stdout , \"(A)\" ) astring // acharacter test_passed ( 2 ) = acharacter // astring == 'World!Hello ' write ( stdout , \"(A)\" ) 'Original: \"' // acharacter // '\"+\"' // astring // '\"' write ( stdout , \"(A)\" ) acharacter // astring test_passed ( 3 ) = astring // anotherstring == 'Hello Bye bye' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // anotherstring // '\"' write ( stdout , \"(A)\" ) astring // anotherstring yetanotherstring = astring . cat . acharacter test_passed ( 4 ) = yetanotherstring % chars () == 'Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // acharacter // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = acharacter . cat . astring test_passed ( 5 ) = yetanotherstring % chars () == 'World!Hello ' write ( stdout , \"(A)\" ) 'Original: \"' // acharacter // '\"+\"' // astring // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = astring . cat . anotherstring test_passed ( 6 ) = yetanotherstring % chars () == 'Hello Bye bye' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // anotherstring // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram concatenation","tags":"","loc":"sourcefile/concatenation.f90.html","title":"concatenation.f90 â€“ StringiFor"},{"text":"StringiFor free test. Source Code !< StringiFor `free` test. program free !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `free` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'say all Hello WorLD!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % is_allocated (). eqv .. true . write ( stdout , \"(A,L1)\" ) 'Is allocated? ' , astring % is_allocated () call astring % free test_passed ( 2 ) = astring % is_allocated (). eqv .. false . write ( stdout , \"(A,L1)\" ) 'Is allocated? ' , astring % is_allocated () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram free","tags":"","loc":"sourcefile/free.f90.html","title":"free.f90 â€“ StringiFor"},{"text":"StringiFor io_basic test. Source Code !< StringiFor `io_basic` test. program io_basic !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `io_basic` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!' acharacter = 'New Hello World!' #ifndef __GFORTRAN__ write ( stdout , \"(DT)\" , iostat = iostat ) astring test_passed ( 1 ) = iostat == 0 read ( acharacter , \"(DT)\" , iostat = iostat ) astring test_passed ( 2 ) = iostat == 0 print \"(DT)\" , astring #else call astring % write_formatted ( stdout , \"(DT)\" , [ 1 ], iostat , iomsg ) test_passed ( 1 ) = iostat == 0 call astring % read_formatted_internal ( acharacter , \"(DT)\" , [ 1 ], iostat , iomsg ) test_passed ( 2 ) = iostat == 0 write ( stdout , \"(A)\" ) astring % chars () #endif write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram io_basic","tags":"","loc":"sourcefile/io_basic.f90.html","title":"io_basic.F90 â€“ StringiFor"},{"text":"StringiFor is_digit test. Source Code !< StringiFor `is_digit` test. program is_digit !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_digit` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112.3 ' test_passed ( 1 ) = astring % is_digit (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Is digit? ' , astring % is_digit () astring = '12121123' test_passed ( 2 ) = astring % is_digit (). eqv .. true . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Is digit? ' , astring % is_digit () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_digit","tags":"","loc":"sourcefile/is_digit.f90.html","title":"is_digit.f90 â€“ StringiFor"},{"text":"StringiFor partition test. Source Code !< StringiFor `partition` test. program partition !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `partition` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: strings ( 3 ) !< A set of strings. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' strings = astring % partition ( sep = 'lo Wo' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'Hel' . and . strings ( 2 ) // '' == 'lo Wo' . and . strings ( 3 ) // '' == 'rLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // 'lo Wo' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' strings = astring % partition ( sep = 'Hello' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == '' . and . strings ( 2 ) // '' == 'Hello' . and . strings ( 3 ) // '' == ' WorLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // 'Hello' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' astring = 'Hello WorLD!' strings = astring % partition () test_passed ( 3 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == ' ' . and . strings ( 3 ) // '' == 'WorLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // ' ' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram partition","tags":"","loc":"sourcefile/partition.f90.html","title":"partition.f90 â€“ StringiFor"},{"text":"StringiFor replace test. Source Code !< StringiFor `replace` test. program replace !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `replace` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'When YOU are sad YOU should think to me :-)' write ( stdout , \"(A)\" ) 'Original:                                 \"' // astring // '\"' test_passed ( 1 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' ) // '' == 'When THEY are sad THEY should think to me :-)' ) write ( stdout , \"(A)\" ) 'Replace \"YOU\" with \"THEY\":                \"' // astring % replace ( old = 'YOU' , new = 'THEY' ) // '\"' test_passed ( 2 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '' == 'When THEY are sad YOU should think to me :-)' ) write ( stdout , \"(A)\" ) 'Replace only the first \"YOU\" with \"THEY\": \"' // astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram replace","tags":"","loc":"sourcefile/replace.f90.html","title":"replace.f90 â€“ StringiFor"},{"text":"StringiFor sadjustlr test. Source Code !< StringiFor `sadjustlr` test. program sadjustlr !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sadjustlr` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % sadjustl () // '' == 'Hello World!   ' write ( stdout , \"(A)\" ) 'AdjustL:  \"' // astring % sadjustl () // '\"' astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 2 ) = astring % sadjustr () // '' == '   Hello World!' write ( stdout , \"(A)\" ) 'AdjustR:  \"' // astring % sadjustr () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sadjustlr","tags":"","loc":"sourcefile/sadjustlr.f90.html","title":"sadjustlr.f90 â€“ StringiFor"},{"text":"StringiFor sindex test. Source Code !< StringiFor `sindex` test. program sindex !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sindex` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sindex ( substring = anothercharacter ) ic = index ( string = acharacter , substring = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sindex ( substring = anothercharacter , back = . true .) ic = index ( string = acharacter , substring = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sindex","tags":"","loc":"sourcefile/sindex.f90.html","title":"sindex.f90 â€“ StringiFor"},{"text":"StringiFor slen test. Source Code !< StringiFor `slen` test. program slen !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `slen` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % slen () == len ( 'Hello World!   ' ) write ( stdout , \"(A,I2)\" ) 'Len: ' , astring % slen () test_passed ( 2 ) = astring % slen_trim () == len_trim ( 'Hello World!   ' ) write ( stdout , \"(A,I2)\" ) 'Len_trim: ' , astring % slen_trim () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram slen","tags":"","loc":"sourcefile/slen.f90.html","title":"slen.f90 â€“ StringiFor"},{"text":"StringiFor split test. Source Code !< StringiFor `split` test. program split !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `split` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. logical :: test_passed ( 5 ) !< List of passed tests. integer :: s !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '+ab-++cre-++cre-ab+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'ab-++cre-++cre-ab+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'ab-++cre-++cre-ab' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 3 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'Hello ' // new_line ( 'a' ) // 'World!' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"new_line\"' call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 4 ) = ( strings ( 1 ) // '' == 'Hello ' . and . strings ( 2 ) // '' == 'World!' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'Hello World!' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"default\" (namely space)' call astring % split ( tokens = strings ) test_passed ( 5 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == 'World!' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram split","tags":"","loc":"sourcefile/split.f90.html","title":"split.f90 â€“ StringiFor"},{"text":"StringiFor srepeat test. Source Code !< StringiFor `srepeat` test. program srepeat !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `srepeat` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . test_passed ( 1 ) = astring % srepeat ( rstring = 'x' , ncopies = 5 ) // '' == 'xxxxx' write ( stdout , \"(A,I2)\" ) 'Repeat x 5 times: \"' // astring % srepeat ( rstring = 'x' , ncopies = 5 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram srepeat","tags":"","loc":"sourcefile/srepeat.f90.html","title":"srepeat.f90 â€“ StringiFor"},{"text":"StringiFor sscan test. Source Code !< StringiFor `sscan` test. program sscan !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sscan` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sscan ( set = anothercharacter ) ic = scan ( string = acharacter , set = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sscan ( set = anothercharacter , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sscan","tags":"","loc":"sourcefile/sscan.f90.html","title":"sscan.f90 â€“ StringiFor"},{"text":"StringiFor start_end test. Source Code !< StringiFor `start_end` test. program start_end !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `start_end` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % start_with ( prefix = 'Hello' ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'start with \"Hello\"? ' , astring % start_with ( prefix = 'Hello' ) test_passed ( 2 ) = astring % start_with ( prefix = 'hell' ). eqv .. false . write ( stdout , \"(A,L1)\" ) 'start with \"hell\"? ' , astring % start_with ( prefix = 'hell' ) test_passed ( 3 ) = astring % start_with ( prefix = 'llo Wor' , start = 3 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (3:) start with \"llo Wor\"? ' , astring % start_with ( prefix = 'llo Wor' , start = 3 ) test_passed ( 4 ) = astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (4:7) start with \"lo W\"? ' , astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ) test_passed ( 5 ) = astring % end_with ( suffix = 'LD!' ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'end with \"LD!\"? ' , astring % end_with ( suffix = 'LD!' ) test_passed ( 6 ) = astring % end_with ( suffix = 'lD!' ). eqv .. false . write ( stdout , \"(A,L1)\" ) 'end with \"lD!\"? ' , astring % end_with ( suffix = 'lD!' ) test_passed ( 7 ) = astring % end_with ( suffix = 'orLD!' , start = 5 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (5:) end with \"orLD!\"? ' , astring % end_with ( suffix = 'orLD!' , start = 5 ) test_passed ( 8 ) = astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (8:12) end with \"orLD!\"? ' , astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram start_end","tags":"","loc":"sourcefile/start_end.f90.html","title":"start_end.f90 â€“ StringiFor"},{"text":"StringiFor strim test. Source Code !< StringiFor `strim` test. program strim !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strim` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % strim () // '' == 'Hello World!' write ( stdout , \"(A)\" ) 'Trimmed:  \"' // astring % strim () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strim","tags":"","loc":"sourcefile/strim.f90.html","title":"strim.f90 â€“ StringiFor"},{"text":"StringiFor strip test. Source Code !< StringiFor `strip` test. program strip !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strip` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. integer :: s !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . write ( stdout , \"(A)\" ) new_line ( 'A' ) // 'Strip' astring = '  Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % strip () // '' == 'Hello World!' write ( stdout , \"(A)\" ) 'Strip:    \"' // astring % strip () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strip","tags":"","loc":"sourcefile/strip.f90.html","title":"strip.f90 â€“ StringiFor"},{"text":"StringiFor sverify test. Source Code !< StringiFor `sverify` test. program sverify !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sverify` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sverify ( set = anothercharacter ) ic = verify ( string = acharacter , set = anothercharacter ) write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sverify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic anothercharacter = acharacter i = astring % sverify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) write ( stdout , \"(A,I2,A,L1)\" ) 'Identical strings call result: ' , i , ' is correct? ' , i == ic stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sverify","tags":"","loc":"sourcefile/sverify.f90.html","title":"sverify.f90 â€“ StringiFor"},{"text":"StringiFor swapcase test. Source Code !< StringiFor `swapcase` test. program swapcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `swapcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. integer :: s !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . write ( stdout , \"(A)\" ) new_line ( 'A' ) // 'Swapcase' astring = '  Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % swapcase () // '' == '  hELLO wORLD!   ' write ( stdout , \"(A)\" ) 'Swapcase: \"' // astring % swapcase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram swapcase","tags":"","loc":"sourcefile/swapcase.f90.html","title":"swapcase.f90 â€“ StringiFor"},{"text":"StringiFor unique test. Source Code !< StringiFor `unique` test. program unique !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `unique` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. integer :: s !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . write ( stdout , \"(A)\" ) new_line ( 'A' ) // 'Unique' astring = '+++ab-++cre-++cre-ab+++++' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % unique ( substring = '+' ) // '' == '+ab-+cre-+cre-ab+' write ( stdout , \"(A)\" ) 'Unique:   \"' // astring % unique ( substring = '+' ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram unique","tags":"","loc":"sourcefile/unique.f90.html","title":"unique.f90 â€“ StringiFor"},{"text":"StringiFor upper_lower test. Source Code !< StringiFor `upper_lower` test. program upper_lower !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `upper_lower` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 : 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' test_passed ( 1 ) = astring % upper () // '' == 'HELLO WORLD!' test_passed ( 2 ) = astring % lower () // '' == 'hello world!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'UPPER:    \"' // astring % upper () // '\". Is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) 'lower:    \"' // astring % lower () // '\". Is correct? ' , test_passed ( 2 ) astring = ' Hello World' test_passed ( 3 ) = astring % is_upper (). eqv .. false . test_passed ( 4 ) = astring % is_lower (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 4 ) astring = ' HELLO WORLD' test_passed ( 5 ) = astring % is_upper (). eqv .. true . test_passed ( 6 ) = astring % is_lower (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 5 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 6 ) astring = ' hello world' test_passed ( 7 ) = astring % is_upper (). eqv .. false . test_passed ( 8 ) = astring % is_lower (). eqv .. true . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 7 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 8 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram upper_lower","tags":"","loc":"sourcefile/upper_lower.f90.html","title":"upper_lower.f90 â€“ StringiFor"},{"text":"type, public :: string OOP designed string class. Components Type Visibility Attributes Name Initial character(kind=CK,len=:), private, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: free Free dynamic memory. private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Description Free dynamic memory. procedure, public, pass(self) :: chars Return the raw characters data. private pure function chars (self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data. procedure, public, pass(self) :: upper Return a string with all uppercase characters. private elemental function upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all uppercase characters. procedure, public, pass(self) :: lower Return a string with all lowercase characters. private elemental function lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all lowercase characters. procedure, public, pass(self) :: capitalize Return a string with its first character capitalized and the rest lowercased. private elemental function capitalize (self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with its first character capitalized and the rest lowercased. procedure, public, pass(self) :: partition Split string at separator and return the 3 parts (before, the separator and after). private pure function partition (self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )\n  (1:3) after the separator. Description Split string at separator and return the 3 parts (before, the separator and after). procedure, public, pass(self) :: replace Return a string with all occurrences of substring old replaced by new. private elemental function replace (self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Description Return a string with all occurrences of substring old replaced by new. procedure, public, pass(self) :: split Return a list of substring in the string, using sep as the delimiter string. private pure subroutine split (self, tokens, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. Description Return a list of substring in the string, using sep as the delimiter string. procedure, public, pass(self) :: strip Return a copy of the string with the leading and trailing characters removed. private elemental function strip (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The stripped string. Description Return a copy of the string with the leading and trailing characters removed. procedure, public, pass(self) :: swapcase Return a copy of the string with uppercase chars converted to lowercase and vice versa. private elemental function swapcase (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a copy of the string with uppercase characters converted to lowercase and vice versa. procedure, public, pass(self) :: unique Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. private elemental function unique (self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Description Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. procedure, public, pass(self) :: is_allocated Return true if the string is allocated. private elemental function is_allocated (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if the string is allocated. procedure, public, pass(self) :: is_upper Return true if all characters in the string are uppercase. private elemental function is_upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are uppercase. procedure, public, pass(self) :: is_lower Return true if all characters in the string are lowercase. private elemental function is_lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are lowercase. procedure, public, pass(self) :: is_digit Return true if all characters in the string are digits. private elemental function is_digit (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are digits. procedure, public, pass(self) :: end_with Return true if a string ends with a specified suffix. private elemental function end_with (self, suffix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string ends with a specified suffix. procedure, public, pass(self) :: start_with Return true if a string starts with a specified prefix. private elemental function start_with (self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string starts with a specified prefix. generic, public :: assignment(=) => string_assign_string , string_assign_character Assignment operator overloading. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. generic, public :: operator(//) => string_concat_string , string_concat_character , character_concat_string Concatenation operator overloading. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). generic, public :: operator(.cat.) => string_concat_string_string , string_concat_character_string , character_concat_string_string Concatenation operator (string output) overloading. private elemental function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. private elemental function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. private elemental function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). procedure, public, pass(self) :: sadjustl Adjustl replacement. private elemental function sadjustl (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. procedure, public, pass(self) :: sadjustr Adjustr replacement. private elemental function sadjustr (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. procedure, public, pass(self) :: scount Count replacement. private elemental function scount (self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore \"isolated\" occurrences. Return Value integer Number of occurrences. Description Count the number of occurences of a substring into a string. procedure, public, pass(self) :: sindex Index replacement. private elemental function sindex (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. procedure, public, pass(self) :: slen Len replacement. private elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. procedure, public, pass(self) :: slen_trim Len_trim replacement. private elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer <\np S\nt\nr\ni\nn\ng l\ne\nn\ng\nt\nh\n.\n<\n/\np Description Return the length of a string, ignoring any trailing blanks. procedure, public, nopass :: srepeat Repeat replacement. private elemental function srepeat (rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. procedure, public, pass(self) :: sscan Scan replacement. private elemental function sscan (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . procedure, public, pass(self) :: strim Trim replacement. private elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. procedure, public, pass(self) :: sverify Verify replacement. private elemental function sverify (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. procedure, public, pass(dtv) :: read_formatted => read_formatted_ Formatted input. private subroutine read_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted input. procedure, public, pass(dtv) :: read_formatted_internal Formatted input from internal. private subroutine read_formatted_internal (dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. character(kind=CK,len=*), intent(in) :: iunit Internal unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted input from internal. procedure, public, pass(dtv) :: write_formatted => write_formatted_ Formatted output. private subroutine write_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. procedure, public, pass(dtv) :: write_formatted_internal Formatted output to internal. private subroutine write_formatted_internal (dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. character(kind=CK,len=*), intent(inout) :: iunit Interanl unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output to internal. procedure, private, pass(lhs) :: string_assign_string Assignment operator from string input. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. procedure, private, pass(lhs) :: string_assign_character Assignment operator from character input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. procedure, private, pass(lhs) :: string_concat_string Concatenation with string. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. procedure, private, pass(lhs) :: string_concat_character Concatenation with character. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. procedure, private, pass(rhs) :: character_concat_string Concatenation with character (inverted). private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). procedure, private, pass(lhs) :: string_concat_string_string Concatenation with string (string output). private elemental function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. procedure, private, pass(lhs) :: string_concat_character_string Concatenation with character (string output). private elemental function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. procedure, private, pass(rhs) :: character_concat_string_string Concatenation with character (inverted, string output). private elemental function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). procedure, private, pass(dtv) :: read_formatted_ Formatted input. private subroutine read_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted input. procedure, private, pass(dtv) :: write_formatted_ Formatted output. private subroutine write_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. procedure, private, pass(dtv) :: read_unformatted_ Unformatted input. private subroutine read_unformatted_ (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. procedure, private, pass(dtv) :: write_unformatted_ Unformatted output. private subroutine write_unformatted_ (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. procedure, private, pass(self) :: replace_one_occurrence Replace the first occurrence of substring old by new. private elemental function replace_one_occurrence (self, old, new) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Description Return a string with the first occurrence of substring old replaced by new. Source Code type :: string !< OOP designed string class. private character ( kind = CK , len = :), allocatable :: raw !< Raw data. contains ! public methods procedure , pass ( self ) :: free !< Free dynamic memory. procedure , pass ( self ) :: chars !< Return the raw characters data. procedure , pass ( self ) :: upper !< Return a string with all uppercase characters. procedure , pass ( self ) :: lower !< Return a string with all lowercase characters. procedure , pass ( self ) :: capitalize !< Return a string with its first character capitalized and the rest lowercased. procedure , pass ( self ) :: partition !< Split string at separator and return the 3 parts (before, the separator and after). procedure , pass ( self ) :: replace !< Return a string with all occurrences of substring old replaced by new. procedure , pass ( self ) :: split !< Return a list of substring in the string, using sep as the delimiter string. procedure , pass ( self ) :: strip !< Return a copy of the string with the leading and trailing characters removed. procedure , pass ( self ) :: swapcase !< Return a copy of the string with uppercase chars converted to lowercase and vice versa. procedure , pass ( self ) :: unique !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. ! inquire procedure , pass ( self ) :: is_allocated !< Return true if the string is allocated. procedure , pass ( self ) :: is_upper !< Return true if all characters in the string are uppercase. procedure , pass ( self ) :: is_lower !< Return true if all characters in the string are lowercase. procedure , pass ( self ) :: is_digit !< Return true if all characters in the string are digits. procedure , pass ( self ) :: end_with !< Return true if a string ends with a specified suffix. procedure , pass ( self ) :: start_with !< Return true if a string starts with a specified prefix. ! operators generic :: assignment ( = ) => string_assign_string , & string_assign_character !< Assignment operator overloading. generic :: operator ( // ) => string_concat_string , & string_concat_character , & character_concat_string !< Concatenation operator overloading. generic :: operator (. cat .) => string_concat_string_string , & string_concat_character_string , & character_concat_string_string !< Concatenation operator (string output) overloading. ! builtins replacements procedure , pass ( self ) :: sadjustl !< Adjustl replacement. procedure , pass ( self ) :: sadjustr !< Adjustr replacement. procedure , pass ( self ) :: scount !< Count replacement. procedure , pass ( self ) :: sindex !< Index replacement. procedure , pass ( self ) :: slen !< Len replacement. procedure , pass ( self ) :: slen_trim !< Len_trim replacement. procedure , nopass :: srepeat !< Repeat replacement. procedure , pass ( self ) :: sscan !< Scan replacement. procedure , pass ( self ) :: strim !< Trim replacement. procedure , pass ( self ) :: sverify !< Verify replacement. ! IO #ifndef __GFORTRAN__ generic :: read ( formatted ) => read_formatted_ !< Formatted input. generic :: write ( formatted ) => write_formatted_ !< Formatted output. generic :: read ( unformatted ) => read_unformatted_ !< Unformatted input. generic :: write ( unformatted ) => write_unformatted_ !< Unformatted output. #else procedure , pass ( dtv ) :: read_formatted => read_formatted_ !< Formatted input. procedure , pass ( dtv ) :: read_formatted_internal !< Formatted input from internal. procedure , pass ( dtv ) :: write_formatted => write_formatted_ !< Formatted output. procedure , pass ( dtv ) :: write_formatted_internal !< Formatted output to internal. #endif ! private methods procedure , private , pass ( lhs ) :: string_assign_string !< Assignment operator from string input. procedure , private , pass ( lhs ) :: string_assign_character !< Assignment operator from character input. procedure , private , pass ( lhs ) :: string_concat_string !< Concatenation with string. procedure , private , pass ( lhs ) :: string_concat_character !< Concatenation with character. procedure , private , pass ( rhs ) :: character_concat_string !< Concatenation with character (inverted). procedure , private , pass ( lhs ) :: string_concat_string_string !< Concatenation with string (string output). procedure , private , pass ( lhs ) :: string_concat_character_string !< Concatenation with character (string output). procedure , private , pass ( rhs ) :: character_concat_string_string !< Concatenation with character (inverted, string output). procedure , private , pass ( dtv ) :: read_formatted_ !< Formatted input. procedure , private , pass ( dtv ) :: write_formatted_ !< Formatted output. procedure , private , pass ( dtv ) :: read_unformatted_ !< Unformatted input. procedure , private , pass ( dtv ) :: write_unformatted_ !< Unformatted output. procedure , private , pass ( self ) :: replace_one_occurrence !< Replace the first occurrence of substring old by new. endtype string","tags":"","loc":"type/string.html","title":"string â€“ StringiFor "},{"text":"private pure function chars(self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data. Source Code pure function chars ( self ) result ( raw ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len = :), allocatable :: raw !< Raw characters data. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then raw = self % raw else raw = '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction chars","tags":"","loc":"proc/chars.html","title":"chars â€“ StringiFor"},{"text":"private elemental function upper(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all uppercase characters. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. Source Code elemental function upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all uppercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: upper !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then upper = self do n1 = 1 , len ( self % raw ) n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) upper % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction upper","tags":"","loc":"proc/upper.html","title":"upper â€“ StringiFor"},{"text":"private elemental function lower(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all lowercase characters. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. Source Code elemental function lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all lowercase characters. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: lower !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then lower = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) lower % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction lower","tags":"","loc":"proc/lower.html","title":"lower â€“ StringiFor"},{"text":"private elemental function capitalize(self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with its first character capitalized and the rest lowercased. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function capitalize ( self ) result ( capitalized ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with its first character capitalized and the rest lowercased. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: capitalized !< Upper case string. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then capitalized = self % lower () c = index ( LOWER_ALPHABET , capitalized % raw ( 1 : 1 )) if ( c > 0 ) capitalized % raw ( 1 : 1 ) = UPPER_ALPHABET ( c : c ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction capitalize","tags":"","loc":"proc/capitalize.html","title":"capitalize â€“ StringiFor"},{"text":"private pure function partition(self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )\n  (1:3) after the separator. Description Split string at separator and return the 3 parts (before, the separator and after). Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: c Character counter. character(kind=CK,len=:), public, allocatable :: temporary Temporary storage, workaround for GNU bug. Source Code pure function partition ( self , sep ) result ( partitions ) !--------------------------------------------------------------------------------------------------------------------------------- !< Split string at separator and return the 3 parts (before, the separator and after). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ) :: partitions ( 1 : 3 ) !< Partions: before the separator, the separator itsels and !< after the separator. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: c !< Character counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep partitions ( 1 ) = self partitions ( 2 ) = sep_ partitions ( 3 ) = '' if ( len ( sep_ ) >= len ( self % raw )) return c = index ( self % raw , sep_ ) if ( c > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw partitions ( 1 )% raw = temporary ( 1 : c - 1 ) partitions ( 2 )% raw = temporary ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = temporary ( c + len ( sep_ ):) #else partitions ( 1 )% raw = self % raw ( 1 : c - 1 ) partitions ( 2 )% raw = self % raw ( c : c + len ( sep_ ) - 1 ) partitions ( 3 )% raw = self % raw ( c + len ( sep_ ):) #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction partition","tags":"","loc":"proc/partition.html","title":"partition â€“ StringiFor"},{"text":"private elemental function replace(self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Description Return a string with all occurrences of substring old replaced by new. Variables Type Visibility Attributes Name Initial integer, public :: r Counter. Source Code elemental function replace ( self , old , new , count ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with all occurrences of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. integer , intent ( in ), optional :: count !< Number of old occurences to be replaced. type ( string ) :: replaced !< The string with old replaced by new. integer :: r !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self r = 0 do if ( index ( replaced % raw , old ) > 0 ) then replaced = replaced % replace_one_occurrence ( old = old , new = new ) r = r + 1 if ( present ( count )) then if ( r >= count ) exit endif else exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace","tags":"","loc":"proc/replace.html","title":"replace â€“ StringiFor"},{"text":"private elemental function strip(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The stripped string. Description Return a copy of the string with the leading and trailing characters removed. Source Code elemental function strip ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with the leading and trailing characters removed. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: strip !< The stripped string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then strip = self % sadjustl () strip = strip % strim () endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strip","tags":"","loc":"proc/strip.html","title":"strip â€“ StringiFor"},{"text":"private elemental function swapcase(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a copy of the string with uppercase characters converted to lowercase and vice versa. Variables Type Visibility Attributes Name Initial integer, public :: n1 Characters counter. integer, public :: n2 Characters counter. Source Code elemental function swapcase ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a copy of the string with uppercase characters converted to lowercase and vice versa. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: swapcase !< Upper case string. integer :: n1 !< Characters counter. integer :: n2 !< Characters counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then swapcase = self do n1 = 1 , len ( self % raw ) n2 = index ( UPPER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) then swapcase % raw ( n1 : n1 ) = LOWER_ALPHABET ( n2 : n2 ) else n2 = index ( LOWER_ALPHABET , self % raw ( n1 : n1 )) if ( n2 > 0 ) swapcase % raw ( n1 : n1 ) = UPPER_ALPHABET ( n2 : n2 ) endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction swapcase","tags":"","loc":"proc/swapcase.html","title":"swapcase â€“ StringiFor"},{"text":"private elemental function unique(self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Description Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. Note Eventual multiple trailing white space are not reduced to one occurrence. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: substring_ Substring, default value. Source Code elemental function unique ( self , substring ) result ( uniq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. !< !< For example the string ' ab-cre-cre-ab' is reduce to 'ab-cre-ab' if the substring is '-cre'. !< @note Eventual multiple trailing white space are not reduced to one occurrence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: substring !< Substring which multiple occurences must be reduced to one. character ( kind = CK , len = :), allocatable :: substring_ !< Substring, default value. type ( string ) :: uniq !< String parsed. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then substring_ = SPACE ; if ( present ( substring )) substring_ = substring uniq = self do if (. not . uniq % sindex ( repeat ( substring_ , 2 )) > 0 ) exit uniq = uniq % replace ( old = repeat ( substring_ , 2 ), new = substring_ ) enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction unique","tags":"","loc":"proc/unique.html","title":"unique â€“ StringiFor"},{"text":"private elemental function is_allocated(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if the string is allocated. Source Code elemental function is_allocated ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if the string is allocated. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_allocated !< Result of the test. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_allocated = allocated ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_allocated","tags":"","loc":"proc/is_allocated.html","title":"is_allocated â€“ StringiFor"},{"text":"private elemental function is_digit(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are digits. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function is_digit ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are digits. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_digit !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_digit = . false . if ( allocated ( self % raw )) then do c = 1 , len ( self % raw ) select case ( self % raw ( c : c )) case ( '0' : '9' ) is_digit = . true . case default is_digit = . false . exit end select enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_digit","tags":"","loc":"proc/is_digit.html","title":"is_digit â€“ StringiFor"},{"text":"private elemental function is_upper(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are uppercase. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function is_upper ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are uppercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_upper !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_upper = . false . if ( allocated ( self % raw )) then is_upper = . true . do c = 1 , len ( self % raw ) if ( index ( LOWER_ALPHABET , self % raw ( c : c )) > 0 ) then is_upper = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_upper","tags":"","loc":"proc/is_upper.html","title":"is_upper â€“ StringiFor"},{"text":"private elemental function is_lower(self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are lowercase. Variables Type Visibility Attributes Name Initial integer, public :: c Character counter. Source Code elemental function is_lower ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if all characters in the string are lowercase. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. logical :: is_lower !< Result of the test. integer :: c !< Character counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- is_lower = . false . if ( allocated ( self % raw )) then is_lower = . true . do c = 1 , len ( self % raw ) if ( index ( UPPER_ALPHABET , self % raw ( c : c )) > 0 ) then is_lower = . false . exit endif enddo endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction is_lower","tags":"","loc":"proc/is_lower.html","title":"is_lower â€“ StringiFor"},{"text":"private elemental function end_with(self, suffix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string ends with a specified suffix. Variables Type Visibility Attributes Name Initial integer, public :: start_ Start position into the string, local variable. integer, public :: end_ End position into the string, local variable. Source Code elemental function end_with ( self , suffix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string ends with a specified suffix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: suffix !< Searched suffix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: end_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- end_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( suffix ) <= len ( self % raw ( start_ : end_ ))) then end_with = index ( self % raw ( start_ : end_ ), suffix ) == ( len ( self % raw ( start_ : end_ )) - len ( suffix ) + 1 ) endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction end_with","tags":"","loc":"proc/end_with.html","title":"end_with â€“ StringiFor"},{"text":"private elemental function start_with(self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string starts with a specified prefix. Variables Type Visibility Attributes Name Initial integer, public :: start_ Start position into the string, local variable. integer, public :: end_ End position into the string, local variable. Source Code elemental function start_with ( self , prefix , start , end ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return true if a string starts with a specified prefix. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: prefix !< Searched prefix. integer , intent ( in ), optional :: start !< Start position into the string. integer , intent ( in ), optional :: end !< End position into the string. logical :: start_with !< Result of the test. integer :: start_ !< Start position into the string, local variable. integer :: end_ !< End position into the string, local variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- start_with = . false . if ( allocated ( self % raw )) then start_ = 1 ; if ( present ( start )) start_ = start end_ = len ( self % raw ) ; if ( present ( end )) end_ = end if ( len ( prefix ) <= len ( self % raw ( start_ : end_ ))) then start_with = index ( self % raw ( start_ : end_ ), prefix ) == 1 endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction start_with","tags":"","loc":"proc/start_with.html","title":"start_with â€“ StringiFor"},{"text":"private elemental function sadjustl(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. Source Code elemental function sadjustl ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Left adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustl ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustl","tags":"","loc":"proc/sadjustl.html","title":"sadjustl â€“ StringiFor"},{"text":"private elemental function sadjustr(self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. Source Code elemental function sadjustr ( self ) result ( adjusted ) !--------------------------------------------------------------------------------------------------------------------------------- !< Right adjust a string by removing leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: adjusted !< Adjusted string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- adjusted = self if ( allocated ( adjusted % raw )) adjusted % raw = adjustr ( adjusted % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sadjustr","tags":"","loc":"proc/sadjustr.html","title":"sadjustr â€“ StringiFor"},{"text":"private elemental function scount(self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore \"isolated\" occurrences. Return Value integer Number of occurrences. Description Count the number of occurences of a substring into a string. Note If ignore_isolated is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those\n occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a\n right companion). Variables Type Visibility Attributes Name Initial logical, public :: ignore_isolated_ Ignore \"isolated\" occurrences, local variable. integer, public :: c1 Counter. integer, public :: c2 Counter. character(kind=CK,len=:), public, allocatable :: temporary Temporary storage, workaround for GNU bug. Source Code elemental function scount ( self , substring , ignore_isolated ) result ( No ) !--------------------------------------------------------------------------------------------------------------------------------- !< Count the number of occurences of a substring into a string. !< !< @note If `ignore_isolated` is set to true the eventual \"isolated\" occurences are ignored: an isolated occurrences are those !< occurrences happening at the start of string (thus not having a left companion) or at the end of the string (thus not having a !< right companion). !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( * ), intent ( in ) :: substring !< Substring. logical , intent ( in ), optional :: ignore_isolated !< Ignore \"isolated\" occurrences. integer :: No !< Number of occurrences. logical :: ignore_isolated_ !< Ignore \"isolated\" occurrences, local variable. integer :: c1 !< Counter. integer :: c2 !< Counter. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- No = 0 if ( allocated ( self % raw )) then if ( len ( substring ) > len ( self % raw )) return ignore_isolated_ = . false . ; if ( present ( ignore_isolated )) ignore_isolated_ = ignore_isolated #ifdef __GFORTRAN__ temporary = self % raw #endif c1 = 1 do #ifdef __GFORTRAN__ c2 = index ( string = temporary ( c1 :), substring = substring ) #else c2 = index ( string = self % raw ( c1 :), substring = substring ) #endif if ( c2 == 0 ) return if (. not .( ignore_isolated_ . and .( c1 == 1. or . c1 + c2 - 1 == len ( self % raw ) - len ( substring ) + 1 ))) then No = No + 1 endif c1 = c1 + c2 - 1 + len ( substring ) enddo endif !--------------------------------------------------------------------------------------------------------------------------------- endfunction scount","tags":"","loc":"proc/scount.html","title":"scount â€“ StringiFor"},{"text":"private elemental function sindex(self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. Source Code elemental function sindex ( self , substring , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the position of the start of the first occurrence of string `substring` as a substring in `string`, counting from one. !< If `substring` is not present in `string`, zero is returned. If the back argument is present and true, the return value is !< the start of the last occurrence rather than the first. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: substring !< Searched substring. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = index ( string = self % raw , substring = substring , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sindex","tags":"","loc":"proc/sindex.html","title":"sindex â€“ StringiFor"},{"text":"private elemental function slen(self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. Source Code elemental function slen ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen","tags":"","loc":"proc/slen.html","title":"slen â€“ StringiFor"},{"text":"private elemental function slen_trim(self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string, ignoring any trailing blanks. Source Code elemental function slen_trim ( self ) result ( l ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the length of a string, ignoring any trailing blanks. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. integer :: l !< String length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then l = len_trim ( string = self % raw ) else l = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction slen_trim","tags":"","loc":"proc/slen_trim.html","title":"slen_trim â€“ StringiFor"},{"text":"private elemental function srepeat(rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. Source Code elemental function srepeat ( rstring , ncopies ) result ( repeated ) !--------------------------------------------------------------------------------------------------------------------------------- !< !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: rstring !< String to be repeated. integer , intent ( in ) :: ncopies !< Number of string copies. type ( string ) :: repeated !< Repeated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- repeated % raw = repeat ( string = rstring , ncopies = ncopies ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction srepeat","tags":"","loc":"proc/srepeat.html","title":"srepeat â€“ StringiFor"},{"text":"private elemental function sscan(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . Source Code elemental function sscan ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is in `set`. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = scan ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sscan","tags":"","loc":"proc/sscan.html","title":"sscan â€“ StringiFor"},{"text":"private elemental function strim(self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. Source Code elemental function strim ( self ) result ( trimmed ) !--------------------------------------------------------------------------------------------------------------------------------- !< Remove leading spaces. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. type ( string ) :: trimmed !< Trimmed string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- trimmed = self if ( allocated ( trimmed % raw )) trimmed % raw = trim ( trimmed % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strim","tags":"","loc":"proc/strim.html","title":"strim â€“ StringiFor"},{"text":"private elemental function sverify(self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. Source Code elemental function sverify ( self , set , back ) result ( i ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return the leftmost (if `back` is either absent or equals false, otherwise the rightmost) character of string that is not !< in `set`. If all characters of `string` are found in `set`, the result is zero. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: set !< Searched set. logical , intent ( in ), optional :: back !< Start of the last occurrence rather than the first. integer :: i !< Result of the search. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then i = verify ( string = self % raw , set = set , back = back ) else i = 0 endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sverify","tags":"","loc":"proc/sverify.html","title":"sverify â€“ StringiFor"},{"text":"private pure function string_concat_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. Source Code pure function string_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- concat = '' if ( allocated ( lhs % raw )) concat = lhs % raw if ( allocated ( rhs % raw )) concat = concat // rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string","tags":"","loc":"proc/string_concat_string.html","title":"string_concat_string â€“ StringiFor"},{"text":"private pure function string_concat_character(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. Source Code pure function string_concat_character ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat = lhs % raw // rhs else concat = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character","tags":"","loc":"proc/string_concat_character.html","title":"string_concat_character â€“ StringiFor"},{"text":"private pure function character_concat_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). Source Code pure function character_concat_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. character ( kind = CK , len = :), allocatable :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat = lhs // rhs % raw else concat = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string","tags":"","loc":"proc/character_concat_string.html","title":"character_concat_string â€“ StringiFor"},{"text":"private elemental function string_concat_string_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: temporary Temporary concatenated string. Source Code elemental function string_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with string. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. character ( kind = CK , len = :), allocatable :: temporary !< Temporary concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- temporary = '' if ( allocated ( lhs % raw )) temporary = lhs % raw if ( allocated ( rhs % raw )) temporary = temporary // rhs % raw if ( temporary /= '' ) concat % raw = temporary return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_string_string","tags":"","loc":"proc/string_concat_string_string.html","title":"string_concat_string_string â€“ StringiFor"},{"text":"private elemental function string_concat_character_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. Source Code elemental function string_concat_character_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( lhs % raw )) then concat % raw = lhs % raw // rhs else concat % raw = rhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction string_concat_character_string","tags":"","loc":"proc/string_concat_character_string.html","title":"string_concat_character_string â€“ StringiFor"},{"text":"private elemental function character_concat_string_string(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). Source Code elemental function character_concat_string_string ( lhs , rhs ) result ( concat ) !--------------------------------------------------------------------------------------------------------------------------------- !< Concatenation with character (inverted). !--------------------------------------------------------------------------------------------------------------------------------- character ( kind = CK , len =* ), intent ( in ) :: lhs !< Left hand side. class ( string ), intent ( in ) :: rhs !< Right hand side. type ( string ) :: concat !< Concatenated string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) then concat % raw = lhs // rhs % raw else concat % raw = lhs endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction character_concat_string_string","tags":"","loc":"proc/character_concat_string_string.html","title":"character_concat_string_string â€“ StringiFor"},{"text":"private elemental function replace_one_occurrence(self, old, new) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Description Return a string with the first occurrence of substring old replaced by new. Variables Type Visibility Attributes Name Initial integer, public :: pos Position from which replace old. character(kind=CK,len=:), public, allocatable :: temporary Temporary storage, workaround for GNU bug. Source Code elemental function replace_one_occurrence ( self , old , new ) result ( replaced ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a string with the first occurrence of substring old replaced by new. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ) :: old !< Old substring. character ( kind = CK , len =* ), intent ( in ) :: new !< New substring. type ( string ) :: replaced !< The string with old replaced by new. integer :: pos !< Position from which replace old. #ifdef __GFORTRAN__ character ( kind = CK , len = :), allocatable :: temporary !< Temporary storage, workaround for GNU bug. #endif !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then replaced = self pos = index ( string = self % raw , substring = old ) if ( pos > 0 ) then #ifdef __GFORTRAN__ temporary = self % raw if ( pos == 1 ) then replaced % raw = new // temporary ( len ( old ) + 1 :) else replaced % raw = temporary ( 1 : pos - 1 ) // new // temporary ( pos + len ( old ):) endif #else if ( pos == 1 ) then replaced % raw = new // self % raw ( len ( old ) + 1 :) else replaced % raw = self % raw ( 1 : pos - 1 ) // new // self % raw ( pos + len ( old ):) endif #endif endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction replace_one_occurrence","tags":"","loc":"proc/replace_one_occurrence.html","title":"replace_one_occurrence â€“ StringiFor"},{"text":"private elemental subroutine free(self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Description Free dynamic memory. Source Code elemental subroutine free ( self ) !--------------------------------------------------------------------------------------------------------------------------------- !< Free dynamic memory. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: self !< The string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) deallocate ( self % raw ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine free","tags":"","loc":"proc/free.html","title":"free â€“ StringiFor"},{"text":"private pure subroutine split(self, tokens, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. Description Return a list of substring in the string, using sep as the delimiter string. Note Multiple subsequent separators are collapsed to one occurence. Variables Type Visibility Attributes Name Initial character(kind=CK,len=:), public, allocatable :: sep_ Separator, default value. integer, public :: No Number of occurrences of sep. integer, public :: t Character counter. type( string ), public :: temporary Temporary storage. type( string ), public, allocatable :: temp_toks (:,:) Temporary tokens substring. Source Code pure subroutine split ( self , tokens , sep ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return a list of substring in the string, using sep as the delimiter string. !< !< @note Multiple subsequent separators are collapsed to one occurence. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: self !< The string. character ( kind = CK , len =* ), intent ( in ), optional :: sep !< Separator. type ( string ), allocatable , intent ( out ) :: tokens (:) !< Tokens substring. character ( kind = CK , len = :), allocatable :: sep_ !< Separator, default value. integer :: No !< Number of occurrences of sep. integer :: t !< Character counter. type ( string ) :: temporary !< Temporary storage. type ( string ), allocatable :: temp_toks (:,:) !< Temporary tokens substring. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( self % raw )) then sep_ = SPACE ; if ( present ( sep )) sep_ = sep temporary = self % unique ( sep_ ) No = temporary % scount ( sep_ ) allocate ( temp_toks ( 3 , No )) temp_toks (:, 1 ) = temporary % partition ( sep_ ) if ( No > 1 ) then do t = 2 , No temp_toks (:, t ) = temp_toks ( 3 , t - 1 )% partition ( sep_ ) enddo endif if ( temp_toks ( 1 , 1 )% raw /= '' . and . temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No + 1 )) do t = 1 , No if ( t == No ) then tokens ( t ) = temp_toks ( 1 , t ) tokens ( t + 1 ) = temp_toks ( 3 , t ) else tokens ( t ) = temp_toks ( 1 , t ) endif enddo elseif ( temp_toks ( 1 , 1 )% raw /= '' ) then allocate ( tokens ( No )) do t = 1 , No tokens ( t ) = temp_toks ( 1 , t ) enddo elseif ( temp_toks ( 3 , No )% raw /= '' ) then allocate ( tokens ( No )) do t = 2 , No if ( t == No ) then tokens ( t - 1 ) = temp_toks ( 1 , t ) tokens ( t ) = temp_toks ( 3 , t ) else tokens ( t - 1 ) = temp_toks ( 1 , t ) endif enddo else allocate ( tokens ( No - 1 )) do t = 2 , No tokens ( t - 1 ) = temp_toks ( 1 , t ) enddo endif endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine split","tags":"","loc":"proc/split.html","title":"split â€“ StringiFor"},{"text":"private elemental subroutine string_assign_string(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. Source Code elemental subroutine string_assign_string ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from string input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. type ( string ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( rhs % raw )) lhs % raw = rhs % raw return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_string","tags":"","loc":"proc/string_assign_string.html","title":"string_assign_string â€“ StringiFor"},{"text":"private elemental subroutine string_assign_character(lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. Source Code elemental subroutine string_assign_character ( lhs , rhs ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment operator from character input. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: lhs !< Left hand side. character ( kind = CK , len =* ), intent ( in ) :: rhs !< Right hand side. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- lhs % raw = rhs return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine string_assign_character","tags":"","loc":"proc/string_assign_character.html","title":"string_assign_character â€“ StringiFor"},{"text":"private subroutine read_formatted_(dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Variables Type Visibility Attributes Name Initial character(kind=CK,len=100), public :: temporary Temporary storage string. Source Code subroutine read_formatted_ ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted_","tags":"","loc":"proc/read_formatted_.html","title":"read_formatted_ â€“ StringiFor"},{"text":"private subroutine read_formatted_internal(dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. character(kind=CK,len=*), intent(in) :: iunit Internal unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted input from internal. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Variables Type Visibility Attributes Name Initial character(kind=CK,len=100), public :: temporary Temporary storage string. Source Code subroutine read_formatted_internal ( dtv , iunit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted input from internal. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. character ( kind = CK , len =* ), intent ( in ) :: iunit !< Internal unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_formatted_internal","tags":"","loc":"proc/read_formatted_internal.html","title":"read_formatted_internal â€“ StringiFor"},{"text":"private subroutine write_formatted_(dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. Source Code subroutine write_formatted_ ( dtv , unit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted_","tags":"","loc":"proc/write_formatted_.html","title":"write_formatted_ â€“ StringiFor"},{"text":"private subroutine write_formatted_internal(dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. character(kind=CK,len=*), intent(inout) :: iunit Interanl unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output to internal. Source Code subroutine write_formatted_internal ( dtv , iunit , iotype , v_list , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Formatted output to internal. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. character ( kind = CK , len =* ), intent ( inout ) :: iunit !< Interanl unit. character ( kind = CK , len =* ), intent ( in ) :: iotype !< Edit descriptor. integer , intent ( in ) :: v_list (:) !< Edit descriptor list. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( iunit , \"(A)\" , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_formatted_internal","tags":"","loc":"proc/write_formatted_internal.html","title":"write_formatted_internal â€“ StringiFor"},{"text":"private subroutine read_unformatted_(dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. Bug Change temporary acks: find a more precise length of the input string and avoid the trimming! Variables Type Visibility Attributes Name Initial character(kind=CK,len=100), public :: temporary Temporary storage string. Source Code subroutine read_unformatted_ ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted input. !< !< @bug Change temporary acks: find a more precise length of the input string and avoid the trimming! !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( inout ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. character ( kind = CK , len = 100 ) :: temporary !< Temporary storage string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( unit , iostat = iostat , iomsg = iomsg ) temporary dtv % raw = trim ( temporary ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine read_unformatted_","tags":"","loc":"proc/read_unformatted_.html","title":"read_unformatted_ â€“ StringiFor"},{"text":"private subroutine write_unformatted_(dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output. Source Code subroutine write_unformatted_ ( dtv , unit , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Unformatted output. !--------------------------------------------------------------------------------------------------------------------------------- class ( string ), intent ( in ) :: dtv !< The string. integer , intent ( in ) :: unit !< Logical unit. integer , intent ( out ) :: iostat !< IO status code. character ( kind = CK , len =* ), intent ( inout ) :: iomsg !< IO status message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( allocated ( dtv % raw )) then write ( unit , iostat = iostat , iomsg = iomsg ) dtv % raw else write ( unit , iostat = iostat , iomsg = iomsg ) '' endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine write_unformatted_","tags":"","loc":"proc/write_unformatted_.html","title":"write_unformatted_ â€“ StringiFor"},{"text":"StringiFor, Strings Fortran, yet another stringify Fortran module Used By module~~stringifor~~UsedByGraph module~stringifor stringifor program~strim strim module~stringifor->program~strim program~replace replace module~stringifor->program~replace program~is_digit is_digit module~stringifor->program~is_digit program~sscan sscan module~stringifor->program~sscan program~sverify sverify module~stringifor->program~sverify program~io_basic io_basic module~stringifor->program~io_basic program~slen slen module~stringifor->program~slen program~split split module~stringifor->program~split program~partition partition module~stringifor->program~partition program~upper_lower upper_lower module~stringifor->program~upper_lower program~sadjustlr sadjustlr module~stringifor->program~sadjustlr program~strip strip module~stringifor->program~strip program~free free module~stringifor->program~free program~start_end start_end module~stringifor->program~start_end program~swapcase swapcase module~stringifor->program~swapcase program~sindex sindex module~stringifor->program~sindex program~srepeat srepeat module~stringifor->program~srepeat program~concatenation concatenation module~stringifor->program~concatenation program~unique unique module~stringifor->program~unique program~capitalize capitalize module~stringifor->program~capitalize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: CK = selected_char_kind('DEFAULT') Default character kind. character(kind=CK,len=26), private, parameter :: UPPER_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' Upper case alphabet. character(kind=CK,len=26), private, parameter :: LOWER_ALPHABET = 'abcdefghijklmnopqrstuvwxyz' Lower case alphabet. character(kind=CK,len=*), private, parameter :: SPACE = ' ' Space character. Derived Types type, public :: string Components Type Visibility Attributes Name Initial character(kind=CK,len=:), private, allocatable :: raw Raw data. Type-Bound Procedures procedure, public, pass(self) :: free Free dynamic memory. procedure, public, pass(self) :: chars Return the raw characters data. procedure, public, pass(self) :: upper Return a string with all uppercase characters. procedure, public, pass(self) :: lower Return a string with all lowercase characters. procedure, public, pass(self) :: capitalize Return a string with its first character capitalized and the rest lowercased. procedure, public, pass(self) :: partition Split string at separator and return the 3 parts (before, the separator and after). procedure, public, pass(self) :: replace Return a string with all occurrences of substring old replaced by new. procedure, public, pass(self) :: split Return a list of substring in the string, using sep as the delimiter string. procedure, public, pass(self) :: strip Return a copy of the string with the leading and trailing characters removed. procedure, public, pass(self) :: swapcase Return a copy of the string with uppercase chars converted to lowercase and vice versa. procedure, public, pass(self) :: unique Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. procedure, public, pass(self) :: is_allocated Return true if the string is allocated. procedure, public, pass(self) :: is_upper Return true if all characters in the string are uppercase. procedure, public, pass(self) :: is_lower Return true if all characters in the string are lowercase. procedure, public, pass(self) :: is_digit Return true if all characters in the string are digits. procedure, public, pass(self) :: end_with Return true if a string ends with a specified suffix. procedure, public, pass(self) :: start_with Return true if a string starts with a specified prefix. generic, public :: assignment(=) => string_assign_string, string_assign_character Assignment operator overloading. generic, public :: operator(//) => string_concat_string, string_concat_character, character_concat_string Concatenation operator overloading. generic, public :: operator(.cat.) => string_concat_string_string, string_concat_character_string, character_concat_string_string Concatenation operator (string output) overloading. procedure, public, pass(self) :: sadjustl Adjustl replacement. procedure, public, pass(self) :: sadjustr Adjustr replacement. procedure, public, pass(self) :: scount Count replacement. procedure, public, pass(self) :: sindex Index replacement. procedure, public, pass(self) :: slen Len replacement. procedure, public, pass(self) :: slen_trim Len_trim replacement. procedure, public, nopass :: srepeat Repeat replacement. procedure, public, pass(self) :: sscan Scan replacement. procedure, public, pass(self) :: strim Trim replacement. procedure, public, pass(self) :: sverify Verify replacement. procedure, public, pass(dtv) :: read_formatted => read_formatted_ Formatted input. procedure, public, pass(dtv) :: read_formatted_internal Formatted input from internal. procedure, public, pass(dtv) :: write_formatted => write_formatted_ Formatted output. procedure, public, pass(dtv) :: write_formatted_internal Formatted output to internal. procedure, private, pass(lhs) :: string_assign_string Assignment operator from string input. procedure, private, pass(lhs) :: string_assign_character Assignment operator from character input. procedure, private, pass(lhs) :: string_concat_string Concatenation with string. procedure, private, pass(lhs) :: string_concat_character Concatenation with character. procedure, private, pass(rhs) :: character_concat_string Concatenation with character (inverted). procedure, private, pass(lhs) :: string_concat_string_string Concatenation with string (string output). procedure, private, pass(lhs) :: string_concat_character_string Concatenation with character (string output). procedure, private, pass(rhs) :: character_concat_string_string Concatenation with character (inverted, string output). procedure, private, pass(dtv) :: read_formatted_ Formatted input. procedure, private, pass(dtv) :: write_formatted_ Formatted output. procedure, private, pass(dtv) :: read_unformatted_ Unformatted input. procedure, private, pass(dtv) :: write_unformatted_ Unformatted output. procedure, private, pass(self) :: replace_one_occurrence Replace the first occurrence of substring old by new. Description OOP designed string class. Functions private pure function chars (self) result(raw) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value character(kind=CK,len=:),\n  allocatable Raw characters data. Description Return the raw characters data. private elemental function upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all uppercase characters. private elemental function lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with all lowercase characters. private elemental function capitalize (self) result(capitalized) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a string with its first character capitalized and the rest lowercased. private pure function partition (self, sep) result(partitions) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: sep Separator. Return Value type( string )\n  (1:3) after the separator. Description Split string at separator and return the 3 parts (before, the separator and after). private elemental function replace (self, old, new, count) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. integer, intent(in), optional :: count Number of old occurences to be replaced. Return Value type( string ) The string with old replaced by new. Description Return a string with all occurrences of substring old replaced by new. private elemental function strip (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) The stripped string. Description Return a copy of the string with the leading and trailing characters removed. private elemental function swapcase (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Upper case string. Description Return a copy of the string with uppercase characters converted to lowercase and vice versa. private elemental function unique (self, substring) result(uniq) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in), optional :: substring Substring which multiple occurences must be reduced to one. Return Value type( string ) String parsed. Description Reduce to one (unique) multiple (sequential) occurrences of a substring into a string. private elemental function is_allocated (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if the string is allocated. private elemental function is_digit (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are digits. private elemental function is_upper (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are uppercase. private elemental function is_lower (self) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value logical Result of the test. Description Return true if all characters in the string are lowercase. private elemental function end_with (self, suffix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: suffix Searched suffix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string ends with a specified suffix. private elemental function start_with (self, prefix, start, end) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: prefix Searched prefix. integer, intent(in), optional :: start Start position into the string. integer, intent(in), optional :: end End position into the string. Return Value logical Result of the test. Description Return true if a string starts with a specified prefix. private elemental function sadjustl (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Left adjust a string by removing leading spaces. private elemental function sadjustr (self) result(adjusted) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Adjusted string. Description Right adjust a string by removing leading spaces. private elemental function scount (self, substring, ignore_isolated) result(No) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(len=*), intent(in) :: substring Substring. logical, intent(in), optional :: ignore_isolated Ignore \"isolated\" occurrences. Return Value integer Number of occurrences. Description Count the number of occurences of a substring into a string. private elemental function sindex (self, substring, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: substring Searched substring. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the position of the start of the first occurrence of string substring as a substring in string , counting from one.\n If substring is not present in string , zero is returned. If the back argument is present and true, the return value is\n the start of the last occurrence rather than the first. private elemental function slen (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer String length. Description Return the length of a string. private elemental function slen_trim (self) result(l) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value integer <\np S\nt\nr\ni\nn\ng l\ne\nn\ng\nt\nh\n.\n<\n/\np Description Return the length of a string, ignoring any trailing blanks. private elemental function srepeat (rstring, ncopies) result(repeated) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: rstring String to be repeated. integer, intent(in) :: ncopies Number of string copies. Return Value type( string ) Repeated string. private elemental function sscan (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is in set . private elemental function strim (self) result(trimmed) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. Return Value type( string ) Trimmed string. Description Remove leading spaces. private elemental function sverify (self, set, back) result(i) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: set Searched set. logical, intent(in), optional :: back Start of the last occurrence rather than the first. Return Value integer Result of the search. Description Return the leftmost (if back is either absent or equals false, otherwise the rightmost) character of string that is not\n in set . If all characters of string are found in set , the result is zero. private pure function string_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with string. private pure function string_concat_character (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character. private pure function character_concat_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value character(kind=CK,len=:),\n  allocatable Concatenated string. Description Concatenation with character (inverted). private elemental function string_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with string. private elemental function string_concat_character_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character. private elemental function character_concat_string_string (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name character(kind=CK,len=*), intent(in) :: lhs Left hand side. class( string ), intent(in) :: rhs Right hand side. Return Value type( string ) Concatenated string. Description Concatenation with character (inverted). private elemental function replace_one_occurrence (self, old, new) result(replaced) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. character(kind=CK,len=*), intent(in) :: old Old substring. character(kind=CK,len=*), intent(in) :: new New substring. Return Value type( string ) The string with old replaced by new. Description Return a string with the first occurrence of substring old replaced by new. Subroutines private elemental subroutine free (self) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: self The string. Description Free dynamic memory. private pure subroutine split (self, tokens, sep) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: self The string. type( string ), intent(out), allocatable :: tokens (:) Tokens substring. character(kind=CK,len=*), intent(in), optional :: sep Separator. Description Return a list of substring in the string, using sep as the delimiter string. private elemental subroutine string_assign_string (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. type( string ), intent(in) :: rhs Right hand side. Description Assignment operator from string input. private elemental subroutine string_assign_character (lhs, rhs) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: lhs Left hand side. character(kind=CK,len=*), intent(in) :: rhs Right hand side. Description Assignment operator from character input. private subroutine read_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted input. private subroutine read_formatted_internal (dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. character(kind=CK,len=*), intent(in) :: iunit Internal unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted input from internal. private subroutine write_formatted_ (dtv, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output. private subroutine write_formatted_internal (dtv, iunit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. character(kind=CK,len=*), intent(inout) :: iunit Interanl unit. character(kind=CK,len=*), intent(in) :: iotype Edit descriptor. integer, intent(in) :: v_list (:) Edit descriptor list. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Formatted output to internal. private subroutine read_unformatted_ (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(inout) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted input. private subroutine write_unformatted_ (dtv, unit, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( string ), intent(in) :: dtv The string. integer, intent(in) :: unit Logical unit. integer, intent(out) :: iostat IO status code. character(kind=CK,len=*), intent(inout) :: iomsg IO status message. Description Unformatted output.","tags":"","loc":"module/stringifor.html","title":"stringifor â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~capitalize~~UsesGraph program~capitalize capitalize iso_fortran_env iso_fortran_env iso_fortran_env->program~capitalize module~stringifor stringifor module~stringifor->program~capitalize Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor capitalize test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program capitalize !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `capitalize` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'say all Hello WorLD!' test_passed ( 1 ) = astring % capitalize () // '' == 'Say all hello world!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A)\" ) 'Capitalize: \"' // astring % capitalize () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram capitalize","tags":"","loc":"program/capitalize.html","title":"capitalize â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~concatenation~~UsesGraph program~concatenation concatenation iso_fortran_env iso_fortran_env iso_fortran_env->program~concatenation module~stringifor stringifor module~stringifor->program~concatenation Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor concatenation test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: anotherstring Another string. type( string ) :: yetanotherstring Yet another string. character(len=:), allocatable :: acharacter A character. logical :: test_passed (6) List of passed tests. Source Code program concatenation !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `concatenation` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: anotherstring !< Another string. type ( string ) :: yetanotherstring !< Yet another string. character ( len = :), allocatable :: acharacter !< A character. logical :: test_passed ( 6 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello ' anotherstring = 'Bye bye' acharacter = 'World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // acharacter // '\"' test_passed ( 1 ) = astring // acharacter == 'Hello World!' write ( stdout , \"(A)\" ) astring // acharacter test_passed ( 2 ) = acharacter // astring == 'World!Hello ' write ( stdout , \"(A)\" ) 'Original: \"' // acharacter // '\"+\"' // astring // '\"' write ( stdout , \"(A)\" ) acharacter // astring test_passed ( 3 ) = astring // anotherstring == 'Hello Bye bye' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // anotherstring // '\"' write ( stdout , \"(A)\" ) astring // anotherstring yetanotherstring = astring . cat . acharacter test_passed ( 4 ) = yetanotherstring % chars () == 'Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // acharacter // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = acharacter . cat . astring test_passed ( 5 ) = yetanotherstring % chars () == 'World!Hello ' write ( stdout , \"(A)\" ) 'Original: \"' // acharacter // '\"+\"' // astring // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () yetanotherstring = astring . cat . anotherstring test_passed ( 6 ) = yetanotherstring % chars () == 'Hello Bye bye' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"+\"' // anotherstring // '\"' write ( stdout , \"(A)\" ) yetanotherstring % chars () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram concatenation","tags":"","loc":"program/concatenation.html","title":"concatenation â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~free~~UsesGraph program~free free iso_fortran_env iso_fortran_env iso_fortran_env->program~free module~stringifor stringifor module~stringifor->program~free Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor free test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program free !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `free` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'say all Hello WorLD!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % is_allocated (). eqv .. true . write ( stdout , \"(A,L1)\" ) 'Is allocated? ' , astring % is_allocated () call astring % free test_passed ( 2 ) = astring % is_allocated (). eqv .. false . write ( stdout , \"(A,L1)\" ) 'Is allocated? ' , astring % is_allocated () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram free","tags":"","loc":"program/free.html","title":"free â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~io_basic~~UsesGraph program~io_basic io_basic iso_fortran_env iso_fortran_env iso_fortran_env->program~io_basic module~stringifor stringifor module~stringifor->program~io_basic Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor io_basic test. Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. integer :: iostat IO status code. character(len=99) :: iomsg IO status message. logical :: test_passed (2) List of passed tests. Source Code program io_basic !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `io_basic` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. integer :: iostat !< IO status code. character ( len = 99 ) :: iomsg !< IO status message. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!' acharacter = 'New Hello World!' #ifndef __GFORTRAN__ write ( stdout , \"(DT)\" , iostat = iostat ) astring test_passed ( 1 ) = iostat == 0 read ( acharacter , \"(DT)\" , iostat = iostat ) astring test_passed ( 2 ) = iostat == 0 print \"(DT)\" , astring #else call astring % write_formatted ( stdout , \"(DT)\" , [ 1 ], iostat , iomsg ) test_passed ( 1 ) = iostat == 0 call astring % read_formatted_internal ( acharacter , \"(DT)\" , [ 1 ], iostat , iomsg ) test_passed ( 2 ) = iostat == 0 write ( stdout , \"(A)\" ) astring % chars () #endif write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram io_basic","tags":"","loc":"program/io_basic.html","title":"io_basic â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~is_digit~~UsesGraph program~is_digit is_digit iso_fortran_env iso_fortran_env iso_fortran_env->program~is_digit module~stringifor stringifor module~stringifor->program~is_digit Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor is_digit test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program is_digit !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `is_digit` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   -1212112.3 ' test_passed ( 1 ) = astring % is_digit (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Is digit? ' , astring % is_digit () astring = '12121123' test_passed ( 2 ) = astring % is_digit (). eqv .. true . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'Is digit? ' , astring % is_digit () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram is_digit","tags":"","loc":"program/is_digit.html","title":"is_digit â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~partition~~UsesGraph program~partition partition iso_fortran_env iso_fortran_env iso_fortran_env->program~partition module~stringifor stringifor module~stringifor->program~partition Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor partition test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ) :: strings (3) A set of strings. logical :: test_passed (3) List of passed tests. Source Code program partition !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `partition` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ) :: strings ( 3 ) !< A set of strings. logical :: test_passed ( 3 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' strings = astring % partition ( sep = 'lo Wo' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'Hel' . and . strings ( 2 ) // '' == 'lo Wo' . and . strings ( 3 ) // '' == 'rLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // 'lo Wo' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' strings = astring % partition ( sep = 'Hello' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == '' . and . strings ( 2 ) // '' == 'Hello' . and . strings ( 3 ) // '' == ' WorLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // 'Hello' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' astring = 'Hello WorLD!' strings = astring % partition () test_passed ( 3 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == ' ' . and . strings ( 3 ) // '' == 'WorLD!' ) write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\" separator: \"' // ' ' // '\"' write ( stdout , \"(A)\" ) 'Before sep: \"' // strings ( 1 ) // '\"' write ( stdout , \"(A)\" ) 'Sep itself: \"' // strings ( 2 ) // '\"' write ( stdout , \"(A)\" ) 'After sep:  \"' // strings ( 3 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram partition","tags":"","loc":"program/partition.html","title":"partition â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~replace~~UsesGraph program~replace replace iso_fortran_env iso_fortran_env iso_fortran_env->program~replace module~stringifor stringifor module~stringifor->program~replace Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor replace test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program replace !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `replace` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'When YOU are sad YOU should think to me :-)' write ( stdout , \"(A)\" ) 'Original:                                 \"' // astring // '\"' test_passed ( 1 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' ) // '' == 'When THEY are sad THEY should think to me :-)' ) write ( stdout , \"(A)\" ) 'Replace \"YOU\" with \"THEY\":                \"' // astring % replace ( old = 'YOU' , new = 'THEY' ) // '\"' test_passed ( 2 ) = ( astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '' == 'When THEY are sad YOU should think to me :-)' ) write ( stdout , \"(A)\" ) 'Replace only the first \"YOU\" with \"THEY\": \"' // astring % replace ( old = 'YOU' , new = 'THEY' , count = 1 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram replace","tags":"","loc":"program/replace.html","title":"replace â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sadjustlr~~UsesGraph program~sadjustlr sadjustlr iso_fortran_env iso_fortran_env iso_fortran_env->program~sadjustlr module~stringifor stringifor module~stringifor->program~sadjustlr Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sadjustlr test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program sadjustlr !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sadjustlr` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '   Hello World!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % sadjustl () // '' == 'Hello World!   ' write ( stdout , \"(A)\" ) 'AdjustL:  \"' // astring % sadjustl () // '\"' astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 2 ) = astring % sadjustr () // '' == '   Hello World!' write ( stdout , \"(A)\" ) 'AdjustR:  \"' // astring % sadjustr () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sadjustlr","tags":"","loc":"program/sadjustlr.html","title":"sadjustlr â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sindex~~UsesGraph program~sindex sindex iso_fortran_env iso_fortran_env iso_fortran_env->program~sindex module~stringifor stringifor module~stringifor->program~sindex Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sindex test. Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. character(len=:), allocatable :: anothercharacter Another character. integer :: i Index result. integer :: ic Index result comparison. logical :: test_passed (2) List of passed tests. Source Code program sindex !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sindex` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sindex ( substring = anothercharacter ) ic = index ( string = acharacter , substring = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sindex ( substring = anothercharacter , back = . true .) ic = index ( string = acharacter , substring = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sindex","tags":"","loc":"program/sindex.html","title":"sindex â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~slen~~UsesGraph program~slen slen iso_fortran_env iso_fortran_env iso_fortran_env->program~slen module~stringifor stringifor module~stringifor->program~slen Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor slen test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (2) List of passed tests. Source Code program slen !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `slen` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % slen () == len ( 'Hello World!   ' ) write ( stdout , \"(A,I2)\" ) 'Len: ' , astring % slen () test_passed ( 2 ) = astring % slen_trim () == len_trim ( 'Hello World!   ' ) write ( stdout , \"(A,I2)\" ) 'Len_trim: ' , astring % slen_trim () write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram slen","tags":"","loc":"program/slen.html","title":"slen â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~split~~UsesGraph program~split split iso_fortran_env iso_fortran_env iso_fortran_env->program~split module~stringifor stringifor module~stringifor->program~split Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor split test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ), allocatable :: strings (:) A set of strings. logical :: test_passed (5) List of passed tests. integer :: s Counter. Source Code program split !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `split` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. logical :: test_passed ( 5 ) !< List of passed tests. integer :: s !< Counter. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = '+ab-++cre-++cre-ab+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 1 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'ab-++cre-++cre-ab+' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 2 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'ab-++cre-++cre-ab' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"+\"' call astring % split ( tokens = strings , sep = '+' ) test_passed ( 3 ) = ( strings ( 1 ) // '' == 'ab-' . and . strings ( 2 ) // '' == 'cre-' . and . strings ( 3 ) // '' == 'cre-ab' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'Hello ' // new_line ( 'a' ) // 'World!' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"new_line\"' call astring % split ( tokens = strings , sep = new_line ( 'a' )) test_passed ( 4 ) = ( strings ( 1 ) // '' == 'Hello ' . and . strings ( 2 ) // '' == 'World!' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo astring = 'Hello World!' write ( stdout , \"(A)\" ) 'Split \"' // astring // '\" at \"default\" (namely space)' call astring % split ( tokens = strings ) test_passed ( 5 ) = ( strings ( 1 ) // '' == 'Hello' . and . strings ( 2 ) // '' == 'World!' ) do s = 1 , size ( strings ) write ( stdout , \"(A)\" ) '+ \"' // strings ( s ) // '\"' enddo write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram split","tags":"","loc":"program/split.html","title":"split â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~srepeat~~UsesGraph program~srepeat srepeat iso_fortran_env iso_fortran_env iso_fortran_env->program~srepeat module~stringifor stringifor module~stringifor->program~srepeat Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor srepeat test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program srepeat !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `srepeat` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . test_passed ( 1 ) = astring % srepeat ( rstring = 'x' , ncopies = 5 ) // '' == 'xxxxx' write ( stdout , \"(A,I2)\" ) 'Repeat x 5 times: \"' // astring % srepeat ( rstring = 'x' , ncopies = 5 ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram srepeat","tags":"","loc":"program/srepeat.html","title":"srepeat â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sscan~~UsesGraph program~sscan sscan iso_fortran_env iso_fortran_env iso_fortran_env->program~sscan module~stringifor stringifor module~stringifor->program~sscan Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sscan test. Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. character(len=:), allocatable :: anothercharacter Another character. integer :: i Index result. integer :: ic Index result comparison. logical :: test_passed (2) List of passed tests. Source Code program sscan !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sscan` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. logical :: test_passed ( 2 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sscan ( set = anothercharacter ) ic = scan ( string = acharacter , set = anothercharacter ) test_passed ( 1 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sscan ( set = anothercharacter , back = . true .) ic = scan ( string = acharacter , set = anothercharacter , back = . true .) test_passed ( 2 ) = i == ic write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sscan","tags":"","loc":"program/sscan.html","title":"sscan â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~start_end~~UsesGraph program~start_end start_end iso_fortran_env iso_fortran_env iso_fortran_env->program~start_end module~stringifor stringifor module~stringifor->program~start_end Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor start_end test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (8) List of passed tests. Source Code program start_end !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `start_end` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % start_with ( prefix = 'Hello' ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'start with \"Hello\"? ' , astring % start_with ( prefix = 'Hello' ) test_passed ( 2 ) = astring % start_with ( prefix = 'hell' ). eqv .. false . write ( stdout , \"(A,L1)\" ) 'start with \"hell\"? ' , astring % start_with ( prefix = 'hell' ) test_passed ( 3 ) = astring % start_with ( prefix = 'llo Wor' , start = 3 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (3:) start with \"llo Wor\"? ' , astring % start_with ( prefix = 'llo Wor' , start = 3 ) test_passed ( 4 ) = astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (4:7) start with \"lo W\"? ' , astring % start_with ( prefix = 'lo W' , start = 4 , end = 7 ) test_passed ( 5 ) = astring % end_with ( suffix = 'LD!' ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'end with \"LD!\"? ' , astring % end_with ( suffix = 'LD!' ) test_passed ( 6 ) = astring % end_with ( suffix = 'lD!' ). eqv .. false . write ( stdout , \"(A,L1)\" ) 'end with \"lD!\"? ' , astring % end_with ( suffix = 'lD!' ) test_passed ( 7 ) = astring % end_with ( suffix = 'orLD!' , start = 5 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (5:) end with \"orLD!\"? ' , astring % end_with ( suffix = 'orLD!' , start = 5 ) test_passed ( 8 ) = astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ). eqv .. true . write ( stdout , \"(A,L1)\" ) 'slice (8:12) end with \"orLD!\"? ' , astring % end_with ( suffix = 'orLD!' , start = 8 , end = 12 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram start_end","tags":"","loc":"program/start_end.html","title":"start_end â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~strim~~UsesGraph program~strim strim iso_fortran_env iso_fortran_env iso_fortran_env->program~strim module~stringifor stringifor module~stringifor->program~strim Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor strim test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1) List of passed tests. Source Code program strim !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strim` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % strim () // '' == 'Hello World!' write ( stdout , \"(A)\" ) 'Trimmed:  \"' // astring % strim () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strim","tags":"","loc":"program/strim.html","title":"strim â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~strip~~UsesGraph program~strip strip iso_fortran_env iso_fortran_env iso_fortran_env->program~strip module~stringifor stringifor module~stringifor->program~strip Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor strip test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ), allocatable :: strings (:) A set of strings. integer :: s Counter. logical :: test_passed (1) List of passed tests. Source Code program strip !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `strip` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. integer :: s !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . write ( stdout , \"(A)\" ) new_line ( 'A' ) // 'Strip' astring = '  Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % strip () // '' == 'Hello World!' write ( stdout , \"(A)\" ) 'Strip:    \"' // astring % strip () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram strip","tags":"","loc":"program/strip.html","title":"strip â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~sverify~~UsesGraph program~sverify sverify iso_fortran_env iso_fortran_env iso_fortran_env->program~sverify module~stringifor stringifor module~stringifor->program~sverify Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor sverify test. Variables Type Attributes Name Initial type( string ) :: astring A string. character(len=:), allocatable :: acharacter A character. character(len=:), allocatable :: anothercharacter Another character. integer :: i Index result. integer :: ic Index result comparison. Source Code program sverify !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `sverify` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. character ( len = :), allocatable :: acharacter !< A character. character ( len = :), allocatable :: anothercharacter !< Another character. integer :: i !< Index result. integer :: ic !< Index result comparison. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- acharacter = 'Hello World Hello!' anothercharacter = 'llo' astring = acharacter i = astring % sverify ( set = anothercharacter ) ic = verify ( string = acharacter , set = anothercharacter ) write ( stdout , \"(A,I2,A,L1)\" ) 'Basic call result: ' , i , ' is correct? ' , i == ic i = astring % sverify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) write ( stdout , \"(A,I2,A,L1)\" ) 'Back call result: ' , i , ' is correct? ' , i == ic anothercharacter = acharacter i = astring % sverify ( set = anothercharacter , back = . true .) ic = verify ( string = acharacter , set = anothercharacter , back = . true .) write ( stdout , \"(A,I2,A,L1)\" ) 'Identical strings call result: ' , i , ' is correct? ' , i == ic stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram sverify","tags":"","loc":"program/sverify.html","title":"sverify â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~swapcase~~UsesGraph program~swapcase swapcase iso_fortran_env iso_fortran_env iso_fortran_env->program~swapcase module~stringifor stringifor module~stringifor->program~swapcase Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor swapcase test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ), allocatable :: strings (:) A set of strings. integer :: s Counter. logical :: test_passed (1) List of passed tests. Source Code program swapcase !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `swapcase` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. integer :: s !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . write ( stdout , \"(A)\" ) new_line ( 'A' ) // 'Swapcase' astring = '  Hello World!   ' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % swapcase () // '' == '  hELLO wORLD!   ' write ( stdout , \"(A)\" ) 'Swapcase: \"' // astring % swapcase () // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram swapcase","tags":"","loc":"program/swapcase.html","title":"swapcase â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~unique~~UsesGraph program~unique unique iso_fortran_env iso_fortran_env iso_fortran_env->program~unique module~stringifor stringifor module~stringifor->program~unique Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor unique test. Variables Type Attributes Name Initial type( string ) :: astring A string. type( string ), allocatable :: strings (:) A set of strings. integer :: s Counter. logical :: test_passed (1) List of passed tests. Source Code program unique !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `unique` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. type ( string ), allocatable :: strings (:) !< A set of strings. integer :: s !< Counter. logical :: test_passed ( 1 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . write ( stdout , \"(A)\" ) new_line ( 'A' ) // 'Unique' astring = '+++ab-++cre-++cre-ab+++++' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' test_passed ( 1 ) = astring % unique ( substring = '+' ) // '' == '+ab-+cre-+cre-ab+' write ( stdout , \"(A)\" ) 'Unique:   \"' // astring % unique ( substring = '+' ) // '\"' write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram unique","tags":"","loc":"program/unique.html","title":"unique â€“ StringiFor"},{"text":"Uses: iso_fortran_env stringifor program~~upper_lower~~UsesGraph program~upper_lower upper_lower iso_fortran_env iso_fortran_env iso_fortran_env->program~upper_lower module~stringifor stringifor module~stringifor->program~upper_lower Help Ã— Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. StringiFor upper_lower test. Variables Type Attributes Name Initial type( string ) :: astring A string. logical :: test_passed (1:8) List of passed tests. Source Code program upper_lower !----------------------------------------------------------------------------------------------------------------------------------- !< StringiFor `upper_lower` test. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : stdout => output_unit use stringifor , only : string !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none type ( string ) :: astring !< A string. logical :: test_passed ( 1 : 8 ) !< List of passed tests. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- test_passed = . false . astring = 'Hello WorLD!' test_passed ( 1 ) = astring % upper () // '' == 'HELLO WORLD!' test_passed ( 2 ) = astring % lower () // '' == 'hello world!' write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1)\" ) 'UPPER:    \"' // astring % upper () // '\". Is correct? ' , test_passed ( 1 ) write ( stdout , \"(A,L1)\" ) 'lower:    \"' // astring % lower () // '\". Is correct? ' , test_passed ( 2 ) astring = ' Hello World' test_passed ( 3 ) = astring % is_upper (). eqv .. false . test_passed ( 4 ) = astring % is_lower (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 3 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 4 ) astring = ' HELLO WORLD' test_passed ( 5 ) = astring % is_upper (). eqv .. true . test_passed ( 6 ) = astring % is_lower (). eqv .. false . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 5 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 6 ) astring = ' hello world' test_passed ( 7 ) = astring % is_upper (). eqv .. false . test_passed ( 8 ) = astring % is_lower (). eqv .. true . write ( stdout , \"(A)\" ) 'Original: \"' // astring // '\"' write ( stdout , \"(A,L1,A,L1)\" ) 'Is UPPER? ' , astring % is_upper (), '. Is correct? ' , test_passed ( 7 ) write ( stdout , \"(A,L1,A,L1)\" ) 'Is lower? ' , astring % is_lower (), '. Is correct? ' , test_passed ( 8 ) write ( stdout , \"(A,L1)\" ) new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) stop !----------------------------------------------------------------------------------------------------------------------------------- endprogram upper_lower","tags":"","loc":"program/upper_lower.html","title":"upper_lower â€“ StringiFor"}]}